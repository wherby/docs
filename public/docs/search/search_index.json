{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Docs"},{"location":"/index.html#docs","text":"This is the introduction for doradilla library.\nSingle truth principle Database Single truth principle Database null field error Engagement entity add to database Slick query overflow Shadow query Inconsistent status Daily schedule job Oauth2 client for Pac4j NIO and Akka-Http Store file in database Flyway clean failed on mysql8 IE issues for javascript Api call failed software architecture Excel reader using POI Future value Lockless design Upgrade issue for authentication DB bulk insert React web render Out of memory for batch job Pure function design Code issue Timeout errors and crash Refactor code for Excel output Refine code with function programming Traps in Scala JVM allocate memory failed in docker How to structure a extractor process. Bugs Code design Speed up python by remove enclosure Issues","title":"Docs"},{"location":"/singletruthprinciple.html","text":"","title":"Single truth principle"},{"location":"/singletruthprinciple.html#single-truth-principle","text":"","title":"Single truth principle"},{"location":"/database/index.html","text":"","title":"Database Single truth principle"},{"location":"/database/index.html#database-single-truth-principle","text":"DB service","title":"Database Single truth principle"},{"location":"/database/dbservice.html","text":"","title":"DB service"},{"location":"/database/dbservice.html#db-service","text":"In traditional way, the database service will be implemented in this way:\nController import scala.concurrent.ExecutionContext\n\n@Singleton\nclass UserController @Inject()(userServiceRead: UserRead,\n                               userServiceWrite: UserWrite,\n                                ...)\n                              (implicit ec: ExecutionContext) extends AbstractController(cc) {\n    ...\n\n} Database package db\n\nimport scala.concurrent.Future\n\n\ntrait UserDAO {\n  def lookup(id: String): Future[Option[User]]\n\n  def create(user: User): Future[Int]\n    ...\n\n}\n\n\ncase class User(id: String, email: String)\n\n\n Database impl package db.impl\n\nclass SlickUserDAO @Inject()(db: Database)(implicit ec: ExecutionContext) extends UserDAO with DbTables {\n\n  import profile.api._\n\n  override def lookup(id: String): Future[Option[User]] = {\n    val f: Future[Option[UsersRow]] = db.run(queryById(id).result.headOption)\n    f.map { maybeRow => maybeRow.map(usersRowToUser) }\n  }\n\n  override def create(user: User): Future[Int] = {\n    db.run(\n      Users += userToUsersRow(user)\n    )\n  }\n\n  ...\n}\n Read package service\n\n  ...\n\ntrait UserRead {\n  def lookup(id: String): Future[Option[User]]\n} Read Impl package service.impl\n\nimport scala.concurrent.ExecutionContext\n\nclass UserReadImpl @Inject()(userDAO: UserDAO)(implicit ec: ExecutionContext) extends UserRead {\n  override def lookup(id: String): Future[Option[User]] = {\n    userDAO.lookup(id)\n  }\n} Write package service\n\ntrait UserWrite {\n  def create(user: User): Future[Int]\n} Write Impl package service.impl\n\n\n@Singleton\nclass UserWriteImpl @Inject()(userDAO: UserDAO)(implicit ec: ExecutionContext) extends UserWrite {\n  override def create(user: User): Future[Int] = {\n    userDAO.create(user)\n  }\n} Module class Module(environment: Environment,\n             configuration: Configuration) extends AbstractModule {\n  override def configure(): Unit = {\n      ...\n    bind(classOf[UserDAO]).to(classOf[SlickUserDAO])\n    bind(classOf[UserRead]).to(classOf[UserReadImpl])\n    bind(classOf[UserWrite]).to(classOf[UserWriteImpl])\n      ...\n  }\n}","title":"DB service"},{"location":"/fieldnull/index.html","text":"","title":"Database null field error"},{"location":"/fieldnull/index.html#database-null-field-error","text":"","title":"Database null field error"},{"location":"/fieldnull/index.html#user-bug-report","text":"User report error when they want to define report types for fund in engagemnt:\nWhen check the request in the network:\nCompare with valid request in network:\nWe will find that id is missing in the payload.","title":"User bug report"},{"location":"/fieldnull/index.html#database-check","text":"Check the database:\nIt seems the fund_admin_id field is null, we fix this issue, then user could define report types now. But we check the production database, we will find the field will be set to null by application:\n4:20:13 PM: mysql> SELECT id,fund_admin_id,fund_admin FROM awm.funds;\n+--------------------------------------+---------------+-----------------+\n| id                                   | fund_admin_id | fund_admin      |\n+--------------------------------------+---------------+-----------------+\n| 02635de9-97d8-4520-90f3-68a53e3d6518 | 1             | HSBC IMS        |\n| 03361d5c-531e-411f-8a57-e02eaffa81e7 | 1             | HSBC IMS        |\n\n\n| 8be5db7b-3358-4e3d-a572-839f2f765ed9 | 1             | HSBC IMS        |\n| 918bb23a-c5ff-4a91-a822-bf8f8416fadd | 1             | HSBC IMS        |\n| 930131cb-9c91-44b0-88e7-12460949dcae | 1             | HSBC IMS        |\n| 961c5a46-9a87-4084-ac0d-408c436522d8 | 1             | HSBC IMS        |\n| a6e44dc6-b72e-4b23-8d1d-b885c8561e83 | 2             | HSBC MultiFonds |\n| b1109ece-7686-4efb-93d6-81e00356c736 | 1             | HSBC IMS        |\n| b8c1cb44-c60e-482c-9b7f-67abc6165a75 | 1             | HSBC IMS        |    ********\n| be3de937-5c8a-45d7-8619-047a50785430 | 1             | HSBC IMS        |\n| cb4c2be3-78b4-4edb-b08f-11b66fb4ee1e | 1             | HSBC IMS        |\n| d2bbb0ec-50c1-44b6-8039-686daf8e137f | 1             | HSBC IMS        |\n| ebbae85a-52f1-4445-9dbb-79e6d2bd8db1 | 1             | HSBC IMS        |\n| f872f26e-21fe-4d12-b23e-baa0635d8ebf | 3             | HSBC Geneva     |\n| f9c9eb38-7a1c-43c0-9678-c4562594449b | 1             | HSBC IMS        |\n| fb488f25-d2e8-47d2-9090-6807c9960c01 | 1             | HSBC IMS        |\n| fbec119f-7e68-4cbc-905b-b40db35f0a2f | 1             | HSBC IMS        |\n+--------------------------------------+---------------+-----------------+\n43 rows in set (0.00 sec) \n\n\n\n5:38:27 PM: mysql> SELECT id,fund_admin_id,fund_admin FROM awm.funds; \n+--------------------------------------+---------------+-----------------+\n| id                                   | fund_admin_id | fund_admin      |\n+--------------------------------------+---------------+-----------------+\n| 02635de9-97d8-4520-90f3-68a53e3d6518 | 1             | HSBC IMS        |\n| 03361d5c-531e-411f-8a57-e02eaffa81e7 | 1             | HSBC IMS        |\n| 049d9aa4-2822-4bcd-8ec7-1b6bef3cd628 | 1             | HSBC IMS        |\n| 0a1938df-a03a-45c8-8c3a-86e4bd52d92c | 1             | HSBC IMS        |\n\n\n| 961c5a46-9a87-4084-ac0d-408c436522d8 | 1             | HSBC IMS        |\n| a6e44dc6-b72e-4b23-8d1d-b885c8561e83 | 2             | HSBC MultiFonds |\n| b1109ece-7686-4efb-93d6-81e00356c736 | 1             | HSBC IMS        |\n| b42ab859-ff5a-4fe0-b283-fe0c98c88392 | 1             | HSBC IMS        |\n| b8c1cb44-c60e-482c-9b7f-67abc6165a75 | NULL          | HSBC IMS        |   ********\n| be3de937-5c8a-45d7-8619-047a50785430 | 1             | HSBC IMS        |\n| cb4c2be3-78b4-4edb-b08f-11b66fb4ee1e | 1             | HSBC IMS        |\n| d2bbb0ec-50c1-44b6-8039-686daf8e137f | 1             | HSBC IMS        |\n| ebbae85a-52f1-4445-9dbb-79e6d2bd8db1 | 1             | HSBC IMS        |\n| f872f26e-21fe-4d12-b23e-baa0635d8ebf | 3             | HSBC Geneva     |\n| f9c9eb38-7a1c-43c0-9678-c4562594449b | 1             | HSBC IMS        |\n| fb488f25-d2e8-47d2-9090-6807c9960c01 | 1             | HSBC IMS        |\n| fbec119f-7e68-4cbc-905b-b40db35f0a2f | 1             | HSBC IMS        |\n+--------------------------------------+---------------+-----------------+\n44 rows in set (0.00 sec)","title":"Database check"},{"location":"/fieldnull/index.html#database-define","text":"The database define as below:\nFund create table `funds`(\n   `id` varchar(128) NOT NULL,\n   `name` VARCHAR(128) not null,\n    fund_admin_id varchar(128) null,\n   `fund_type` VARCHAR(128) not null,\n   `legal_structure` VARCHAR(128) not null,\n   `base_currency` VARCHAR(128) not null,\n   `audit_period_begin` TIMESTAMP not null,\n   `audit_period_end` TIMESTAMP not null,\n   `fund_admin` VARCHAR(128) not null,\n   `admin_code` VARCHAR(128) NULL,\n   `createby` VARCHAR(128) NULL,\n   `createdatetime`  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,\n   `modifyby` VARCHAR(128) NULL,\n   `modifydatetime`  TIMESTAMP  NULL,\n   PRIMARY KEY (`id`)\n) FundAdmin create table `fund_admin`(\n    `id` varchar(128) NOT NULL,\n    `name` varchar(128) NOT NULL,\n    PRIMARY KEY (`id`)\n)","title":"Database define"},{"location":"/fieldnull/index.html#code-check","text":"The field fund_admin_id in fund table is queried from fund admin table.\nCreate fund override def create(fund: Fund, engagementId:String): Future[Int] = {\n  engagementDAO.lookup(engagementId).flatMap(maybeEngagement => {\n    maybeEngagement match {\n      case engagement => {\n        fundAdminDAO.queryByFundAdmin(fund.fundAdmin).flatMap(optionFundAdmin => {\n          optionFundAdmin match {\n            case Some(fundAdmin) => {\n              fund.fundAdminId = Some(fundAdmin.id)\n              fundsDAO.create(fund, engagementId)\n            }\n            case _ =>{\n              throw new Exception(s\"fund admin doesn't exist\")\n            }\n          }\n        }).flatMap(resFund => {\n          var fundEngagement = new FundEngagementData(randomUUID().toString, engagementId, resFund.id, None, resFund.createby, Some(new Timestamp(DateTime.now.getMillis)))\n          fundEngagementDAO.create(fundEngagement)\n        })\n      }\n      case _ => {\n        throw new Exception(s\"engagement with this Id doesn't exist\")\n      }\n    }\n  })\n}\n Update fund override def update(fund: Fund): Future[Int] = {\n  fundsDAO.lookup(fund.id).flatMap(maybeFund => {\n    maybeFund match {\n\n      //if fundAdmin changed, should update fund admin id and remove fund selection types\n      case Some(existingFund) if(existingFund.fundAdmin != fund.fundAdmin) => {\n        fundAdminDAO.queryByFundAdmin(fund.fundAdmin).flatMap(optionFundAdmin => {\n          optionFundAdmin match {\n            case Some(fundAdmin) => {\n              fund.fundAdminId = Some(fundAdmin.id)\n              fundsDAO.update(fund).flatMap(updateResult => {\n                fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n                  fundEngagementReportTypeSelectionDAO.deleteByEngagementIds(engagements.map(_.id))\n                })\n              })\n            }\n            case _ =>{\n              throw new Exception(s\"fund admin doesn't exist\")\n            }\n          }\n        })\n      }\n      //if fund audit period or accurency changed, should clear uploaded reports and ega.\n      case Some(exisitingFund) if(!exisitingFund.auditPeriodBegin.equals(fund.auditPeriodBegin) || !exisitingFund.auditPeriodEnd.equals(fund.auditPeriodEnd) || !exisitingFund.baseCurrency.equals(fund.baseCurrency)) => {\n        fundsDAO.update(fund).flatMap(res =>fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements =>{\n          fundEngagementReportTypeSelectionWrite.clearUploadedReports(engagements.map(_.id)).flatMap(result =>{\n            egaWrite.cleanEGAByFundEngagementId(engagements.map(_.id))\n          })\n        }))\n      }\n      case Some(existingFund) => {\n        fundsDAO.update(fund)\n      }\n      case _ => {\n        throw new Exception(s\"fund  ${fund.name} doesn't exist\")\n      }\n    }\n  })\n}\nThen we find in update fund, the second branch doesn’t retrieve fund_admin_id, so this may lead the null field\nSo we need to fix the issue by add query:\nFix one: by add query for second branch override def update(fund: Fund): Future[Int] = {\n  fundsDAO.lookup(fund.id).flatMap(maybeFund => {\n    maybeFund match {\n\n      //if fundAdmin changed, should update fund admin id and remove fund selection types\n      case Some(existingFund) if(existingFund.fundAdmin != fund.fundAdmin) => {\n        fundAdminDAO.queryByFundAdmin(fund.fundAdmin).flatMap(optionFundAdmin => {\n          optionFundAdmin match {\n            case Some(fundAdmin) => {\n              fund.fundAdminId = Some(fundAdmin.id)\n              fundsDAO.update(fund).flatMap(updateResult => {\n                fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n                  fundEngagementReportTypeSelectionDAO.deleteByEngagementIds(engagements.map(_.id))\n                })\n              })\n            }\n            case _ =>{\n              throw new Exception(s\"fund admin doesn't exist\")\n            }\n          }\n        })\n      }\n      //if fund audit period or accurency changed, should clear uploaded reports and ega.\n      case Some(exisitingFund) if(!exisitingFund.auditPeriodBegin.equals(fund.auditPeriodBegin) || !exisitingFund.auditPeriodEnd.equals(fund.auditPeriodEnd) || !exisitingFund.baseCurrency.equals(fund.baseCurrency)) => {\n        fundAdminDAO.queryByFundAdmin(fund.fundAdmin).flatMap(optionFundAdmin => {\n          optionFundAdmin match {\n            case Some(fundAdmin) => {\n              fundsDAO.update(fund).flatMap(res => fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n                fundEngagementReportTypeSelectionWrite.clearUploadedReports(engagements.map(_.id)).flatMap(result => {\n                  egaWrite.cleanEGAByFundEngagementId(engagements.map(_.id))\n                })\n              }))\n            }\n            case _ => {\n              throw new Exception(s\"fund admin doesn't exist\")\n            }\n          }\n        })\n      }\n      case Some(existingFund) => {\n        fundsDAO.update(fund)\n      }\n      case _ => {\n        throw new Exception(s\"fund  ${fund.name} doesn't exist\")\n      }\n    }\n  })\n} Fix two: by add shared query override def update(fund: Fund): Future[Int] = {\n  val newFundFuture =  fundAdminDAO.queryByFundAdmin(fund.fundAdmin).map{\n    tmpOpt =>tmpOpt match{\n      case Some(fundAdmin)=>fund.copy(fundAdminId = Some(fundAdmin.id))\n      case _=>fund\n    }\n  }\n  val newFund = Await.result(newFundFuture, 1 second)\n\n  fundsDAO.lookup(fund.id).flatMap(maybeFund => {\n    maybeFund match {\n\n      //if fundAdmin changed, should update fund admin id and remove fund selection types\n      case Some(existingFund) if(existingFund.fundAdmin != fund.fundAdmin) => {\n        fundsDAO.update(newFund).flatMap(updateResult => {\n          fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n            fundEngagementReportTypeSelectionDAO.deleteByEngagementIds(engagements.map(_.id))\n          })\n        })\n      }\n      //if fund audit period or accurency changed, should clear uploaded reports and ega.\n      case Some(exisitingFund) if(!exisitingFund.auditPeriodBegin.equals(fund.auditPeriodBegin) || !exisitingFund.auditPeriodEnd.equals(fund.auditPeriodEnd) || !exisitingFund.baseCurrency.equals(fund.baseCurrency)) => {\n        fundsDAO.update(newFund).flatMap(res => fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n          fundEngagementReportTypeSelectionWrite.clearUploadedReports(engagements.map(_.id)).flatMap(result => {\n            egaWrite.cleanEGAByFundEngagementId(engagements.map(_.id))\n          })\n        }))\n      }\n      case Some(existingFund) => {\n        fundsDAO.update(newFund)\n      }\n      case _ => {\n        throw new Exception(s\"fund  ${fund.name} doesn't exist\")\n      }\n    }\n  })\n}","title":"Code check"},{"location":"/fieldnull/index.html#after-fix","text":"Question 1, what’s the root cause of the issue?\nThe Fund table contains redundant information of FundAdmin table The update function has multiple paths, and don’t use shared function The shared function should in out of update scope.\nQuestion 2, how to use the single truth principle to resolve issues above?","title":"After fix"},{"location":"/fieldnull/code/index.html","text":"","title":"Database define"},{"location":"/fieldnull/code/index.html#database-define","text":"The database define as below:\nFund create table `funds`(\n   `id` varchar(128) NOT NULL,\n   `name` VARCHAR(128) not null,\n    fund_admin_id varchar(128) null,\n   `fund_type` VARCHAR(128) not null,\n   `legal_structure` VARCHAR(128) not null,\n   `base_currency` VARCHAR(128) not null,\n   `audit_period_begin` TIMESTAMP not null,\n   `audit_period_end` TIMESTAMP not null,\n   `fund_admin` VARCHAR(128) not null,\n   `admin_code` VARCHAR(128) NULL,\n   `createby` VARCHAR(128) NULL,\n   `createdatetime`  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,\n   `modifyby` VARCHAR(128) NULL,\n   `modifydatetime`  TIMESTAMP  NULL,\n   PRIMARY KEY (`id`)\n) FundAdmin create table `fund_admin`(\n    `id` varchar(128) NOT NULL,\n    `name` varchar(128) NOT NULL,\n    PRIMARY KEY (`id`)\n)","title":"Database define"},{"location":"/fieldnull/code/index.html#code-check","text":"The field fund_admin_id in fund table is queried from fund admin table.\nCreate fund override def create(fund: Fund, engagementId:String): Future[Int] = {\n  engagementDAO.lookup(engagementId).flatMap(maybeEngagement => {\n    maybeEngagement match {\n      case engagement => {\n        fundAdminDAO.queryByFundAdmin(fund.fundAdmin).flatMap(optionFundAdmin => {\n          optionFundAdmin match {\n            case Some(fundAdmin) => {\n              fund.fundAdminId = Some(fundAdmin.id)\n              fundsDAO.create(fund, engagementId)\n            }\n            case _ =>{\n              throw new Exception(s\"fund admin doesn't exist\")\n            }\n          }\n        }).flatMap(resFund => {\n          var fundEngagement = new FundEngagementData(randomUUID().toString, engagementId, resFund.id, None, resFund.createby, Some(new Timestamp(DateTime.now.getMillis)))\n          fundEngagementDAO.create(fundEngagement)\n        })\n      }\n      case _ => {\n        throw new Exception(s\"engagement with this Id doesn't exist\")\n      }\n    }\n  })\n}\n Update fund override def update(fund: Fund): Future[Int] = {\n  fundsDAO.lookup(fund.id).flatMap(maybeFund => {\n    maybeFund match {\n\n      //if fundAdmin changed, should update fund admin id and remove fund selection types\n      case Some(existingFund) if(existingFund.fundAdmin != fund.fundAdmin) => {\n        fundAdminDAO.queryByFundAdmin(fund.fundAdmin).flatMap(optionFundAdmin => {\n          optionFundAdmin match {\n            case Some(fundAdmin) => {\n              fund.fundAdminId = Some(fundAdmin.id)\n              fundsDAO.update(fund).flatMap(updateResult => {\n                fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n                  fundEngagementReportTypeSelectionDAO.deleteByEngagementIds(engagements.map(_.id))\n                })\n              })\n            }\n            case _ =>{\n              throw new Exception(s\"fund admin doesn't exist\")\n            }\n          }\n        })\n      }\n      //if fund audit period or accurency changed, should clear uploaded reports and ega.\n      case Some(exisitingFund) if(!exisitingFund.auditPeriodBegin.equals(fund.auditPeriodBegin) || !exisitingFund.auditPeriodEnd.equals(fund.auditPeriodEnd) || !exisitingFund.baseCurrency.equals(fund.baseCurrency)) => {\n        fundsDAO.update(fund).flatMap(res =>fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements =>{\n          fundEngagementReportTypeSelectionWrite.clearUploadedReports(engagements.map(_.id)).flatMap(result =>{\n            egaWrite.cleanEGAByFundEngagementId(engagements.map(_.id))\n          })\n        }))\n      }\n      case Some(existingFund) => {\n        fundsDAO.update(fund)\n      }\n      case _ => {\n        throw new Exception(s\"fund  ${fund.name} doesn't exist\")\n      }\n    }\n  })\n}\nThen we find in update fund, the second branch doesn’t retrieve fund_admin_id, so this may lead the null field\nSo we need to fix the issue by add query:\nFix one: by add query for second branch override def update(fund: Fund): Future[Int] = {\n  fundsDAO.lookup(fund.id).flatMap(maybeFund => {\n    maybeFund match {\n\n      //if fundAdmin changed, should update fund admin id and remove fund selection types\n      case Some(existingFund) if(existingFund.fundAdmin != fund.fundAdmin) => {\n        fundAdminDAO.queryByFundAdmin(fund.fundAdmin).flatMap(optionFundAdmin => {\n          optionFundAdmin match {\n            case Some(fundAdmin) => {\n              fund.fundAdminId = Some(fundAdmin.id)\n              fundsDAO.update(fund).flatMap(updateResult => {\n                fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n                  fundEngagementReportTypeSelectionDAO.deleteByEngagementIds(engagements.map(_.id))\n                })\n              })\n            }\n            case _ =>{\n              throw new Exception(s\"fund admin doesn't exist\")\n            }\n          }\n        })\n      }\n      //if fund audit period or accurency changed, should clear uploaded reports and ega.\n      case Some(exisitingFund) if(!exisitingFund.auditPeriodBegin.equals(fund.auditPeriodBegin) || !exisitingFund.auditPeriodEnd.equals(fund.auditPeriodEnd) || !exisitingFund.baseCurrency.equals(fund.baseCurrency)) => {\n        fundAdminDAO.queryByFundAdmin(fund.fundAdmin).flatMap(optionFundAdmin => {\n          optionFundAdmin match {\n            case Some(fundAdmin) => {\n              fundsDAO.update(fund).flatMap(res => fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n                fundEngagementReportTypeSelectionWrite.clearUploadedReports(engagements.map(_.id)).flatMap(result => {\n                  egaWrite.cleanEGAByFundEngagementId(engagements.map(_.id))\n                })\n              }))\n            }\n            case _ => {\n              throw new Exception(s\"fund admin doesn't exist\")\n            }\n          }\n        })\n      }\n      case Some(existingFund) => {\n        fundsDAO.update(fund)\n      }\n      case _ => {\n        throw new Exception(s\"fund  ${fund.name} doesn't exist\")\n      }\n    }\n  })\n} Fix two: by add shared query override def update(fund: Fund): Future[Int] = {\n  val newFundFuture =  fundAdminDAO.queryByFundAdmin(fund.fundAdmin).map{\n    tmpOpt =>tmpOpt match{\n      case Some(fundAdmin)=>fund.copy(fundAdminId = Some(fundAdmin.id))\n      case _=>fund\n    }\n  }\n  val newFund = Await.result(newFundFuture, 1 second)\n\n  fundsDAO.lookup(fund.id).flatMap(maybeFund => {\n    maybeFund match {\n\n      //if fundAdmin changed, should update fund admin id and remove fund selection types\n      case Some(existingFund) if(existingFund.fundAdmin != fund.fundAdmin) => {\n        fundsDAO.update(newFund).flatMap(updateResult => {\n          fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n            fundEngagementReportTypeSelectionDAO.deleteByEngagementIds(engagements.map(_.id))\n          })\n        })\n      }\n      //if fund audit period or accurency changed, should clear uploaded reports and ega.\n      case Some(exisitingFund) if(!exisitingFund.auditPeriodBegin.equals(fund.auditPeriodBegin) || !exisitingFund.auditPeriodEnd.equals(fund.auditPeriodEnd) || !exisitingFund.baseCurrency.equals(fund.baseCurrency)) => {\n        fundsDAO.update(newFund).flatMap(res => fundEngagementDAO.queryByFundId(fund.id).flatMap(engagements => {\n          fundEngagementReportTypeSelectionWrite.clearUploadedReports(engagements.map(_.id)).flatMap(result => {\n            egaWrite.cleanEGAByFundEngagementId(engagements.map(_.id))\n          })\n        }))\n      }\n      case Some(existingFund) => {\n        fundsDAO.update(newFund)\n      }\n      case _ => {\n        throw new Exception(s\"fund  ${fund.name} doesn't exist\")\n      }\n    }\n  })\n}","title":"Code check"},{"location":"/fieldnull/code/index.html#after-fix","text":"Question 1, what’s the root cause of the issue?\nThe Fund table contains redundant information of FundAdmin table The update function has multiple paths, and don’t use shared function The shared function should in out of update scope.\nQuestion 2, how to use the single truth principle to resolve issues above?","title":"After fix"},{"location":"/engagement/index.html","text":"","title":"Engagement entity add to database"},{"location":"/engagement/index.html#engagement-entity-add-to-database","text":"","title":"Engagement entity add to database"},{"location":"/engagement/index.html#user-story","text":"In PFIC system, PwC internal user could visit all their business information without restriction at beginning.\nBusiness information PFIC system has fund, company information. Fund will invest multiple companies. So the business information will includes information for funds and companies.\nBut client want to introduce engagement concept to restrict PwC internal user to handle engagement’s business information.\nEngagement PwC internal user could be in one or more engagements; One engagement will have multiple funds; One funds will invest multiple companies.","title":"User story"},{"location":"/engagement/index.html#question-about-privilege-in-different-engagement","text":"One user could be in one or more engagements, but does a same user in different engagements with different roles?","title":"Question about privilege in different engagement"},{"location":"/engagement/index.html#db-design","text":"Database as below:\nUser create table `users`(\n   `id` varchar(128) NOT NULL,\n   `email` VARCHAR(128) NOT NULL,\n   `role` VARCHAR(128) NOT NULL,\n   `engagementid` TEXT NULL,\n   PRIMARY KEY (`id`),\n   CONSTRAINT `email` UNIQUE (`email`)\n) Engagement create table `engagements`(\n   `id` varchar(128) NOT NULL,\n   `name` VARCHAR(128) NOT NULL,\n   `funds` TEXT NOT NULL,\n    PRIMARY KEY (id)\n) Fund-company CREATE TABLE fund_company_investments (\n    id varchar(128) NOT NULL, \n    fund_id varchar(255) NOT NULL,\n    company_id varchar(128) NOT NULL, \n    year INT NOT NULL,\n    PRIMARY KEY (id)\n); Fund create table `fund` (\n   `id` varchar(128) NOT NULL,\n   `name` VARCHAR(128) NOT NULL,\n    PRIMARY KEY (id)\n) Company create table `company` (\n   `id` varchar(128) NOT NULL,\n   `name` VARCHAR(128) NOT NULL,\n    PRIMARY KEY (id)\n)","title":"DB design"},{"location":"/engagement/index.html#question","text":"How could we check the user’s privilege on company and fund?\ncase class EngagementInfo(id: String, name: String, funds: Seq[String])\n\ncase class UserEngagementInfo(userRole: String, engagements: Seq[EngagementInfo],funds: Seq[String])\n\n\noverride def verifyForFund(email: String, fundId: String): Future[Boolean] = {\n  getUserEngagementInfoByEmail(email).map {\n    userEngagement =>\n      userEngagement.userRole match {\n        case \"Admin\" => true\n        case other if userEngagement.funds.contains(fundId) => true\n        case _ => false\n      }\n  }\n}\n\n\n\noverride def verifyForComapany(email: String, companyId: String, year: Int): Future[Boolean] = {\n  getUserEngagementInfoByEmail(email).flatMap {\n    userEngagement=>\n      userEngagement.userRole match{\n        case \"Admin\" => Future(true)\n        case other =>\n          val fdIds= fiCompanyInvestmentsDAO.queryByCompanyIdAndYear(companyId,year).map{\n            investSeq=>investSeq.map(_.fiId).toSet\n          }\n          val fdIdsInEng = getUserEngagementInfoByEmail(email).map{\n            engs=>engs.funds.toSet\n          }\n          val comsetF= for(s1 <- fdIds;\n                           s2 <- fdIdsInEng)\n            yield {\n              s1 &s2\n            }\n          comsetF.map{\n            comset=> !comset.isEmpty\n          }\n      }\n  }\n}","title":"Question"},{"location":"/engagement/index.html#question-two","text":"","title":"Question Two"},{"location":"/engagement/index.html#1-if-one-user-has-different-privilege-in-different-engagement-how-to-design-the-database-","text":"","title":"1. If one user has different privilege in different engagement, how to design the database?"},{"location":"/engagement/index.html#2-what-will-happen-when-user-binding-to-engagement-table-not-engagement-binging-to-user-table-","text":"","title":"2. What will happen when user binding to engagement table not engagement binging to user table?"},{"location":"/slickqueryfailed/index.html","text":"","title":"Slick query overflow"},{"location":"/slickqueryfailed/index.html#slick-query-overflow","text":"","title":"Slick query overflow"},{"location":"/slickqueryfailed/index.html#query-overflow","text":"User report a bug for table can’t be displayed:\nThere is something wrong with the get api\nConsole Console log [info] application - GET /api/engagements?page=1&pageSize=2147483647 took 117ms by admin@cn.pwc.com and returned 200\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n\n....\n\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[error] c.p.d.a.s.c.CustomErrorHandler - Error occurrred\njava.util.concurrent.RejectedExecutionException: Task slick.basic.BasicBackend$DatabaseDef$$anon$2@6e97c67a rejected from slick.util.AsyncExecutor$$anon$2$$anon$1@7efc5b8f[Running, pool size = 20, active threads = 3, queued tasks = 50, completed tasks = 338]\n        at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Unknown Source)\n        at java.util.concurrent.ThreadPoolExecutor.reject(Unknown Source)\n        at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)\n        at slick.util.AsyncExecutor$$anon$2$$anon$3.execute(AsyncExecutor.scala:161)\n        at slick.basic.BasicBackend$DatabaseDef.runSynchronousDatabaseAction(BasicBackend.scala:264)\n        at slick.basic.BasicBackend$DatabaseDef.runSynchronousDatabaseAction$(BasicBackend.scala:262)\n        at slick.jdbc.JdbcBackend$DatabaseDef.runSynchronousDatabaseAction(JdbcBackend.scala:37)\n        at slick.basic.BasicBackend$DatabaseDef.slick$basic$BasicBackend$DatabaseDef$$runInContextInline(BasicBackend.scala:241)\n        at slick.basic.BasicBackend$DatabaseDef.runInContextSafe(BasicBackend.scala:147)\n        at slick.basic.BasicBackend$DatabaseDef.runInContext(BasicBackend.scala:141)\nSo it’s seems the query triggered too many query to database, more than the database configuration.","title":"Query overflow"},{"location":"/slickqueryfailed/index.html#code-implement","text":"let see how is the query implemented?\ndef queryPageWithName(page: Int, pageSize: Int, useridOpt: Option[String], engagementidOpt: Option[String], roleOpt: Option[String]) =\n  deadbolt.Pattern()() {implicit authRequest =>\n    var filterMap = Map[String, String]()\n        ....\n    engageuserRead.listPage(page, pageSize, filterMap).flatMap(page => {\n      Future.sequence(page.items.map {\n        user1 =>\n          engagementRead.lookup(user1.engagementid).map {\n            engagementOpt =>\n              EngageuserWithName(user1, engagementOpt.get)\n          }\n      }).map {\n        engageWithName =>\n          Ok(Json.obj(\"engageuserWithName\" -> Json.toJson(engageWithName), \"total\" -> page.total))\n      }\n    })\n  }\nWith database configuration:\nmyapp = {\n  database = {\n      ...\n    numThreads = 20\n\n    queueSize = 50\n\n    maxConnections = 20\n        ...\n  }\n}\nSo we could easily know the inner query has triggered 50 query in queue of database setting, then the query failed\nLet’s see more clear about the get query:\nRequest Requet test Request URL: http://localhost:9000/api/engageuserswithname?page=1&pageSize=2147483647&roleOpt=File%20Owner\nRequest Method: GET\nStatus Code: 500 Internal Server Error\nRemote Address: [::1]:9000\nReferrer Policy: no-referrer-when-downgrade\nIn this get query, set the page size to 2147483647.","title":"Code implement"},{"location":"/slickqueryfailed/index.html#how-to-fix-","text":"","title":"How to fix?"},{"location":"/slickqueryfailed/index.html#fix-it-by-reduce-inner-query-","text":"Add new query override def listPageWithEngagement(pageNum: Int, pageSize: Int, filterMap: Map[String, String]): Future[Page[(Engageuser,Engagement)]] = {\n  val offset = pageSize * (pageNum - 1)\n  val engageUsersWithNotDeleted = for{\n    (engageusers, engagements) <- Engageusers join Engagements on ((left, right) => left.engagementid === right.id && right.deleted === \"false\" )\n  } yield (engageusers, engagements)\n\n  val defaultFilter = engageUsersWithNotDeleted.filter{ userEngagement =>\n    filterMap.get(\"engagementid\").map(someId=>userEngagement._1.engagementid.asColumnOf[String] === someId).getOrElse(true: Rep[Boolean])}\n    .filter{userEngagement =>\n      filterMap.get(\"userid\").map(someId=>userEngagement._1.userid.asColumnOf[String] like s\"%$someId%\").getOrElse(true: Rep[Boolean])}\n    .filter{userEngagement =>\n      filterMap.get(\"role\").map(role => userEngagement._1.role ===role).getOrElse(true: Rep[Boolean])\n    }\n    .filter(_._1.deleted === \"false\")\n\n  val query = defaultFilter.sortBy(_._1.createdatetime.desc).drop(offset).take(pageSize)\n  for {\n    totalRows <- db.run(defaultFilter.length.result)\n    result <- db.run(query.result).map(rows => rows.collect { case userEngagement => (engageuserRowToEngageuser(userEngagement._1), toEntity(userEngagement._2))})\n  } yield Page(result, pageNum, offset, totalRows)\n} Query Refined def queryPageWithName(page: Int, pageSize: Int, useridOpt: Option[String], engagementidOpt: Option[String], roleOpt: Option[String]) =\n  deadbolt.Pattern()() {implicit authRequest =>\n    var filterMap = Map[String, String]()\n      ...\n    engageuserRead.listPageWithEngagement(page,pageSize,filterMap).map{\n      page=>val engageWithName= page.items.map{\n        item=> EngageuserWithName(item._1,item._2)\n      }\n        Ok(Json.obj(\"engageuserWithName\" -> Json.toJson(engageWithName), \"total\" -> page.total))\n    }\n  } Console result [debug] s.j.J.statement - Preparing statement: select x2.`id`, x2.`userid`, x2.`username`, x2.`engagementid`, x2.`role`, x2.`active`, x2.`deleted`, x2.`createdatetime`, x2.`lastactivetime`, x2.`disabledtime`, x2.`meta`, x3.`id`, x3.`engagementcode`, x3.`name`, x3.`periodstart`, x3.`periodend`, x3.`auralink`, x3.`active`, x3.`deleted`, x3.`createdatetime`, x3.`meta` from `engageusers` x2, `engagements` x3 where ((x2.`role` = 'File Owner') and (x2.`deleted` = 'false')) and ((x2.`engagementid` = x3.`id`) and (x3.`deleted` = 'false')) order by x2.`createdatetime` desc limit 0,2147483647\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where `deleted` = 'false' order by `createdatetime` desc limit 0,2147483647\n[debug] s.j.J.statement - Preparing statement: select x2.`id`, x2.`userid`, x2.`username`, x2.`engagementid`, x2.`role`, x2.`active`, x2.`deleted`, x2.`createdatetime`, x2.`lastactivetime`, x2.`disabledtime`, x2.`meta`, x3.`id`, x3.`engagementcode`, x3.`name`, x3.`periodstart`, x3.`periodend`, x3.`auralink`, x3.`active`, x3.`deleted`, x3.`createdatetime`, x3.`meta` from `engageusers` x2, `engagements` x3 where ((x2.`role` = 'File Owner') and (x2.`deleted` = 'false')) and ((x2.`engagementid` = x3.`id`) and (x3.`deleted` = 'false')) order by x2.`createdatetime` desc limit 0,10\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where `deleted` = 'false' order by `createdatetime` desc limit 0,2147483647\n[info] application - GET /api/engageuserswithname?page=1&pageSize=10&roleOpt=File%20Owner took 81ms by admin@cn.pwc.com and returned 200\n[info] application - GET /api/engagements?page=1&pageSize=2147483647 took 85ms by admin@cn.pwc.com and returned 200\n[info] application - GET /api/engagements?page=1&pageSize=2147483647 took 98ms by admin@cn.pwc.com and returned 200\n[info] application - GET /api/engageuserswithname?page=1&pageSize=2147483647&roleOpt=File%20Owner took 103ms by admin@cn.pwc.com and returned 200","title":"Fix it by reduce inner query:"},{"location":"/slickqueryfailed/index.html#fix-by-reduce-the-inner-number-query-by-pagenumber","text":"The inner query is triggered by the outer pageNumber, in practical way of page query, there should not set the number to the number [pageSize=214748364]. And also increase the database queue size.","title":"Fix by reduce the inner number query by pageNumber"},{"location":"/shadowquery/index.html","text":"","title":"Shadow query"},{"location":"/shadowquery/index.html#shadow-query","text":"","title":"Shadow query"},{"location":"/shadowquery/index.html#shadow-query-issue","text":"For AWM project, when user change audit period, then updated file will be removed. The UI should be refeshed, and the “uplpaded audit files” should be “Not Started”.\nBut in our project when a fund has updated file as below:\nWhen we change audit period:\nBut the “uploaded audit files” status is not changed:\nWe could find in the network, all update are executed before the query, but the query return the wrong result.\nBut when we refresh the page, everything goes fine.","title":"Shadow query issue"},{"location":"/shadowquery/index.html#how-to-fix","text":"","title":"How to fix"},{"location":"/shadowquery/index.html#db-config-file","text":"Let see the db config file:\nmyapp = {\n  database = {\n    ...\n    // The number of threads determines how many things you can *run* in parallel\n    // the number of connections determines you many things you can *keep in memory* at the same time\n    // on the database server.\n    // numThreads = (core_count (hyperthreading included))\n    numThreads = 10\n\n    ...\n}\nWe could see the db connection numThreads is 10. When change the number to 1.\nSeems the issue is fixed.","title":"Db config file"},{"location":"/shadowquery/index.html#add-some-delay-to-the-query","text":"","title":"Add some delay to the query"},{"location":"/shadowquery/index.html#why-the-issue-happens-","text":"Let see what’s the update and query code does:\nUpdateCode private def cleanSelectionType(oldFund:Fund, newFund: Fund, fundenegagementId:String ):Future[Any]={\n   if(oldFund.fundAdmin != newFund.fundAdmin){\n     fundEngagementReportTypeSelectionDAO.deleteByEngagementId(fundenegagementId)\n   }\n   else if(!oldFund.auditPeriodBegin.equals(newFund.auditPeriodBegin) ||\n     !oldFund.auditPeriodEnd.equals(newFund.auditPeriodEnd) ||\n    !oldFund.baseCurrency.equals(newFund.baseCurrency)){\n     fundEngagementReportTypeSelectionWrite.clearUploadedReports(fundenegagementId)\n     egaWrite.cleanEGAByFundEngagementId(fundenegagementId)\n   }else {\n     Future(1)\n   }\n }\n\n override def update(fundEngagement: FundEngagementData): Future[Int] = {\n   val newFundOpt = fundEngagement.fundRecord.map{\n     record=>Json.parse(record).as[Fund]\n   }\n   val oldFunFutureOpt = fundEngagementDAO.lookup(fundEngagement.id).map{\n     fundEngagementOpt => fundEngagementOpt.flatMap{\n       fundengagementTemp=>fundengagementTemp.fundRecord.map{\n         record=>Json.parse(record).as[Fund]\n       }\n     }\n   }\n   val cleanUpTask= oldFunFutureOpt.flatMap{\n     oldFunOpt=> oldFunOpt.flatMap{\n       oldFun=> newFundOpt.map{\n         newFund => cleanSelectionType(oldFun, newFund,fundEngagement.id)\n       }\n     }match {\n       case Some(futureThing)=> futureThing\n       case _=>Future(1)\n     }\n   }\n   cleanUpTask.flatMap { result =>\n     val newFundTemp = newFundOpt.get\n     val newFundFuture =  fundAdminDAO.queryByFundAdmin(newFundTemp.fundAdmin).map{\n       tmpOpt =>tmpOpt match{\n         case Some(fundAdmin)=>newFundTemp.copy(fundAdminId = Some(fundAdmin.id))\n         case _=>newFundTemp\n       }\n     }\n     val newFund = Await.result(newFundFuture, 1 second)\n     val newFundEngagement = fundEngagement.copy(fundRecord = Some(Json.toJson(newFund).toString()))\n     fundEngagementDAO.update(newFundEngagement)\n   }\n } QueryStatus override def queryFundReportStatus(engagementId: String): Future[Seq[FundEngagementWithStatus]] = {\n  val sql = for ((((fundEnagements, funds), selections), ega)\n                   <- FundEngagement join Funds on ((left, right) => left.fundid === right.id && left.engagementid === engagementId)\n                                     joinLeft  FundEngagementReportTypeSelection on ((left, right) => left._1.id === right.fundEngagementId && right.selected === true)\n                                     joinLeft Ega on ((left, right) => left._1._1.id === right.fundEngagementId))\n    yield {\n      var isReportTypeDefined: Rep[Boolean]  = selections.isDefined\n      var hasReportUploadedContent = selections.map(_.uploadFileStatus === UploadFileStatus.success.toString)\n      var hasEgaDownloaded: Rep[Boolean] = ega.map(_.generateStatus === GenerateStatus.success.toString).getOrElse(false)\n      (fundEnagements.id, fundEnagements.engagementid, fundEnagements.fundid, funds.name, isReportTypeDefined, hasReportUploadedContent, hasEgaDownloaded)\n    }\n\n  for {\n    result <- db.run(sql.result).map(rows => rows.collect { case dataRow => (FundEngagementWithStatusBoolean.apply _).tupled(dataRow) })\n  } yield {\n    var sqlResult = result.map(item => {\n      var definedReportTypeNumber = if(item.isReportTypeDefined) 1 else 0\n      var reportUploadedNumber = if(item.hasReportUploadedPath == Some(true)) 1 else 0\n      FundEngagementWithStatus(item.fundEngagementId,item.engagementId, item.fundId, item.fundName, definedReportTypeNumber, reportUploadedNumber, item.hasEgaDownloaded)\n    })\n\n    var combineStatus = Seq[FundEngagementWithStatus]()\n    for(status <- sqlResult){\n      if(combineStatus.find(_.fundEngagementId == status.fundEngagementId).isEmpty){ // has put into combineStatus sequence\n\n        var statusWithSameFundEngagementId: Seq[FundEngagementWithStatus] = sqlResult.filter(_.fundEngagementId == status.fundEngagementId)\n\n        var definedReportNumbers:Int = 0\n        var uploadedReportNumbers:Int = 0\n        var hasEgaDownloaded:Boolean = true\n        for(fundStatus <- statusWithSameFundEngagementId){\n          definedReportNumbers = definedReportNumbers + fundStatus.definedReportTypeNumber\n          uploadedReportNumbers = uploadedReportNumbers + fundStatus.reportUploadedNumber\n          hasEgaDownloaded = hasEgaDownloaded && fundStatus.hasEgaDownloaded\n        }\n        combineStatus = combineStatus :+ FundEngagementWithStatus(status.fundEngagementId, status.engagementId, status.fundId, status.fundName, definedReportNumbers, uploadedReportNumbers, hasEgaDownloaded)\n      }\n    }\n    combineStatus\n  }\n}","title":"Why the issue happens:"},{"location":"/inconsistent/index.html","text":"","title":"Inconsistent status"},{"location":"/inconsistent/index.html#inconsistent-status","text":"Statistics query goes different for “downloaders” in User Information section and “Single EGA Download” in Fund Information section\nBut the two information comes from same api:\nclass StatisticsReadImpl @Inject()(...\n                                   slickUserlogDAO: SlickUserlogDAO)(implicit ec: ExecutionContext) extends StatisticsRead {\n  override def getAWMStatistics(): Future[AWMStatistics] = {\n      ....\n    val from = Await.result(fromFuture,Duration(1,TimeUnit.SECONDS))\n\n    val to = new Timestamp(DateTime.now.getMillis)\n    for(userNum <- statisticsDAO.getUserCount();\n      ...\n        userEgaNumDaily <-slickStatisticsDailyDAO.getEgaCountDaily(from);\n        egaNumDaily <-slickStatisticsDailyDAO.getEgaCountDaily(from);\n      ...\n    )yield AWMStatistics(Seq(\n        ....\n      StatisticRecord(\"Number of users with Single EGA downloaded daily\",userEgaNumDaily.toString),\n      StatisticRecord(\"Number of Single EGAs created daily\",egaNumDaily.toString),\n      ...\n    )\n    )\n  }\n}\nAnd we could see from UI, the query goes like:\nfetchData = () => {\n    this.props.getPureAdminUsers().then((res) => {\n     ....\n            for(var i = 0; i < data.length; i++){\n\n              downloaders += parseInt(JSON.parse(data[i].content).statisticsSeq[2].number)     [1]\n            }\n\n\n        ...\n\n\n\n  fetchData = () => {\n    if(this.state.selectDateType[0] > 0) {\n        ...\n          for(var i = 0; i < data.length; i++){\n            uploadedReports += parseInt(JSON.parse(data[i].content).statisticsSeq[4].number)    [2]\n        ...\n          }\nbut check the response body of the api:\n[{\"id\":\"9b58f780-fbd2-4557-9522-5cdcfa62cf6b\",\"createDateTime\":1585621636000,\"content\":\"{\\\"statisticsSeq\\\":\n[{\\\"name\\\":\\\"Number of users logged daily\\\",\\\"number\\\":\\\"1\\\"},\n{\\\"name\\\":\\\"Number of users that uploaded daily\\\",\\\"number\\\":\\\"1\\\"},\n{\\\"name\\\":\\\"Number of users with Single EGA downloaded daily\\\",\\\"number\\\":\\\"2\\\"},\n{\\\"name\\\":\\\"Number of Single EGAs created daily\\\",\\\"number\\\":\\\"2\\\"},\n{\\\"name\\\":\\\"Number of reports uploaded daily\\\",\\\"number\\\":\\\"15\\\"},\n{\\\"name\\\":\\\"Number of engagements created daily\\\",\\\"number\\\":\\\"0\\\"},\n{\\\"name\\\":\\\"Number of fund profiles created daily\\\",\\\"number\\\":\\\"0\\\"},\n\\\"name\\\":\\\"Number of fund processed daily\\\",\\\"number\\\":\\\"1\\\"},\n{\\\"name\\\":\\\"Number of users logged\\\",\\\"number\\\":\\\"20\\\"},\n{\\\"name\\\":\\\"Number of users that uploaded\\\",\\\"number\\\":\\\"1\\\"},\n{\\\"name\\\":\\\"Number of users with Single EGA downloaded\\\",\\\"number\\\":\\\"2\\\"},\n{\\\"name\\\":\\\"Number of Single EGAs created\\\",\\\"number\\\":\\\"11\\\"},\n{\\\"name\\\":\\\"Number of reports uploaded\\\",\\\"number\\\":\\\"80\\\"},\n{\\\"name\\\":\\\"Number of engagements created\\\",\\\"number\\\":\\\"4\\\"},\n{\\\"name\\\":\\\"Number of fund profiles created\\\",\\\"number\\\":\\\"15\\\"},\n{\\\"name\\\":\\\"Number of fund processed\\\",\\\"number\\\":\\\"11\\\"},\n{\\\"name\\\":\\\"Average number of funds per engagement\\\",\\\"number\\\":\\\"3.75\\\"},\n{\\\"name\\\":\\\"Average number of users per engagement\\\",\\\"number\\\":\\\"5.00\\\"}]}\"},\n\n....\n\n{\"id\":\"493788c6-58f5-40b5-a411-6e532d58da07\",\"createDateTime\":1577675915000,\"content\":\"{\\\"statisticsSeq\\\":\n[{\\\"name\\\":\\\"Number of users logged\\\",\\\"number\\\":\\\"17\\\"},\n{\\\"name\\\":\\\"Number of users that uploaded\\\",\\\"number\\\":\\\"7\\\"},\n{\\\"name\\\":\\\"Number of users with Single EGA downloaded\\\",\\\"number\\\":\\\"2\\\"},\n{\\\"name\\\":\\\"Number of Single EGAs created\\\",\\\"number\\\":\\\"21\\\"},\n{\\\"name\\\":\\\"Number of reports uploaded\\\",\\\"number\\\":\\\"223\\\"},\n{\\\"name\\\":\\\"Number of engagements created\\\",\\\"number\\\":\\\"4\\\"},\n{\\\"name\\\":\\\"Number of fund profiles created\\\",\\\"number\\\":\\\"10\\\"},\n{\\\"name\\\":\\\"Number of fund processed\\\",\\\"number\\\":\\\"12\\\"},\n{\\\"name\\\":\\\"Average number of funds per engagement\\\",\\\"number\\\":\\\"2.50\\\"},\n{\\\"name\\\":\\\"Average number of users per engagement\\\",\\\"number\\\":\\\"4.25\\\"}]}\"}]","title":"Inconsistent status"},{"location":"/dailyjob/index.html","text":"","title":"Daily schedule job"},{"location":"/dailyjob/index.html#daily-schedule-job","text":"","title":"Daily schedule job"},{"location":"/dailyjob/index.html#issue-","text":"In a project, there is a daily schedule job to do some work, but when we query the database, the record of daily job is not as expected:\n+--------------------------------------+---------------------+\n| id                                   | createdatetime      |\n| 493788c6-58f5-40b5-a411-6e532d58da07 | 2019-12-30 03:18:35 |\n| 4b143a14-256e-4a95-8757-15d3867a67db | 2020-01-17 08:32:03 |\n| 625b0523-cc02-4e26-ad85-17dfda3f7707 | 2020-03-06 06:43:57 |\n| 6b0094db-c5e1-449d-a387-cbf29c2e318f | 2020-03-23 02:46:16 |\n| 76fc0973-254a-4b6f-9853-950b84cbb859 | 2020-03-29 12:00:42 |\n| 878a8476-32bf-4139-bf4e-afe093c5187b | 2020-02-11 08:11:05 |\n| 9b58f780-fbd2-4557-9522-5cdcfa62cf6b | 2020-03-31 02:27:16 |\n| a9a9658b-2daa-4676-a296-1af5ff97cd54 | 2020-04-01 02:28:02 |\n| c294bf2c-fbf4-4f74-b786-e39c44c162f8 | 2020-03-27 05:23:57 |\n| c6072bc1-85eb-491b-9aaf-50a5e42b9d17 | 2020-03-20 07:16:26 |\n| d8f90fd2-8754-438f-97ee-47242a50a93f | 2020-01-08 07:17:44 |\n| e7d51849-f599-4062-bba9-97960c15d4d1 | 2020-03-04 06:44:10 |\n| e8123059-7daa-46c0-b902-7f4540a4179e | 2020-02-28 09:16:14 |\n| f6e98a8a-a10c-44d7-b4a0-599ce8025224 | 2020-02-19 02:33:32 |\n\n\n\n+--------------------------------------+---------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| id                                   | createdatetime      | content                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n+--------------------------------------+---------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| 1921eea1-721f-44fc-9635-87bfc463c4f0 | 2020-03-28 12:00:41 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"2\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"1\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"3\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"3\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"40\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"2\"},{\"name\":\"Number of fund processed daily\",\"number\":\"3\"},{\"name\":\"Number of users logged\",\"number\":\"20\"},{\"name\":\"Number of users that uploaded\",\"number\":\"1\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"2\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"9\"},{\"name\":\"Number of reports uploaded\",\"number\":\"65\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"15\"},{\"name\":\"Number of fund processed\",\"number\":\"12\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"3.75\"},{\"name\":\"Average number of users per engagement\",\"number\":\"5.00\"}]} |\n| 493788c6-58f5-40b5-a411-6e532d58da07 | 2019-12-30 03:18:35 | {\"statisticsSeq\":[{\"name\":\"Number of users logged\",\"number\":\"17\"},{\"name\":\"Number of users that uploaded\",\"number\":\"7\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"2\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"21\"},{\"name\":\"Number of reports uploaded\",\"number\":\"223\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"10\"},{\"name\":\"Number of fund processed\",\"number\":\"12\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"2.50\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.25\"}]}                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| 4b143a14-256e-4a95-8757-15d3867a67db | 2020-01-17 08:32:03 | {\"statisticsSeq\":[{\"name\":\"Number of users logged\",\"number\":\"18\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"44\"},{\"name\":\"Number of reports uploaded\",\"number\":\"331\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"27\"},{\"name\":\"Number of fund processed\",\"number\":\"28\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"6.75\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.50\"}]}                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| 625b0523-cc02-4e26-ad85-17dfda3f7707 | 2020-03-06 06:43:57 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"2\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"0\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"0\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"0\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"0\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"0\"},{\"name\":\"Number of fund processed daily\",\"number\":\"0\"},{\"name\":\"Number of users logged\",\"number\":\"16\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"55\"},{\"name\":\"Number of reports uploaded\",\"number\":\"407\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"17\"},{\"name\":\"Number of fund processed\",\"number\":\"14\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"4.25\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.00\"}]} |\n| 6b0094db-c5e1-449d-a387-cbf29c2e318f | 2020-03-23 02:46:16 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"2\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"0\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"0\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"0\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"0\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"0\"},{\"name\":\"Number of fund processed daily\",\"number\":\"0\"},{\"name\":\"Number of users logged\",\"number\":\"19\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"59\"},{\"name\":\"Number of reports uploaded\",\"number\":\"432\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"18\"},{\"name\":\"Number of fund processed\",\"number\":\"17\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"4.50\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.75\"}]} |\n| 76fc0973-254a-4b6f-9853-950b84cbb859 | 2020-03-29 12:00:42 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"0\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"0\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"0\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"0\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"0\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"0\"},{\"name\":\"Number of fund processed daily\",\"number\":\"0\"},{\"name\":\"Number of users logged\",\"number\":\"20\"},{\"name\":\"Number of users that uploaded\",\"number\":\"1\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"2\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"9\"},{\"name\":\"Number of reports uploaded\",\"number\":\"65\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"15\"},{\"name\":\"Number of fund processed\",\"number\":\"11\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"3.75\"},{\"name\":\"Average number of users per engagement\",\"number\":\"5.00\"}]} |\n| 878a8476-32bf-4139-bf4e-afe093c5187b | 2020-02-11 08:11:05 | {\"statisticsSeq\":[{\"name\":\"Number of users logged\",\"number\":\"19\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"47\"},{\"name\":\"Number of reports uploaded\",\"number\":\"358\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"27\"},{\"name\":\"Number of fund processed\",\"number\":\"28\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"6.75\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.75\"}]}                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| 9b58f780-fbd2-4557-9522-5cdcfa62cf6b | 2020-03-31 02:27:16 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"1\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"1\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"2\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"2\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"15\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"0\"},{\"name\":\"Number of fund processed daily\",\"number\":\"1\"},{\"name\":\"Number of users logged\",\"number\":\"20\"},{\"name\":\"Number of users that uploaded\",\"number\":\"1\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"2\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"11\"},{\"name\":\"Number of reports uploaded\",\"number\":\"80\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"15\"},{\"name\":\"Number of fund processed\",\"number\":\"11\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"3.75\"},{\"name\":\"Average number of users per engagement\",\"number\":\"5.00\"}]} |\n| a9a9658b-2daa-4676-a296-1af5ff97cd54 | 2020-04-01 02:28:02 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"3\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"1\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"1\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"1\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"2\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"0\"},{\"name\":\"Number of fund processed daily\",\"number\":\"1\"},{\"name\":\"Number of users logged\",\"number\":\"21\"},{\"name\":\"Number of users that uploaded\",\"number\":\"1\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"2\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"12\"},{\"name\":\"Number of reports uploaded\",\"number\":\"82\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"15\"},{\"name\":\"Number of fund processed\",\"number\":\"12\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"3.75\"},{\"name\":\"Average number of users per engagement\",\"number\":\"5.25\"}]} |\n| c294bf2c-fbf4-4f74-b786-e39c44c162f8 | 2020-03-27 05:23:57 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"2\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"0\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"0\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"0\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"0\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"0\"},{\"name\":\"Number of fund processed daily\",\"number\":\"0\"},{\"name\":\"Number of users logged\",\"number\":\"19\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"59\"},{\"name\":\"Number of reports uploaded\",\"number\":\"432\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"13\"},{\"name\":\"Number of fund processed\",\"number\":\"12\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"3.25\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.75\"}]} |\n| c6072bc1-85eb-491b-9aaf-50a5e42b9d17 | 2020-03-20 07:16:26 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"3\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"1\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"4\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"8\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"5\"},{\"name\":\"Number of fund processed daily\",\"number\":\"5\"},{\"name\":\"Number of users logged\",\"number\":\"19\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"59\"},{\"name\":\"Number of reports uploaded\",\"number\":\"430\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"21\"},{\"name\":\"Number of fund processed\",\"number\":\"19\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"5.25\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.75\"}]} |\n| d8f90fd2-8754-438f-97ee-47242a50a93f | 2020-01-08 07:17:44 | {\"statisticsSeq\":[{\"name\":\"Number of users logged\",\"number\":\"17\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"39\"},{\"name\":\"Number of reports uploaded\",\"number\":\"280\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"29\"},{\"name\":\"Number of fund processed\",\"number\":\"31\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"7.25\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.25\"}]}                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| e7d51849-f599-4062-bba9-97960c15d4d1 | 2020-03-04 06:44:10 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"2\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"1\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"0\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"0\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"0\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"1\"},{\"name\":\"Number of fund processed daily\",\"number\":\"1\"},{\"name\":\"Number of users logged\",\"number\":\"16\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"55\"},{\"name\":\"Number of reports uploaded\",\"number\":\"407\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"17\"},{\"name\":\"Number of fund processed\",\"number\":\"14\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"4.25\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.00\"}]} |\n| e8123059-7daa-46c0-b902-7f4540a4179e | 2020-02-28 09:16:14 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"2\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"2\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"6\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"6\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"33\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"6\"},{\"name\":\"Number of fund processed daily\",\"number\":\"8\"},{\"name\":\"Number of users logged\",\"number\":\"16\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"55\"},{\"name\":\"Number of reports uploaded\",\"number\":\"407\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"15\"},{\"name\":\"Number of fund processed\",\"number\":\"13\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"3.75\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.00\"}]} |\n| f6e98a8a-a10c-44d7-b4a0-599ce8025224 | 2020-02-19 02:33:32 | {\"statisticsSeq\":[{\"name\":\"Number of users logged daily\",\"number\":\"0\"},{\"name\":\"Number of users that uploaded daily\",\"number\":\"2\"},{\"name\":\"Number of users with Single EGA downloaded daily\",\"number\":\"2\"},{\"name\":\"Number of Single EGAs created daily\",\"number\":\"2\"},{\"name\":\"Number of reports uploaded daily\",\"number\":\"16\"},{\"name\":\"Number of engagements created daily\",\"number\":\"0\"},{\"name\":\"Number of fund profiles created daily\",\"number\":\"3\"},{\"name\":\"Number of fund processed daily\",\"number\":\"4\"},{\"name\":\"Number of users logged\",\"number\":\"19\"},{\"name\":\"Number of users that uploaded\",\"number\":\"8\"},{\"name\":\"Number of users with Single EGA downloaded\",\"number\":\"4\"},{\"name\":\"Number of Single EGAs created\",\"number\":\"49\"},{\"name\":\"Number of reports uploaded\",\"number\":\"374\"},{\"name\":\"Number of engagements created\",\"number\":\"4\"},{\"name\":\"Number of fund profiles created\",\"number\":\"12\"},{\"name\":\"Number of fund processed\",\"number\":\"12\"},{\"name\":\"Average number of funds per engagement\",\"number\":\"3.00\"},{\"name\":\"Average number of users per engagement\",\"number\":\"4.75\"}]} |\n+--------------------------------------+---------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\nWhat’s the daily job do:\nclass ScheduledTasks @Inject()(...\n                               statisticslogWrite: StatisticslogWrite)(implicit executionContext: ExecutionContext) {\n\n\n  if(isScheduledHost){\n    actorSystem.scheduler.schedule(initialDelay = 10.seconds + Random.nextInt(100).seconds, interval = 1.day + Random.nextInt(100).seconds) {\n      // the block of code that will be executed\n      Await.result( statisticslogWrite.takeSnap(), 10 seconds)\n      Await.result(fundsWrite.cleanExpiredFund(), 10 seconds)\n      Await.result(fundEngagementWrite.cleanExpiredFundEngagement(), 10 seconds)\n      Await.result(fundEngagementReportTypeSelectionWrite.cleanExpiredTypeSelection(), 10 seconds)\n      egaWrite.cleanExpiredEga()\n    }\n  }\n}\nHow to fix:\nclass ScheduledTasks @Inject()(...\n                               statisticslogWrite: StatisticslogWrite)(implicit executionContext: ExecutionContext) {\n\n  if(isScheduledHost){\n    actorSystem.scheduler.schedule(initialDelay = 10.seconds + Random.nextInt(100).seconds, interval = 1.day + Random.nextInt(100).seconds) {\n      for{\n        _ <- statisticslogWrite.takeSnap();\n        _ <-fundsWrite.cleanExpiredFund();\n        _ <-fundEngagementWrite.cleanExpiredFundEngagement();\n        _<-fundEngagementReportTypeSelectionWrite.cleanExpiredTypeSelection();\n        _<-egaWrite.cleanExpiredEga()\n\n      }yield ( Logger.apply(this.getClass.toString).info(\"Daily operation success\") )\n    }\n  }\n}","title":"Issue:"},{"location":"/pac4j/index.html","text":"","title":"Oauth2 client for Pac4j"},{"location":"/pac4j/index.html#oauth2-client-for-pac4j","text":"","title":"Oauth2 client for Pac4j"},{"location":"/pac4j/index.html#whats-pac4j-do-","text":"Pac4j will maintain a “profile” for authenticated user:","title":"What’s pac4j do?"},{"location":"/pac4j/index.html#1-user-will-specify-the-client-used-for-application-","text":"def secureAction[A](action: Action[A]): Action[A] = Secure(\"PwCClient\").async(action.parser) { implicit request =>\n...\n}","title":"1. User will specify the client used for application:"},{"location":"/pac4j/index.html#2-pac4j-will-first-query-profile","text":"and there is no profile exist yet:","title":"2. Pac4j will first query profile"},{"location":"/pac4j/index.html#3-client-will-start-oauth2-authentication-","text":"","title":"3. Client will start Oauth2 authentication:"},{"location":"/pac4j/index.html#get-authorize","text":"User will redirect to authorization portal\nAfter user authorized, then the authorization portal will post back with token for user:","title":"Get authorize"},{"location":"/pac4j/index.html#get-access-token","text":"Then use the authorized token to change the access token:","title":"Get access token"},{"location":"/pac4j/index.html#get-user-information","text":"User the access token to get user information","title":"Get user information"},{"location":"/pac4j/index.html#4-then-the-pac4j-will-use-the-user-information-to-create-a-profile-for-user-","text":"","title":"4. Then the pac4j will use the user information to create a profile for user:"},{"location":"/pac4j/index.html#5-when-profile-is-stored-in-session-user-profile-could-be-get-when-user-visit-restricted-resources-","text":"and redirect to the resources:","title":"5. When profile is stored in session, user profile could be get when user visit restricted resources:"},{"location":"/nio/index.html","text":"","title":"NIO and Akka-Http"},{"location":"/nio/index.html#nio-and-akka-http","text":"","title":"NIO and Akka-Http"},{"location":"/nio/index.html#whats-java-nio-","text":"See the : Java NIO浅析","title":"What’s Java NIO?"},{"location":"/nio/index.html#whats-relationship-about-java-nio-and-akka-http-","text":"Akka IO is based on Java NIO library:\npackage akka.io\n\nimport java.util.{ Iterator ⇒ JIterator }\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.nio.channels.{ SelectableChannel, SelectionKey, CancelledKeyException }\nimport java.nio.channels.SelectionKey._\nBut is Akka-Http is same as Jetty or Netty?\nNo, you could find the answer from Understanding Reactive IO and Back-Pressure with (your own) Akka Http Server","title":"What’s relationship about Java NIO and Akka-Http:"},{"location":"/nio/index.html#why-akka-http-is-introduced-","text":"Well, the main answer is in the same Understanding Reactive IO and Back-Pressure with (your own) Akka Http Server.","title":"Why Akka-http is introduced?"},{"location":"/nio/index.html#go-through-the-article","text":"We will quickly go throught this article:\nThe classical Java BIO can’t fit the requirement\nMost web servers used to use thread per connection model to handle http requests. In this model, the\nservers also used to use blocking IO libraries to read requests from connections and write responses.This works well when connections are short lived. Traditionally, most http requests used to be short\nlived. A client opened a connection, sent request, read the response and closed the connection. This\nallowed servers to have a fixed thread pool to serve the requests and use blocking IO to read and\nwrite to connections. Using blocking IO, also allowed having synchronous APIs, which is a simple\nprogramming model to work with.\n\nThis model created a big problem with changing patterns of web requests though.\n\nTo support Keep-Alive connections, http pipelining, servers could no longer rely on blocking IO and\n threads only. Apache, as of version 2.4 uses evented IO to handle connections\n\n(https://httpd.apache.org/docs/2.4/mod/event.html)\nYou may want to see the Appache MPM Event\nThen there will intruce some Java NIO design pattern throw :Scalable IO in Java { open=new }. The short version from: Scalable IO in Java Because the actor is lightweight, so we could use create an Actor per connection. Actor could also resolve the state management difficult comparing use Java framework. (This solution is just use Actor to hold working thread.) For the back pressure issue, then introduce with Streaming method, which is the Akka-Http.","title":"Go through the article"},{"location":"/nio/code/appacheMPMEvent.html","text":"","title":"Apache MPM event"},{"location":"/nio/code/appacheMPMEvent.html#apache-mpm-event","text":"The original artical from Apache MPM event","title":"Apache MPM event"},{"location":"/nio/code/appacheMPMEvent.html#summary","text":"The event Multi-Processing Module (MPM) is designed to allow more requests to be served simultaneously by passing off some processing work to the listeners threads, freeing up the worker threads to serve new requests.\nTo use the event MPM, add –with-mpm=event to the configure script’s arguments when building the httpd.","title":"Summary"},{"location":"/nio/code/appacheMPMEvent.html#relationship-with-the-worker-mpm","text":"event is based on the worker MPM, which implements a hybrid multi-process multi-threaded server. A single control process (the parent) is responsible for launching child processes. Each child process creates a fixed number of server threads as specified in the ThreadsPerChild directive, as well as a listener thread which listens for connections and passes them to a worker thread for processing when they arrive.\nRun-time configuration directives are identical to those provided by worker, with the only addition of the AsyncRequestWorkerFactor.","title":"Relationship with the Worker MPM"},{"location":"/nio/code/appacheMPMEvent.html#how-it-works","text":"This MPM tries to fix the ‘keep alive problem’ in HTTP. After a client completes the first request, it can keep the connection open, sending further requests using the same socket and saving significant overhead in creating TCP connections. However, Apache HTTP Server traditionally keeps an entire child process/thread waiting for data from the client, which brings its own disadvantages. To solve this problem, this MPM uses a dedicated listener thread for each process to handle both the Listening sockets, all sockets that are in a Keep Alive state, sockets where the handler and protocol filters have done their work and the ones where the only remaining thing to do is send the data to the client.\nThis new architecture, leveraging non-blocking sockets and modern kernel features exposed by APR (like Linux’s epoll), no longer requires the mpm-accept Mutex configured to avoid the thundering herd problem.\nThe total amount of connections that a single process/threads block can handle is regulated by the AsyncRequestWorkerFactor directive.","title":"How it Works"},{"location":"/nio/code/appacheMPMEvent.html#async-connections","text":"Async connections would need a fixed dedicated worker thread with the previous MPMs but not with event. The status page of mod_status shows new columns under the Async connections section:","title":"Async connections"},{"location":"/nio/code/appacheMPMEvent.html#writing","text":"While sending the response to the client, it might happen that the TCP write buffer fills up because the connection is too slow. Usually in this case, a write() to the socket returns EWOULDBLOCK or EAGAIN to become writable again after an idle time. The worker holding the socket might be able to offload the waiting task to the listener thread, that in turn will re-assign it to the first idle worker thread available once an event will be raised for the socket (for example, “the socket is now writable”). Please check the Limitations section for more information.","title":"Writing"},{"location":"/nio/code/appacheMPMEvent.html#keep-alive","text":"Keep Alive handling is the most basic improvement from the worker MPM. Once a worker thread finishes to flush the response to the client, it can offload the socket handling to the listener thread, that in turn will wait for any event from the OS, like “the socket is readable”. If any new request comes from the client, then the listener will forward it to the first worker thread available. Conversely, if the KeepAliveTimeout occurs then the socket will be closed by the listener. In this way, the worker threads are not responsible for idle sockets, and they can be re-used to serve other requests.","title":"Keep-alive"},{"location":"/nio/code/appacheMPMEvent.html#closing","text":"Sometimes the MPM needs to perform a lingering close, namely sending back an early error to the client while it is still transmitting data to httpd. Sending the response and then closing the connection immediately is not the correct thing to do since the client (still trying to send the rest of the request) would get a connection reset and could not read the httpd’s response. The lingering close is time-bounded, but it can take a relatively long time, so it’s offloaded to a worker thread (including the shutdown hooks and real socket close). From 2.4.28 onward, this is also the case when connections finally timeout (the listener thread never handles connections besides waiting for and dispatching their events). These improvements are valid for both HTTP/HTTPS connections.","title":"Closing"},{"location":"/nio/code/scalableIOInJava.html","text":"","title":"Scalable IO in Java"},{"location":"/nio/code/scalableIOInJava.html#scalable-io-in-java","text":"The original reference is from Scalable IO in Java { open=new }","title":"Scalable IO in Java"},{"location":"/nio/code/scalableIOInJava.html#classic-way-of-handle-one-requst-pre-thread","text":"Add design multiple implementations of Event Driven design","title":"Classic way of handle one requst pre thread"},{"location":"/nio/code/scalableIOInJava.html#single-threaded-version-","text":"","title":"Single threaded version [Nodejs]"},{"location":"/nio/code/scalableIOInJava.html#thread-pool-version","text":"","title":"Thread Pool version"},{"location":"/nio/code/scalableIOInJava.html#multiple-reactor","text":"","title":"Multiple reactor"},{"location":"/databasewithfile/index.html","text":"","title":"Store file in database"},{"location":"/databasewithfile/index.html#store-file-in-database","text":"","title":"Store file in database"},{"location":"/databasewithfile/index.html#store-file-in-database-","text":"It’s quiet common that applicaiton will use database blob to store long contents input or files.\nFor our AWM project do the same way, but when we query the file extaction status in home page:\nWe just want a simple answer that if the user upload files are processed:\nwith query result from backend:\n[\n    {\n        \"fundEngagementId\": \"3ed111d1-5f9a-4afd-bc6a-99286e2de59a\",\n        \"engagementId\": \"asfsaf2\",\n        \"fundId\": \"70e59b84-9721-4e22-8f9e-01e04b0a768a\",\n        \"fundName\": \"FI\",\n        \"definedReportTypeNumber\": 15,\n        \"reportUploadedNumber\": 15,\n        \"hasEgaDownloaded\": true\n    }\n]\nso everything looks as expected.","title":"Store file in database:"},{"location":"/databasewithfile/index.html#issue-","text":"But as we look the database query log in backend, we will find:\n[debug] s.j.J.statement - Preparing statement: select x2.`id`, x2.`fund_engagement_id`, x2.`extraction_status`,\n x2.`upload_file_status`, x2.`upload_file_content`, x2.`selected`, x3.`display`, x4.`display`, x2.`createby`,\n  x2.`createdatetime`, x2.`modifyby`, x2.`modifydatetime` from `fund_engagement_report_type_selection` x2,\n  `fund_engagement` x5, `funds` x6, `fund_admin` x7, `sheettypes_reporttypes_map` x8, `sheet_types` x3, `report_types`\n  x4 where ((((((x2.`fund_engagement_id` = x5.`id`) and (x2.`fund_engagement_id` = '3ed111d1-5f9a-4afd-bc6a-99286e2de59a'))\n  and (x5.`fundid` = x6.`id`)) and (x6.`fund_admin_id` = x7.`id`)) and (x2.`sheettypes_reporttypes_map_id` = x8.`id`))\n  and (x8.`sheettypeid` = x3.`id`)) and (x8.`reporttypeid` = x4.`id`)\nThe log shows there will have query for “upload_file_content”. This field is a blob file:\ncreate table `fund_engagement_report_type_selection`(\n\t`id` varchar(128) NOT NULL,\n    `sheettypes_reporttypes_map_id` varchar(128) NOT NULL,\n...\n    `modifyby` VARCHAR(128) NULL,\n    `modifydatetime`  TIMESTAMP  NULL,\n    `selected` boolean NOT NULL DEFAULT FALSE,\n    `upload_file_content` MEDIUMBLOB NULL,\n    `extraction_file_content` MEDIUMBLOB NULL,\n...\n);\nIn this table, we store the file content in field “upload_file_content”.","title":"Issue:"},{"location":"/databasewithfile/index.html#whats-happend-","text":"There is an existed api to query user’s input:\noverride def lookupSelectionWithDisplay(fundEngagementId: String): Future[Seq[FundEngagementReportTypeSelectionWithName]] = {\n  val sql = for (((((((selection, fundEngagement), funds), fundAdmin), sheetReportMap), sheetTypes), reportTypes)\n                   <- FundEngagementReportTypeSelection join FundEngagement on ((left, right) => left.fundEngagementId === right.id && left.fundEngagementId === fundEngagementId)\n    join Funds on ((left, right) => left._2.fundid === right.id)\n    join FundAdmin on ((left, right) => left._2.fundAdminId === right.id)\n    join SheettypesReporttypesMap on (_._1._1._1.sheettypesReporttypesMapId === _.id)\n    join SheetTypes on ((left, right) => left._2.sheettypeid === right.id)\n    join ReportTypes on ((left, right) => left._1._2.reporttypeid === right.id))\n    yield (selection.id, selection.fundEngagementId, selection.extractionStatus, selection.uploadFileStatus ,selection.uploadFileContent, selection.selected, sheetTypes.display, reportTypes.display,\n      selection.createby, selection.createdatetime, selection.modifyby, selection.modifydatetime)\n  db.run(sql.result).map(res => res.map(tup => FundEngagementReportTypeSelectionWithName(tup._1, tup._2, tup._3, tup._4, tup._5 match {\n    case Some(value) => Some(new String(value.toString))\n    case None => None\n  }, tup._6, tup._7,tup._8, tup._9, tup._10, tup._11, tup._12)))\n}\nThe api is as expected.\nBut when another person implements another api to query the extraction result of user input files, the person “reuse” the api. Then the issue happens.","title":"What’s happend:"},{"location":"/databasewithfile/index.html#how-to-resolve-","text":"Change the query. Change the database definition.","title":"How to resolve:"},{"location":"/flywayonmysql/index.html","text":"","title":"Flyway clean failed on mysql8"},{"location":"/flywayonmysql/index.html#flyway-clean-failed-on-mysql8","text":"","title":"Flyway clean failed on mysql8"},{"location":"/flywayonmysql/index.html#issue","text":"The command as belpw is used for clean database schema:\nval cmds = Seq(\n  \"sbt flyway/flywayClean\",\n  \"sbt flyway/flywayBaseline\",\n  \"sbt flyway/flywayMigrate\"\n)\nbut this command will failed on mysql 8.0 for “sbt flyway/flywayClean” as below:\nWhen the database is drop by user and use the same sequence commands, the commands will success (there is no cleanup operation because the database is not existed yet). But the commands sequence will still failed on next round on cleanup operation.\nWhile this issue will not occur with mysql 5.7.","title":"Issue"},{"location":"/flywayonmysql/index.html#how-the-issue-happens-","text":"Because there is one database migration file defined as below:\nDELIMITER $$\nDROP PROCEDURE IF EXISTS `createUserFundForFund` $$\nCREATE PROCEDURE `createUserFundForFund` (fiId VARCHAR(256))\nBEGIN\n  drop temporary table if exists invResult;\n ...\n  insert into userfunds (id, userid, fundid, active, deleted, createdatetime, meta) select * from newUserfunds;\n\nEND $$\nDELIMITER ；\n\nDELIMITER $$\n\nDROP PROCEDURE IF EXISTS `createUserFundForAllFunds` $$\nCREATE PROCEDURE `createUserFundForAllFunds`()\nBEGIN\n\n...\n\nEND $$\n\nDELIMITER ;\n\nCALL createUserFundForAllFunds();\nThe migration will create two procedures in database but not removed. The procedure will only affect mysql 8.0.","title":"How the issue happens?"},{"location":"/iefrontend/index.html","text":"","title":"IE issues for javascript"},{"location":"/iefrontend/index.html#ie-issues-for-javascript","text":"","title":"IE issues for javascript"},{"location":"/iefrontend/index.html#download-failed","text":"In AWM there is a function to download table content as excel, but the download function failed on IE.\nThe code for download as blow:\ndownloadCSV = (csv, filename) => {\n  var csvFile;\n  var downloadLink;\n\n  // CSV file\n  csvFile = new Blob([csv], {type: \"text/csv\"});\n\n  // Download link\n  downloadLink = document.createElement(\"a\");\n\n  // File name\n  downloadLink.download = filename;\n\n  // Create a link to the file\n  downloadLink.href = window.URL.createObjectURL(csvFile);\n\n  // Hide download link\n  downloadLink.style.display = \"none\";\n\n  // Add the link to DOM\n  document.body.appendChild(downloadLink);\n\n  // Click download link\n  downloadLink.click();\n}\nThe javascript download a blob in frontend. But this operation will be “access deny” as below:\nThe MS has its own function(msSaveBlob) to save blob, and IE only support this function msSaveBlob.\ndownloadCSV = (csv, filename) => {\n  var csvFile;\n  var downloadLink;\n\n  // CSV file\n  csvFile = new Blob([csv], {type: 'text/csv;charset=utf-8;'});\n\n\n\n  if (window.navigator.msSaveOrOpenBlob){\n    // IE hack; see http://msdn.microsoft.com/en-us/library/ie/hh779016.aspx\n    window.navigator.msSaveBlob(csvFile, filename);\n  }\n  else\n  {\n  // Download link\n  downloadLink = document.createElement(\"a\");\n\n  // File name\n  downloadLink.download = filename;\n\n  // Create a link to the file\n  downloadLink.href = window.URL.createObjectURL(csvFile);\n  console.log(downloadLink.href)\n\n  // Hide download link\n  downloadLink.style.display = \"none\";\n\n  // Add the link to DOM\n  document.body.appendChild(downloadLink);\n\n  // Click download link\n  downloadLink.click();\n\n  //document.body.removeChild(downloadLink);\n}\n}","title":"Download failed"},{"location":"/iefrontend/index.html#sidebar-missing-in-ie","text":"Sidebar works well in chrome:\nIn one page, the sidebar is missing in IE:\nThe width in IE is only 0.15px.\nTo fix this issue is straightforward:","title":"Sidebar missing in IE"},{"location":"/apicall/index.html","text":"","title":"Api call failed"},{"location":"/apicall/index.html#api-call-failed","text":"","title":"Api call failed"},{"location":"/apicall/index.html#issue","text":"In the workflow, the account number page is loading:\nIt’s caused by api error :","title":"Issue"},{"location":"/apicall/index.html#code","text":"fetchData = () => {\n    this.setState({\n      loading: true\n    })\n   ..\n    this.props.getFundEngagementById(this.props.id).then((fund) => {\n      ..\n      this.props.getAccountNameList(this.state.fundEngagementId).then((data)=>{\n       ...\n          this.setState({data: dataList, loading: false, accountNumMapFilledList: accountNumMapFilledList, accountNumMapUnfilledList: accountNumMapUnfilledList})\n          ...","title":"Code"},{"location":"/apicall/index.html#how-to-fix","text":"The robustness of API call How to wrap the state change for API call","title":"How to fix"},{"location":"/systemdesign/index.html","text":"","title":"software architecture"},{"location":"/systemdesign/index.html#software-architecture","text":"What’s reality of software development? What’re challenges of software development? The reactive manifesto Doradilla design References","title":"software architecture"},{"location":"/systemdesign/sub/reality.html","text":"","title":"Whats reality of software development?"},{"location":"/systemdesign/sub/reality.html#whats-reality-of-software-development-","text":"","title":"What’s reality of software development?"},{"location":"/systemdesign/sub/reality.html#","text":"Code for authentication:\nFor application authentication, there are 3 types: by application, by SAML at first stage, and add by Oauth in later version. For authorization, there is not needed any change for different change.\nCode for frontend controller lazy val secureSource = config.getOptional[Boolean](\"useidam\") match {\n   case Some(true) => config.getOptional[Boolean](\"pwcoauth.useoauth\") match {\n     case Some(true) => index3\n     case _ => index2\n   }\n   case _ => index\n }\n\n def index2: Action[AnyContent] = {\n   secureAction(\n     assets.at(\"index.html\")\n   )\n }\n\n def index3: Action[AnyContent] = {\n   secureActionOauth(\n     assets.at(\"index.html\")\n   )\n }\n\n def index: Action[AnyContent] = assets.at(\"index.html\") Saml def secureAction[A](action: Action[A]): Action[A] = Secure(\"SAML2Client\").async(action.parser) { implicit request =>\n  ...\n  val userInfoMap = Map(\"email\"->profiles.head.getAttribute(emailAttrStr).toString.stripPrefix(\"[\").stripSuffix(\"]\"))\n  ...\n  userTimeOpt match {\n    case Some(userTime) if nowTime - userTime.toInt > maxTimeout =>\n      Future( Redirect(\"/\").flashing(\"success\" -> \"Session timeout, you need to login.\")\n        .discardingCookies(DiscardingCookie(\"PLAY_SESSION\")).withNewSession.withHeaders(\"Cache-Control\"-> \"no-cache\"))\n    case _=>    action(request).map {\n      result =>\n        result.withSession(request.session.+(\"email\"->userInfoMap(\"email\"))\n          .+(\"useidm\"->\"true\")\n          .+(\"userTime\"->nowTime.toString)\n          .+(\"privilege\" -> privilege)).withHeaders(\"Cache-Control\"-> \"no-cache\")\n    }\n  }\n} Oauth def secureActionOauth[A](action: Action[A]): Action[A] = Secure(\"PwCClient\").async(action.parser) { implicit request =>\n  ...\n  val userInfoMap = Map(\"email\"->profiles.head.getAuthenticationAttribute(\"email\").toString)\n  updateUserLastActiveTime(userInfoMap.get(\"email\"))\n  ...\n  userTimeOpt match {\n    case Some(userTime) if nowTime - userTime.toInt > maxTimeout =>\n      Future( Redirect(\"/\").flashing(\"success\" -> \"Session timeout, you need to login.\")\n        .discardingCookies(DiscardingCookie(\"PLAY_SESSION\")).withNewSession.withHeaders(\"Cache-Control\"-> \"no-cache\"))\n    case _=>    action(request).map {\n      result =>\n        result.withSession(request.session.+(\"email\"->userInfoMap(\"email\"))\n          .+(\"useidm\"->\"true\")\n          .+(\"userTime\"->nowTime.toString)\n          .+(\"privilege\" -> privilege)).withHeaders(\"Cache-Control\"-> \"no-cache\")\n          .bakeCookies()\n    }\n  }\n} Authentication def createEngageuser() =\n  deadbolt.Pattern(value = \"(v_admin)|(v_lead)\", patternType = PatternType.REGEX)(trim(parse.json)) {implicit authRequest =>\n    // Action.async(trim(parse.json)) { implicit authRequest =>\n    try {\n        ...\n    } catch {\n      case ValidationException(msg) => Future(BadRequest(msg))\n    }\n  }","title":"Big ball of mud"},{"location":"/systemdesign/sub/issues.html","text":"","title":"Whatre challenges of software development?"},{"location":"/systemdesign/sub/issues.html#whatre-challenges-of-software-development-","text":"","title":"What’re challenges of software development?"},{"location":"/systemdesign/sub/issues.html#about-lock","text":"Lock in Java\nImplementation of lock","title":"About lock"},{"location":"/systemdesign/sub/issues.html#how-to-change-wheels-when-driving-","text":"What’s function in the developer’s view?\nval fx = A => B\nor\ndef fx(par1:Any, par2:Any,...):Any ={\n   doA(par1)\n   if(par2){\n     doB(par2)\n   }\n }\nFor example:\nWe need to query price data with business logic which is not confirmed by LoS people:\nGetByEngagementName def getEngagementSecurityPrice() = Action.async(trim(parse.json)) { implicit request => {\n    ...\n  egaRead.lookupByFundEngagementId(fundEngagementId).flatMap {\n    egaOpt =>\n      egaOpt.flatMap(_.securityItems).map(str => Json.parse(str).as[EngagementSecurity]).map {\n        engageSecurity =>\n          Future(engageSecurity.items.map {\n            securityItem =>\n              getSecrurityPrivceOrderd(securityItem.isin,securityItem.currency.getOrElse(\"\"),  date, securityItem.catagory, priceAndSource)\n          }.flatten)\n      }.getOrElse(Future(Seq()))\n  }\n}\n} GetBySecuritypriceAndOrder private def getSecrurityPrivceOrderd(isin: String,currency:String,  pricedate: String, securityType: String, priceAndSource: PriceAndSource): Seq[SecurityPrice] = {\n  var continueQuery = true\n  val sourceFrom = securityType match {\n    case \"Standard\" => priceAndSource.standard\n    case \"Future\" => priceAndSource.future\n    case \"Option\" => priceAndSource.option\n    case _ => priceAndSource.other\n  }\n  var result: Seq[SecurityPrice] = Seq()\n  val res2 = getByIsinAndDate(isin, currency, pricedate)\n  if(res2.map(_.exchange).toSet.toSeq.length ==1){\n    result =res2\n  }else\n  {\n    var priceType = \"\"\n    var source = \"\"\n    for (priceType <- priceAndSource.priceOrder) {\n      for (source <- sourceFrom) {\n        if (continueQuery && priceType.length>0  && source.length >0) {\n          val ret = getSecurityPriceByPriceAndOrder(isin, pricedate, priceType, currency,source)\n          if (ret.length > 0) {\n            continueQuery = false\n            result = ret\n          }\n        }\n      }\n    }\n  }\n  result\n} QeuryData private def getByIsinAndDate(isin: String,currency:String,  pricedate: String) = {\n  val securityPriceQuery = SecurityPriceQuery(None, None, Some(isin), None, None, None, None,Some(currency), pricedate)\n  Await.result(securityPriceRead.query(securityPriceQuery), 1 second)\n}\n\nprivate def getSecurityPriceByPriceAndOrder(isin: String, pricedate: String, priceType: String, currency:String, source: String): Seq[SecurityPrice] = {\n  val securityPriceQuery = SecurityPriceQuery(None, None, Some(isin), None, Some(priceType), Some(source), None, Some(currency),  pricedate)\n  Await.result(securityPriceRead.query(securityPriceQuery), 1 second)\n}\n\ncase class SecurityPriceQuery(cname: Option[String], gsp: Option[String], isin: Option[String], assetclass: Option[String],\n                              pricetype: Option[String], source: Option[String], exchange: Option[String], currency: Option[String],pricedate: String) QueryInDatabase override def query(securityPriceQuery: SecurityPriceQuery): Future[Seq[SecurityPrice]] = {\n  val query = Securityprices.filter(securityPrice => securityPriceQuery.cname.map(cname => securityPrice.cname === cname).getOrElse(true: Rep[Boolean]))\n    .filter(securityPrice => securityPriceQuery.gsp.map(gsp => securityPrice.gsp === gsp).getOrElse(true: Rep[Boolean]))\n    .filter(securityPrice => securityPriceQuery.isin.map(isin => securityPrice.isin === isin).getOrElse(true: Rep[Boolean]))\n    .filter(securityPrice => securityPriceQuery.assetclass.map(assetclass => securityPrice.assetclass === assetclass).getOrElse(true: Rep[Boolean]))\n    .filter(securityPrice => securityPriceQuery.pricetype.map(priceType => securityPrice.pricetype like(s\"%$priceType%\")).getOrElse(true: Rep[Boolean]))\n    .filter(securityPrice => securityPriceQuery.source.map(source => securityPrice.source === source).getOrElse(true: Rep[Boolean]))\n    .filter(securityPrice => securityPriceQuery.exchange.map(exchange => securityPrice.exchange === exchange).getOrElse(true: Rep[Boolean]))\n    .filter(securityPrice => securityPriceQuery.currency.map(currency => securityPrice.currency === currency).getOrElse(true: Rep[Boolean]))\n    .filter(securityPrice => securityPrice.pricedate === securityPriceQuery.pricedate)\n  db.run(query.result).map {\n    maybeRow => maybeRow.map(rowToEntity)\n  }\n}","title":"How to change wheels when driving?"},{"location":"/systemdesign/sub/reactive.html","text":"","title":"The reactive manifesto"},{"location":"/systemdesign/sub/reactive.html#the-reactive-manifesto","text":"Reactive manifesto","title":"The reactive manifesto"},{"location":"/systemdesign/sub/doradilla.html","text":"","title":"Doradilla design"},{"location":"/systemdesign/sub/doradilla.html#doradilla-design","text":"","title":"Doradilla design"},{"location":"/systemdesign/sub/doradilla.html#","text":"","title":"Message flow"},{"location":"/systemdesign/sub/doradilla.html#","text":"Code implementation for JobApi: Named-job api is need after anonymous api is released.\nAnonymous processor call trait ProcessTranApi extends AskProcessResult{\n  this: SystemApi with DriverApi =>\n  val processTranActor = actorSystem.actorOf(ProcessTranActor.processTranActorProps, CNaming.timebasedName( \"defaultProcessTranActor\"))\n\n  def runProcessCommand(processCallMsg: ProcessCallMsg, timeout: Timeout = longTimeout)(implicit ex: ExecutionContext): Future[JobResult] = {\n    val processJob = JobMsg(\"SimpleProcess\", processCallMsg)\n    val receiveActor = actorSystem.actorOf(ReceiveActor.receiveActorProps, CNaming.timebasedName( \"Receive\"))\n    val processJobRequest = JobRequest(processJob, receiveActor, processTranActor)\n    getProcessCommandFutureResult(processJobRequest, defaultDriver, receiveActor,timeout)\n  }\n} Named job call trait NamedJobRunner {\n  this: BackendServer.type =>\n\n  def runNamedProcessCommand(processJob: JobMsg,\n                             jobName:String,\n                             timeout: Timeout = ConstVars.longTimeOut,\n                             priority: Option[Int] = None)(implicit ex: ExecutionContext): Future[JobResult] = {\n    val jobApi = getNamedJobApi(jobName)\n    val receiveActor = jobApi.actorSystem.actorOf(ReceiveActor.receiveActorProps, CNaming.timebasedName(\"Receive\"))\n    val processJobRequest = JobRequest(processJob, receiveActor, jobApi.processTranActor, priority)\n    getProcessCommandFutureResult(processJobRequest, jobApi.defaultDriver, receiveActor,timeout)\n  }\n} Use in AWM def runProcess(paras : List[Object], clazzName:String, methodName:String, prioritySet: Option[Int] = None) ={\n  println(clazzName)\n  val msg = ProcessCallMsg(clazzName,methodName,paras.map{_.asInstanceOf[AnyRef]}.toArray)\n  val jobMsg = JobMsg(\"SimpleProcess\",msg)\n  BackendServer.runProcessCommand(jobMsg,priority = prioritySet)\n} Use in CIDR def runProcess(paras : List[AnyRef], clazzName:String, methodName:String, prioritySet: Option[Int] = None) ={\n  val setTimeOut:Timeout = 6000 seconds\n  val msg = ProcessCallMsg(clazzName,methodName,paras.map{_.asInstanceOf[AnyRef]}.toArray)\n  val jobMsg = JobMsg(\"SimpleProcessFuture\",msg)\n  val namedSevice = Seq(\"com.pwc.ds.cidr.project.creditreview.processors.OcrPlusProcessor\")\n  if(namedSevice.contains(clazzName)){\n    BackendServer.runNamedProcessCommand(jobMsg,OCRJOBStr, priority = prioritySet,timeout = setTimeOut).map{\n      jobResult=>\n        if((jobResult.result.asInstanceOf[ProcessResult]).jobStatus.toString == \"Failed\" ){\n          throw new RuntimeException(jobResult.result.asInstanceOf[ProcessResult].result.asInstanceOf[Exception].getMessage)\n        }\n        jobResult.result.asInstanceOf[ProcessResult].result.asInstanceOf[ProcessorResultValue]\n    }\n  }else{\n    BackendServer.runProcessCommand(jobMsg,priority = prioritySet,timeout = setTimeOut).map{\n      jobResult=>\n        if((jobResult.result.asInstanceOf[ProcessResult]).jobStatus.toString == \"Failed\" ){\n          throw new RuntimeException(jobResult.result.asInstanceOf[ProcessResult].result.asInstanceOf[Exception].getMessage)\n        }\n        jobResult.result.asInstanceOf[ProcessResult].result.asInstanceOf[ProcessorResultValue]\n    }\n  }\n}","title":"JobApi design"},{"location":"/systemdesign/sub/reference.html","text":"","title":"References"},{"location":"/systemdesign/sub/reference.html#references","text":"Big ball of mud\nThe Reactive Manifesto\n噢，你的代码像一坨翔。然后呢？\n噢，你的代码像一坨翔。甩锅呗！","title":"References"},{"location":"/poiexcel/index.html","text":"","title":"Excel reader using POI"},{"location":"/poiexcel/index.html#excel-reader-using-poi","text":"","title":"Excel reader using POI"},{"location":"/poiexcel/index.html#issue","text":"AWM process user’s excel input throws exception as below:\nIt’s shows index out of boundary on index 3, but the excel has 4 columns.\nIn debug mode, shows output of reader, some rows has 4 columns while some rows has 3 columns.\nOpen the excel, the 4-column line has empty cell which type is “General”:\nAnd 3-clumn line has empty cell which type is “Text”:\nIn debugger, when use cellIterator, POI will pass the empty cell which type is “Text” because POI will remove the empty cell which type is text:","title":"Issue"},{"location":"/poiexcel/index.html#fix","text":"For POI will not read empty “Text” cell, and iterator method will be not apply if need the formatted result.\nCode use iterator def excelToArray(filePath: String) :Seq[Seq[ExcelField]]={\n    ...\n  while (rowIterator.hasNext){\n    val rowT = rowIterator.next()\n    var rowSeq:Seq[ExcelField]=Seq()\n    val cellInterator = rowT.cellIterator()\n    while(cellInterator.hasNext){\n      val cellT = cellInterator.next()\n      rowSeq =rowSeq :+ getCellValue(cellT)\n    }\n    res =res :+rowSeq\n  }\n}\n\ndef getCellValue(cell: Cell):ExcelField={\n  val decimalFormat: DecimalFormat = new DecimalFormat(\"0.##\")\n  cell.getCellType match {\n    case CellType.BOOLEAN => ExcelField(ExcelFieldType.BoolType, cell.getBooleanCellValue.toString)\n    case CellType.NUMERIC => if(DateUtil.isCellDateFormatted(cell)){\n      ExcelField(ExcelFieldType.DateType,cell.getDateCellValue.toString)\n    }else{\n      try {\n        ExcelField(ExcelFieldType.NumberType,decimalFormat.format(cell.getNumericCellValue))\n      }catch {\n        case e:Exception =>\n          ExcelField(ExcelFieldType.Unknown,cell.getStringCellValue)\n      }\n\n    }\n    case CellType.STRING => ExcelField(ExcelFieldType.StringType, cell.getStringCellValue.trim)\n    case CellType.FORMULA => try{\n      ExcelField(ExcelFieldType.NumberType, decimalFormat.format( cell.getNumericCellValue))\n    }catch {\n      case e:Exception =>\n        ExcelField(ExcelFieldType.Unknown,cell.getCellFormula)\n    }\n\n    case _=>ExcelField(ExcelFieldType.Unknown,cell.getStringCellValue)\n  }\n} Code use index def excelToArray(filePath: String) :Seq[Seq[ExcelField]]={\n    ...\n  while (rowIterator.hasNext){\n    val rowT = rowIterator.next()\n    var rowSeq:Seq[ExcelField]=Seq()\n    val Numbers = rowT.getLastCellNum()\n    var i =0\n    while(i< Numbers){\n      val cellT = rowT.getCell(i)\n      rowSeq =rowSeq :+ getCellValue(cellT)\n      i = i+1\n    }\n    res =res :+rowSeq\n  }\n  removeEmptyEnd(res)\n}\n\ndef getCellValue(cell: Cell):ExcelField={\n  try {\n    val decimalFormat: DecimalFormat = new DecimalFormat(\"0.0000\")\n    val dateFormat = new SimpleDateFormat(\"yyyy/MM/DD\");\n    cell.getCellType match {\n      case CellType.BOOLEAN => ExcelField(ExcelFieldType.BoolType, cell.getBooleanCellValue.toString)\n      case CellType.NUMERIC => if (DateUtil.isCellDateFormatted(cell)) {\n        ExcelField(ExcelFieldType.DateType, dateFormat.format(cell.getDateCellValue))\n      } else {\n        try {\n          ExcelField(ExcelFieldType.NumberType, decimalFormat.format(cell.getNumericCellValue))\n        } catch {\n          case e: Exception =>\n            ExcelField(ExcelFieldType.Unknown, cell.getStringCellValue)\n        }\n\n      }\n      case CellType.STRING => ExcelField(ExcelFieldType.StringType, cell.getStringCellValue.trim)\n      case CellType.FORMULA => try {\n        ExcelField(ExcelFieldType.NumberType, decimalFormat.format(cell.getNumericCellValue))\n      } catch {\n        case e: Exception =>\n          ExcelField(ExcelFieldType.Unknown, cell.getCellFormula)\n      }\n\n      case _ => ExcelField(ExcelFieldType.Unknown, cell.getStringCellValue)\n    }\n  }catch {\n    case e:Exception =>\n      ExcelField(ExcelFieldType.Unknown,\"\")\n  }\n}\nFor use index to get null for inplace cell, need to catch exception for null input.","title":"Fix"},{"location":"/future/index.html","text":"","title":"Future value"},{"location":"/future/index.html#future-value","text":"","title":"Future value"},{"location":"/future/index.html#future-with-sequence","text":"There are two tasks for file upload record job: 1. extract excel fields to records 2. record to database\nWhen there is no asynchronous context in the job about 12 seconds:\nWhen use Future.sequence in the job costs about 15 seconds:\nWhen only use Future in the job only less than 4 seconds(for file upload and extract):","title":"Future with sequence"},{"location":"/lockless/index.html","text":"","title":"Lockless design"},{"location":"/lockless/index.html#lockless-design","text":"","title":"Lockless design"},{"location":"/lockless/index.html#multi-thread-update-for-same-field","text":"In a project, there is need to process multiple files from user:\nAfter all files are uploaded, there are random files are not recorded (13 files uploaded, only 11 files recorded):\nThe uploaded file is recorded in database field etcs:","title":"Multi-thread update for same field"},{"location":"/lockless/index.html#use-named-job-to-remove-lock","text":"The recording error is caused by multiple threads update same field in database like below:\ndef update(file:String,dbid:String)={\n  val files = dbreader.getfiles(dbid)\n  dbwrite.record(files.append(file))\n}\nThe classical way for fixing this issue is to have a lock on the operation.\nUse namedjob to have lockless as below:\nCall processor def handleConfirmationsResult(user: String, fileName: String, ***) = {\n  if (jobResult.result.isInstanceOf[ProcessResult]) {\n    val storageResult = jobResult.result.asInstanceOf[ProcessResult]\n    if (storageResult.result.isInstanceOf[ConfirmationSingleEGAStorage]) {\n      //Original code\n      //Await.result(FundEngagementReportTypeSelectionController.exportConfirmationToDatabase(user, fileName,***), 10 seconds)\n\n      //Using namedjob\n      doraServer.runNamedProcess(List(user,fileName,***),\"com.pwc.ds.awm.processor.DatabaseUpdateProcessor\",\"exportConfirmationToDatabase\")\n    }\n  }\n} Processor class DatabaseUpdateProcessor {\n  def exportConfirmationToDatabase(user: String, fileName: String, ***)={\n    Await.result( FundEngagementReportTypeSelectionController.exportConfirmationToDatabase(user,fileName,***), 10 seconds)\n  }\n} NamedJob wrap def runNamedProcess(paras : List[Object], clazzName:String, methodName:String, prioritySet: Option[Int] = None,name:String =singleDBJob) ={\n  val msg = ProcessCallMsg(clazzName,methodName,paras.map{_.asInstanceOf[AnyRef]}.toArray)\n  val jobMsg = JobMsg(\"SimpleProcess\",msg)\n  BackendServer.runNamedProcessCommand(jobMsg,name,priority = prioritySet)\n}\nFor more information about named job : Named job","title":"Use named job to remove lock"},{"location":"/upgradeissue/index.html","text":"","title":"Upgrade issue for authentication"},{"location":"/upgradeissue/index.html#upgrade-issue-for-authentication","text":"","title":"Upgrade issue for authentication"},{"location":"/upgradeissue/index.html#health-check-setting-issue","text":"In AWM project, code upgrade with new authentication method from SAML2 to OpenID. The upgrade is successfully applied in QA environment; but in UAT environment, all API calls to application are lost.\nApi call success in QA:\nBut api call failed in UAT:\nWhat’s different with QA and UAT in network architecture?\nIn QA environment, there is only one standalone server for application, api call could go directly to the application.\nIn UAT environment, there are two servers for application, and nginx server to proxy api calls to the application servers, and a network load balancer for nginx server.\nOn network load balancer for nginx, there is health check for application setting to “/” which is the root path of the application.\nRoute config GET     /api/summary             controllers.HomeController.appSummary\n\n+ nocsrf\nGET     /                        controllers.FrontendController.secureSource()\nBecause the root path is secured by authentication method, when user visit root path, user will redirect to authentication site for user login.\nWhen using SAML2, when health check hit root path, with return 200:\nWhen using OpenId, when health check hit root path, with return code 303:\nSo when upgrade from SAML2 to OpenId, the return code is change from 200 to 303, then the network load balancer will block all traffic to the application.","title":"Health check setting issue"},{"location":"/dbinsert/index.html","text":"","title":"DB bulk insert"},{"location":"/dbinsert/index.html#db-bulk-insert","text":"","title":"DB bulk insert"},{"location":"/dbinsert/index.html#db-multiple-insert-issue","text":"In AWM, there is a function for user to upload GSP data:\nThen the backend will process these data, there are more than 20000 record in the excel:\nBut after backend processing finished, there are only 8451 records in the database:\nwhen upload the same file after 8 times, the number goes to 21751:\nCode for record in backend:\nController def securityPriceFileRecord() = deadbolt.SubjectPresent()(parse.multipartFormData) {\n  implicit request => {\n    request.body.file(\"file\").map {\n      file =>\n        val excelResult = ExcelToArray.excelToArray(file.ref.toFile.getAbsolutePath)\n        val priceSeqOpt = RecordToSecurityPrice.getInputExcel(excelResult)\n        priceSeqOpt match {\n          case Some(priceSeq) => Future(priceSeq.map {\n            priceTemp => securityPriceWrite.recordSecurityPrice(priceTemp)\n          })\n            Future(Ok(s\"${priceSeqOpt.get.length} records recorded.\"))\n          case None => Future(BadRequest(\"This does not seem to be a GSP output file.\"))\n        }\n    }.getOrElse(Future(BadRequest))\n  }\n} Service override def recordSecurityPrice(securityPrice: SecurityPrice): Future[Int] = {\n  val queryItem = SecurityPriceQuery(getQueryItem(securityPrice.cname), getQueryItem(securityPrice.gsp), getQueryItem(securityPrice.isin),\n    None, getQueryItem(securityPrice.pricetype), getQueryItem(securityPrice.source), getQueryItem(securityPrice.exchange), getQueryItem(securityPrice.currency), securityPrice.pricedate)\n  securityPriceDAO.query(queryItem).flatMap {\n    securityPriceSeq =>\n      securityPriceSeq.headOption match {\n        case None => val newRecord = securityPrice.copy(id = UUID.randomUUID().toString)\n          securityPriceDAO.create(newRecord)\n        case Some(securityPriceOld) => val updateSecurity = securityPrice.copy(id = securityPriceOld.id)\n          securityPriceDAO.update(updateSecurity)\n      }\n  }\n} DB override def create(securiryPrice: SecurityPrice): Future[Int] = {\n  db.run(\n    Securityprices += entityToRow(securiryPrice)\n  )\n}\n\noverride def update(securityPrice: SecurityPrice): Future[Int] = {\n  db.run(\n    queryById(securityPrice.id).update(entityToRow(securityPrice))\n  )\n}\nFrom the service, it shows every item recording will cost 2 trips around with the database, and the database status will be :\nRefine code with batch record:\nController def securityPriceFileRecord() = deadbolt.SubjectPresent()(parse.multipartFormData) {\n  implicit request => {\n    request.body.file(\"file\").map {\n      file =>\n        val excelResult = ExcelToArray.excelToArray(file.ref.toFile.getAbsolutePath)\n        val priceSeqOpt = RecordToSecurityPrice.getInputExcel(excelResult)\n        priceSeqOpt match {\n          case Some(priceSeq) => Future(\n            securityPriceWrite.recordMultiple(priceSeq)\n          )\n            Future(Ok(s\"${priceSeqOpt.get.length} records recorded.\"))\n          case None => Future(BadRequest(\"This does not seem to be a GSP output file.\"))\n        }\n    }.getOrElse(Future(BadRequest))\n  }\n} Service override def recordMultiple(securityPriceList: Seq[SecurityPrice]): Future[Seq[Int]] = {\n  securityPriceDAO.recordMultiple(securityPriceList)\n} DB override def recordMultiple(securityPriceList:Seq[SecurityPrice])={\n  val seqRecord = securityPriceList.map(insertOrUpdate)\n  db.run( DBIO.sequence(seqRecord))\n}\n\ndef insertOrUpdate(securityPrice: SecurityPrice)={\n  val recordOption= Securityprices.filter(_.cname ===securityPrice.cname)\n    .filter(_.isin === securityPrice.isin)\n    .filter(_.gsp === securityPrice.gsp)\n    .filter(_.pricedate === securityPrice.pricedate)\n    .filter(_.assetclass === securityPrice.assetclass)\n    .filter(_.exchange ===securityPrice.exchange)\n    .filter(_.source ===securityPrice.source)\n    .filter(_.pricetype === securityPrice.pricetype)\n    .filter(_.currency === securityPrice.currency).result.headOption\n  for{\n    existing<-recordOption\n    row = existing.map{price=>entityToRow(securityPrice).copy(id = price.id)}.getOrElse(entityToRow(securityPrice))\n    result <-Securityprices.insertOrUpdate(row)\n  }yield result\n}\nAfter the code change, all items are recorded:","title":"DB multiple insert issue"},{"location":"/dbinsert/index.html#performance-issue","text":"The record function has some performance issue, each record insert will also have 2 trip around to database, here is using remote mysql server to compare performance:\nThe refine db insert code as below:\nNot refined override def recordMultiple(securityPriceList:Seq[SecurityPrice])={\n  val seqRecord = securityPriceList.map(insertOrUpdate)\n  db.run( DBIO.sequence(seqRecord))\n}\n\ndef insertOrUpdate(securityPrice: SecurityPrice)={\n  val recordOption= Securityprices.filter(_.cname ===securityPrice.cname)\n    .filter(_.isin === securityPrice.isin)\n    .filter(_.gsp === securityPrice.gsp)\n    .filter(_.pricedate === securityPrice.pricedate)\n    .filter(_.assetclass === securityPrice.assetclass)\n    .filter(_.exchange ===securityPrice.exchange)\n    .filter(_.source ===securityPrice.source)\n    .filter(_.pricetype === securityPrice.pricetype)\n    .filter(_.currency === securityPrice.currency).result.headOption\n  for{\n    existing<-recordOption\n    row = existing.map{price=>entityToRow(securityPrice).copy(id = price.id)}.getOrElse(entityToRow(securityPrice))\n    result <-Securityprices.insertOrUpdate(row)\n  }yield result\n} Refined private def getHashID(securityPrice: SecurityPrice):String={\n  val strToHash:String = securityPrice.gsp+ securityPrice.isin +securityPrice.pricetype + securityPrice.source+\n    securityPrice.exchange + securityPrice.pricedate + securityPrice.cname +securityPrice.currency +securityPrice.assetclass\n  MessageDigest.getInstance(\"MD5\").digest(strToHash.getBytes).map(0xFF & _).map { \"%02x\".format(_) }.foldLeft(\"\"){_ + _} +\n    securityPrice.pricedate + securityPrice.cname\n}\n\n\noverride def recordMultiple(securityPriceList:Seq[SecurityPrice])={\n  val idChangedList = securityPriceList.map{\n    item=> val newID = getHashID(item)\n      item.copy(id = newID)\n  }.groupBy(_.id).map(_._2.head).toSeq\n  val seqRecord = idChangedList.map(entityToRow)\n  val ids = idChangedList.map(_.id)\n  val idExisted= Await.result( db.run(Securityprices.filter(_.id.inSet(ids)).result).map(seq =>seq.map(_.id))\n    .map(seq=>seq.toSet), 3 seconds)\n  println(idExisted)\n  val newSecurity = seqRecord.filterNot(item=>idExisted.contains(item.id))\n  db.run(Securityprices++= newSecurity)\n}\nAfter refined, with same configuration, the inserting performance as below:","title":"Performance issue"},{"location":"/dbinsert/index.html#md5-issue-for-compare","text":"","title":"Md5 issue for compare"},{"location":"/dbinsert/index.html#questions","text":"1.Why only 8451 items record in the first scenarios:\nBecause in first scenarios, all items for insert are running in separated DB request, There is some setting for db connection:\nmyapp = {\n  database = {\n    ***\n\n    // The number of threads determines how many things you can *run* in parallel\n    // the number of connections determines you many things you can *keep in memory* at the same time\n    // on the database server.\n    // numThreads = (core_count (hyperthreading included))\n    numThreads = 10\n\n    // queueSize = ((core_count * 2) + effective_spindle_count)\n    // on a MBP 13, this is 2 cores * 2 (hyperthreading not included) + 1 hard disk\n    queueSize = 500\n\n    // https://blog.knoldus.com/2016/01/01/best-practices-for-using-slick-on-production/\n    // make larger than numThreads + queueSize\n    maxConnections = 20\n\n    connectionTimeout = 30000\n    validationTimeout = 30000\n  }\n}\n2.Why there is more than 20071 records in first scenarios when upload files multiple times:\nBecause the inserting are in the different threads to query if same item existed in db, then the insert operations will insert same record at same time in different threads.","title":"Questions"},{"location":"/react/index.html","text":"","title":"React web render"},{"location":"/react/index.html#react-web-render","text":"","title":"React web render"},{"location":"/react/index.html#the-null-element-after-refresh","text":"In AWM the when click the fist tab and go to second tab, every thing goes well\nFirst Tab:\nSecond Tab:\nWhen refresh page on second tab, the “Audit Period End” field is missing\"\nLet’s see how the “Audit Period End” field is rendered:\nIn validation component renderUploadGSP = () => {\n  if (this.state.operationType == \"uploadGSP\") {\n    return <UploadGSPOutputList id={this.props.id} engagementId={this.props.engagementId}\n    fundName={this.props.fundName} auditPeriodEnd={this.props.auditPeriodEnd} />\n  } else return null\n}\nrender() {\n  return (\n    <div className=\"valuations-container\">\n      {this.renderUploadGSP()}\n    </div>\n  )\n} In GSP component  priceGroupColumn: EditableColumnProps<SecurityPriceInfo> = {\n   title: <div style={{display: \"flex\"}}>\n     <p>Audit Period End </p>\n     <p style={{color: \"#e03220\", fontWeight: \"bold\"}}>&nbsp;(Price as of {new Date(Number(this.props.auditPeriodEnd.split(\"-\")[0]), Number(this.props.auditPeriodEnd.split(\"-\")[1])-1, Number(this.props.auditPeriodEnd.split(\"-\")[2])).toString().split(\" \")[1] + \" \"\n     ...\n   </div>,\n   ...\n\nrender() {\n   let columns = []\n   columns=[...columns, this.statusColumn, this.securityCategoryColumn, this.securityNameFundAdminColumn, this.ISINColumn, this.currencyColumn, this.exchangeColumn, this.priceGroupColumn]\n   return (\n     <div>\n       ...\n       <div id=\"securityEditableTable\" className=\"security-price-editable-table\">\n         <EditableTable\n           columns={columns}\n           dataSource={this.state.data}\n           //dataSource={fakeData}\n           controlData={true}\n           loading={this.state.loading}\n           onModify={this.onModify}\n           enableAdd={false}\n           pagination={false}\n           rowKey=\"id\"\n           showControls={false}\n         />\n       </div>\n       ..\n     </div>\n   )\n }\nAnd the field is controlled by {this.props.auditPeriodEnd} in validation component, if the page is refreshed,\nfirst the props value will be:\nand the props will be updated by its parent component:\nthe updated props value is not applied to the GSP component.","title":"The null element after refresh"},{"location":"/react/index.html#fix-","text":"Change the code from\ntitle: <div style={{display: \"flex\"}}>\n      <p>Audit Period End </p>\n      <p style={{color: \"#e03220\", fontWeight: \"bold\"}}>&nbsp;(Price as of {new Date(Number(this.props.auditPeriodEnd.split(\"-\")[0]), Number(this.props.auditPeriodEnd.split(\"-\")[1])-1, Number(this.props.auditPeriodEnd.split(\"-\")[2])).toString().split(\" \")[1] + \" \"\n      ...\n    </div>,\nto\ntitle: ()=> <div style={{display: \"flex\"}}>\n      <p>Audit Period End </p>\n      <p style={{color: \"#e03220\", fontWeight: \"bold\"}}>&nbsp;(Price as of {new Date(Number(this.props.auditPeriodEnd.split(\"-\")[0]), Number(this.props.auditPeriodEnd.split(\"-\")[1])-1, Number(this.props.auditPeriodEnd.split(\"-\")[2])).toString().split(\" \")[1] + \" \"\n      ...\n    </div>,","title":"Fix:"},{"location":"/oom/index.html","text":"","title":"Out of memory for batch job"},{"location":"/oom/index.html#out-of-memory-for-batch-job","text":"","title":"Out of memory for batch job"},{"location":"/oom/index.html#iusse","text":"When we want to process batch job in scala, there may trigger OOM issue if we process batch job in same thread like below:\nThe code as below:\nProcess excel files in folder def verifyExcelFolder()=Action{\n  val folferPath =\"../temp/\"\n  val files = recursiveListFiles(new File(folferPath))\n  val excelFiles =files.filter(file =>file.getName.toLowerCase.endsWith(\".xls\")||\n    file.getName.toLowerCase.endsWith(\".xlsx\"))\n  val fileInfos = excelFiles.map{\n    file => new FileInfo(file.getName,file.getAbsolutePath)\n  }\n  val resultsFuture = fileInfos.toSeq.map{\n    fileInfo => verifyFileForNoMatchedFormula(fileInfo)\n  }\n  Ok(files.length.toString)\n} Actions on excel file private def verifyFileForNoMatchedFormula(fileInfo: FileInfo) = {\n  val resultForExcel = downloadService.downloadForFile(Seq(fileInfo))\n  val filePath = \"conf/Download.xlsx\"\n  val workbook = new XSSFWorkbook(new FileInputStream(new File(filePath)))\n  try{\n    downloadService.evaluateExtractedDataToExcel(resultForExcel._1, workbook)\n  } catch {\n    case ex=>\n      println(ex)\n  }\n  val result = downloadService.evaluateExtractedDataToExcel(resultForExcel._1, workbook)\n  workbook.close()\n  result\n}\nIn the code, all excel files in folder “temp” will be processed with “verifyFileForNoMatchedFormula” method which is memory consuming job.\nHow to fix:\nFix for process def verifyExcelFolder()=Action{\n  val folferPath =\"../temp/\"\n  val files = recursiveListFiles(new File(folferPath))\n  val excelFiles =files.filter(file =>file.getName.toLowerCase.endsWith(\".xls\")||\n    file.getName.toLowerCase.endsWith(\".xlsx\"))\n  val fileInfos = excelFiles.map{\n    file => new FileInfo(file.getName,file.getAbsolutePath)\n  }\n  val resultsFuture = Future.sequence( fileInfos.toSeq.map{\n    fileInfo => Future( verifyFileForNoMatchedFormula(fileInfo))\n  })\n  Ok(files.length.toString)\n}","title":"Iusse"},{"location":"/purefunction/index.html","text":"","title":"Pure function design"},{"location":"/purefunction/index.html#pure-function-design","text":"","title":"Pure function design"},{"location":"/purefunction/index.html#start-from-simple-example","text":"The book Function Programming in Scala start with how to create pure function methods with example of Cofe shop:\nStarter class Cafe{\n  def buyCoffee(cc: CreditCard):Coffee={\n    val cup = new Coffee()\n    cc.charge(cup.price)\n    cup\n  }\n} With payment interface class Cafe{\n  def buyCoffee(cc: CreditCard,p: Payment):Coffee={\n    val cup = new Coffee()\n    p.charge(cc, cup.price)\n    cup\n  }\n} Pure function class Cafe{\n  def buyCoffee(cc: CreditCard):(Coffee,Charge)={\n    val cup = new Coffee()\n    (cup,Charge(cc,cup.price))\n  }\n}\n\ncase class Charge(cc: CreditCard,amount:Double){\n  def combine(other:Charge):Charge={\n    if(cc == other.cc)\n      Charge(cc, amount + other.amount)\n  }\n}","title":"Start from simple example"},{"location":"/purefunction/index.html#for-awm-project","text":"In AWM project, main data workflow is from input files to EGA(Excel file).\ninput file => extract content => post extraction actions and write to excel\nAt first time, “post extraction action and write to excel” are in same step. As time goes on, there are more requirement on post extraction actions. New post extraction actions are added to the system.\nIf keep the same design, the “post extraction action and write to excel” will blow up and more spaghetti code shows up.\ninput file => extract content => post extraction actions => write to excel\nData type translation:\nextract content: [File] => [User Define Content]\nPost extraction action:[User Define Content] => [User Define Content]\nwrite to excel: [User Define Content] => [Excel File]\nThere could show the “Post extraction action” which is idempotent operation, which means add more “Post extraction action” may impact too much to existed code.","title":"For AWM project"},{"location":"/codeissue/index.html","text":"","title":"Code issue"},{"location":"/codeissue/index.html#code-issue","text":"","title":"Code issue"},{"location":"/codeissue/index.html#initialize-exception","text":"The exception happens as below, and the exception can’t tell more information\nGo to CustomDictionary class:\nThen go to service object:","title":"Initialize exception"},{"location":"/timeout/index.html","text":"","title":"Timeout errors and crash"},{"location":"/timeout/index.html#timeout-errors-and-crash","text":"","title":"Timeout errors and crash"},{"location":"/timeout/index.html#error-in-dev","text":"In project, when return value is :\nOk(\"Extract Success\")\nThe result will crush when return value changes to:\nOk(\"Extraction Success\")\nIn dev environment, the UI will crash:\nwhile in prod environment, the UI will not crash, but spin will not stop:\nFor the crash is different in dev and prod environment, let’s see the cause code in front-end:","title":"Error in dev"},{"location":"/timeout/index.html#gateway-timeout","text":"When running long job in rest api. there will throw 502 gateway timeout from nginx. There are two main causes:\nnginx timeout settingdefault is 90s\nserver{\n   ...\n   proxy_read_timeout 300;\n   proxy_connect_timeout 300;\n   proxy_send_timeout 300; \n   ...\n}\nplay server for idle timeoutdefault is 85s\nplay.server.http.idleTimeout = 180s","title":"Gateway timeout"},{"location":"/presentationlayer/index.html","text":"","title":"Refactor code for Excel output"},{"location":"/presentationlayer/index.html#refactor-code-for-excel-output","text":"","title":"Refactor code for Excel output"},{"location":"/presentationlayer/index.html#presentation-layer-for-excel-output","text":"We use Apache POI for Excel output in system.\ncase class OutPutParam(sheetName: String,\n                       columnList: Seq[ColumnWithType],\n                       sheetContent: () => Seq[Map[String, String]],\n                       startWritingRow: Int)\n\ncase class ColumnWithType(columnName:String,\n                          columnType:ExcelColumnFormat = ExcelColumnFormat.format_string,\n                          notfoundValue:String=\"\")\n\nobject ExcelColumnFormat extends Enumeration {\n  type ExcelColumnFormat = Value\n  val user_input =Value(\"USERVALUE\")\n  val format_string = Value(\"STRING\")\n  val format_date = Value(\"DATE\")\n  val format_double = Value(\"DOUBLE\")\n  val format_double2d = Value(\"DOUBLE2D\")\n  val format_double4d = Value(\"DOUBLE4D\")\n  val format_double_without_comma = Value(\"DOUBLEWITHOUTCOMMA\")\n    ....\n}\nFor each fund admin, there is a definition of EGA storage:\nGeneralEGAStorage import java.text.SimpleDateFormat\n\nimport scala.collection.Map\n\nclass GeneralSingleEGAStorage {\n  var errorMsg: ErrorStatus = ErrorStatus(false,\"\")\n  var warningMsg: WarningStatus = WarningStatus(false,\"\")\n\n  var trialBalanceReportTBData: Seq[Map[String, String]] = Seq()\n\n  var detailedGeneralLedgerReportGLData: Seq[Map[String, String]] = Seq()\n  var detailedGeneralLedgerReportGLAfterYEData: Seq[Map[String, String]] = Seq()\n\n  var positionAppraisalReportPositionData: Seq[Map[String, String]] = Seq()\n\n  var cashAppraisalReportCashData: Seq[Map[String, String]] = Seq()\n\n  var purchaseAndSaleTransactionReportPSRData: Seq[Map[String, String]] = Seq()\n  var purchaseAndSaleTransactionReportPSRAfterYEData: Seq[Map[String, String]] = Seq()\n\n  var dividendsIncomeExpenseReportDividendData: Seq[Map[String, String]] = Seq()\n  var dividendsIncomeExpenseReportDividendAfterYEData: Seq[Map[String, String]] = Seq()\n\n  var realisedGainLossReportRGLData: Seq[Map[String, String]] = Seq()\n  var realisedGainLossReportRGLAfterYEData: Seq[Map[String, String]] = Seq()\n\n  val positionParam = OutPutParam(\"Position\",EGAConstMorganStanley.positionColumnList, () => {this.positionAppraisalReportPositionData},1)\n  val cashParam = OutPutParam(\"Cash\",EGAConstMorganStanley.cashColumnList,() => {this.cashAppraisalReportCashData},1)\n  val PSRParam = OutPutParam(\"PSR\",EGAConstMorganStanley.PSRColumnList,() => {this.purchaseAndSaleTransactionReportPSRData} ,1)\n  val PSRAfterYEParam = OutPutParam(\"PSR (after YE)\",EGAConstMorganStanley.PSRColumnList,() => {this.purchaseAndSaleTransactionReportPSRAfterYEData},1)\n  val TBParam = OutPutParam(\"TB\",EGAConstMorganStanley.TBColumnList, () => {this.trialBalanceReportTBData},3)\n  val GLParam = OutPutParam(\"GL\",EGAConstMorganStanley.GLColumnList,() => {this.detailedGeneralLedgerReportGLData},1)\n  val GLAfterYEParam = OutPutParam(\"GL (after YE)\",EGAConstMorganStanley.GLColumnList,() => {this.detailedGeneralLedgerReportGLAfterYEData},1)\n  val dividendParam = OutPutParam(\"Dividend\",EGAConstMorganStanley.dividendColumnList,() => {this.dividendsIncomeExpenseReportDividendData},1)\n  val dividendAfterYEParam = OutPutParam(\"Dividend (after YE)\",EGAConstMorganStanley.dividendColumnList,() => {this.dividendsIncomeExpenseReportDividendAfterYEData},1)\n  val RGLParam = OutPutParam(\"RGL\",EGAConstMorganStanley.RGLColumnList,() => {this.realisedGainLossReportRGLData},1)\n  val RGLAfterYEParam = OutPutParam(\"RGL (after YE)\",EGAConstMorganStanley.RGLColumnList,() => {this.realisedGainLossReportRGLAfterYEData},1)\n\n  val outputParams = Seq(positionParam,cashParam,PSRParam,PSRAfterYEParam,TBParam,GLParam,GLAfterYEParam,dividendParam,dividendAfterYEParam,RGLParam,RGLAfterYEParam)\n  val outputDateFormat = Some(new SimpleDateFormat(\"yyyy/MM/dd\"))\n} EGAConstMorgenStanley object EGAConstMorganStanley {\n  val positionColumnList = EGAConstBase.replaceColumn( EGAConstBase.positionColumnList,\"Group1\",ColumnWithType(\"Group1\",ExcelColumnFormat.format_formula))\n\n  val cashColumnList = EGAConstBase.cashColumnList\n\n  val PSRColumnList = EGAConstBase.PSRColumnList\n\n  val TBColumnList = EGAConstBase.TBColumnList\n\n  val GLColumnList = EGAConstBase.replaceColumn(EGAConstBase.GLColumnList,\"EndingBalanceAmount\",ColumnWithType(\"EndingBalanceAmount\",ExcelColumnFormat.format_formula))\n\n  val dividendColumnList = EGAConstBase.dividendColumnList\n\n  val RGLColumnList = EGAConstBase.RGLColumnList\n}\nEven the “GeneralEGAStorage” has the name of general, but it uses the MorganStanly’s const.\nIf another fund admin has different ColumList definition, there will need another **EGAStorage.\nHow could we define a general EGAStorage:\nGenericSingleEGAStorage import java.text.SimpleDateFormat\n\nimport scala.collection.Map\n\nclass GeneralSingleEGAStorage {\n  this: EGAColConstBase =>\n  var errorMsg: ErrorStatus = ErrorStatus(false,\"\")\n  var warningMsg: WarningStatus = WarningStatus(false,\"\")\n\n  var trialBalanceReportTBData: Seq[Map[String, String]] = Seq()\n\n  var detailedGeneralLedgerReportGLData: Seq[Map[String, String]] = Seq()\n  var detailedGeneralLedgerReportGLAfterYEData: Seq[Map[String, String]] = Seq()\n\n  var positionAppraisalReportPositionData: Seq[Map[String, String]] = Seq()\n\n  var cashAppraisalReportCashData: Seq[Map[String, String]] = Seq()\n\n  var purchaseAndSaleTransactionReportPSRData: Seq[Map[String, String]] = Seq()\n  var purchaseAndSaleTransactionReportPSRAfterYEData: Seq[Map[String, String]] = Seq()\n\n  var dividendsIncomeExpenseReportDividendData: Seq[Map[String, String]] = Seq()\n  var dividendsIncomeExpenseReportDividendAfterYEData: Seq[Map[String, String]] = Seq()\n\n  var realisedGainLossReportRGLData: Seq[Map[String, String]] = Seq()\n  var realisedGainLossReportRGLAfterYEData: Seq[Map[String, String]] = Seq()\n\n  lazy val positionParam = OutPutParam(\"Position\",positionColumnList, () => {this.positionAppraisalReportPositionData},1)\n  lazy val cashParam = OutPutParam(\"Cash\",cashColumnList,() => {this.cashAppraisalReportCashData},1)\n  lazy val PSRParam = OutPutParam(\"PSR\",PSRColumnList,() => {this.purchaseAndSaleTransactionReportPSRData} ,1)\n  lazy val PSRAfterYEParam = OutPutParam(\"PSR (after YE)\",PSRColumnList,() => {this.purchaseAndSaleTransactionReportPSRAfterYEData},1)\n  lazy val TBParam = OutPutParam(\"TB\",TBColumnList, () => {this.trialBalanceReportTBData},3)\n  lazy val GLParam = OutPutParam(\"GL\",GLColumnList,() => {this.detailedGeneralLedgerReportGLData},1)\n  lazy val GLAfterYEParam = OutPutParam(\"GL (after YE)\",GLColumnList,() => {this.detailedGeneralLedgerReportGLAfterYEData},1)\n  lazy val dividendParam = OutPutParam(\"Dividend\",dividendColumnList,() => {this.dividendsIncomeExpenseReportDividendData},1)\n  lazy val dividendAfterYEParam = OutPutParam(\"Dividend (after YE)\",dividendColumnList,() => {this.dividendsIncomeExpenseReportDividendAfterYEData},1)\n  lazy val RGLParam = OutPutParam(\"RGL\",RGLColumnList,() => {this.realisedGainLossReportRGLData},1)\n  lazy val RGLAfterYEParam = OutPutParam(\"RGL (after YE)\",RGLColumnList,() => {this.realisedGainLossReportRGLAfterYEData},1)\n\n  lazy val outputParams = Seq(positionParam,cashParam,PSRParam,PSRAfterYEParam,TBParam,GLParam,GLAfterYEParam,dividendParam,dividendAfterYEParam,RGLParam,RGLAfterYEParam)\n\n} MorgenSingleEGAStorage class MorganSingleEGAStorage extends GeneralSingleEGAStorage with EGAColConstMorgenStanley{\n\n} ColConstBase trait EGAColConstBase {\n  def replaceColumn(orgSeq:Seq[ColumnWithType], columnName:String, newFormat:ColumnWithType)={\n    orgSeq.map{\n      col =>col.columnName match {\n        case x if x == columnName => newFormat\n        case _=>col\n      }\n    }\n  }\n  val positionColumnList = EGAColConstBase.positionColumnList\n\n  val cashColumnList =  EGAColConstBase.cashColumnList\n\n  val PSRColumnList = EGAColConstBase.PSRColumnList\n\n  val TBColumnList = EGAColConstBase.TBColumnList\n\n  val GLColumnList = EGAColConstBase.GLColumnList\n\n  val dividendColumnList = EGAColConstBase.dividendColumnList\n\n  val RGLColumnList = EGAColConstBase.RGLColumnList\n\n} MorganStanleyConst trait EGAColConstMorgenStanley extends EGAColConstBase {\n  override val positionColumnList = replaceColumn(EGAColConstBase.positionColumnList, \"Group1\", ColumnWithType(\"Group1\", ExcelColumnFormat.format_formula))\n\n  override val GLColumnList = replaceColumn(EGAColConstBase.GLColumnList, \"EndingBalanceAmount\", ColumnWithType(\"EndingBalanceAmount\", ExcelColumnFormat.format_formula))\n}","title":"Presentation-layer for Excel output"},{"location":"/presentationlayer/index.html#pitfall-for-refactor-code","text":"In GeneralSingleEGAStorage, for the ColumList depends on EGAColConstBase implementation.\nimport java.text.SimpleDateFormat\n\nimport scala.collection.Map\n\nclass GeneralSingleEGAStorage {\n  this: EGAColConstBase =>\n  var errorMsg: ErrorStatus = ErrorStatus(false,\"\")\n  var warningMsg: WarningStatus = WarningStatus(false,\"\")\n\n  var trialBalanceReportTBData: Seq[Map[String, String]] = Seq()\n\n  var detailedGeneralLedgerReportGLData: Seq[Map[String, String]] = Seq()\n  var detailedGeneralLedgerReportGLAfterYEData: Seq[Map[String, String]] = Seq()\n\n  var positionAppraisalReportPositionData: Seq[Map[String, String]] = Seq()\n\n  var cashAppraisalReportCashData: Seq[Map[String, String]] = Seq()\n\n  var purchaseAndSaleTransactionReportPSRData: Seq[Map[String, String]] = Seq()\n  var purchaseAndSaleTransactionReportPSRAfterYEData: Seq[Map[String, String]] = Seq()\n\n  var dividendsIncomeExpenseReportDividendData: Seq[Map[String, String]] = Seq()\n  var dividendsIncomeExpenseReportDividendAfterYEData: Seq[Map[String, String]] = Seq()\n\n  var realisedGainLossReportRGLData: Seq[Map[String, String]] = Seq()\n  var realisedGainLossReportRGLAfterYEData: Seq[Map[String, String]] = Seq()\n\n  val positionParam = OutPutParam(\"Position\",positionColumnList, () => {this.positionAppraisalReportPositionData},1)\n  val cashParam = OutPutParam(\"Cash\",cashColumnList,() => {this.cashAppraisalReportCashData},1)\n  val PSRParam = OutPutParam(\"PSR\",PSRColumnList,() => {this.purchaseAndSaleTransactionReportPSRData} ,1)\n  val PSRAfterYEParam = OutPutParam(\"PSR (after YE)\",PSRColumnList,() => {this.purchaseAndSaleTransactionReportPSRAfterYEData},1)\n  val TBParam = OutPutParam(\"TB\",TBColumnList, () => {this.trialBalanceReportTBData},3)\n  val GLParam = OutPutParam(\"GL\",GLColumnList,() => {this.detailedGeneralLedgerReportGLData},1)\n  val GLAfterYEParam = OutPutParam(\"GL (after YE)\",GLColumnList,() => {this.detailedGeneralLedgerReportGLAfterYEData},1)\n  val dividendParam = OutPutParam(\"Dividend\",dividendColumnList,() => {this.dividendsIncomeExpenseReportDividendData},1)\n  val dividendAfterYEParam = OutPutParam(\"Dividend (after YE)\",dividendColumnList,() => {this.dividendsIncomeExpenseReportDividendAfterYEData},1)\n  val RGLParam = OutPutParam(\"RGL\",RGLColumnList,() => {this.realisedGainLossReportRGLData},1)\n  val RGLAfterYEParam = OutPutParam(\"RGL (after YE)\",RGLColumnList,() => {this.realisedGainLossReportRGLAfterYEData},1)\n\n  val outputParams = Seq(positionParam,cashParam,PSRParam,PSRAfterYEParam,TBParam,GLParam,GLAfterYEParam,dividendParam,dividendAfterYEParam,RGLParam,RGLAfterYEParam)\n\n}\nif the **Param is not lazy val,the columnList field will be null, for the initialization order.\nFor MorganStanleyConst implementation, there is some overwrite for base const variables.So the base variables should from object variable.\ntrait EGAColConstMorgenStanley extends EGAColConstBase {\n  override val positionColumnList = replaceColumn(EGAColConstBase.positionColumnList, \"Group1\", ColumnWithType(\"Group1\", ExcelColumnFormat.format_formula))\n\n  override val GLColumnList = replaceColumn(EGAColConstBase.GLColumnList, \"EndingBalanceAmount\", ColumnWithType(\"EndingBalanceAmount\", ExcelColumnFormat.format_formula))\n}\nFor the lazy value will only set after evaluation: Before evaluation\nAfter evaluation","title":"Pitfall for refactor code"},{"location":"/coderefineusingfp/index.html","text":"","title":"Refine code with function programming"},{"location":"/coderefineusingfp/index.html#refine-code-with-function-programming","text":"","title":"Refine code with function programming"},{"location":"/coderefineusingfp/index.html#code-to-refine","text":"FundA object FundA {\n\n  val thisfund = fundA\n\n  def belongToThisFund(name:String) = {\n    belongToSomeSelectedFunds(name,thisfund)\n  }\n\n  def generate(cvg:ConfirmationValuationGSP,selections:Seq[FundEngagementReportTypeSelectionData]) = {\n    val afterGuess = cvg.copy(workCash = guessWorkCash(cvg.workCash,selections),workInv = guessWorkInv(cvg.workInv,selections))\n    afterGuess\n  }\n\n  def guessWorkCash(workCash:Seq[Map[String,String]],selections:Seq[FundEngagementReportTypeSelectionData]) = {\n    workCash.map(workCashRow=>{\n      var glAccountName = workCashRow.get(WorkCashColumns.GL_ACCOUNT_NAME).getOrElse(\"\")\n      if(belongToThisFund(glAccountName)){\n        val IandU = guessingWorkCashIAndU(workCashRow,selections)\n        workCashRow ++ Map(\n          WorkCashColumns.BANK_ACCOUNT_NUMBER -> IandU._1,\n          WorkCashColumns.AMOUNT_PER_CONFIRMATION -> IandU._2,\n          WorkCashColumns.QUESTIONARE_FILE -> IandU._3\n        )\n      }else{\n        workCashRow\n      }\n\n    })\n  }\n\n  def guessWorkInv(workInv:Seq[Map[String,String]],selections:Seq[FundEngagementReportTypeSelectionData]) = {\n    workInv.map(workInvRow=>{\n      val custodian = workInvRow.get(WorkInvColumns.CUSTODIAN).getOrElse(\"\")\n      if(belongToThisFund(custodian)){\n        val IandU = guessingWorkInvJandP(workInvRow,selections)\n        workInvRow ++ Map(\n          WorkInvColumns.INVESTMENT_VALUE_PER_CONFIRMATION -> IandU._1,\n          WorkInvColumns.QUANTITY_PER_CONFIRMATION -> IandU._2,\n          WorkInvColumns.QUESTIONARE_FILE -> IandU._3\n        )\n      }else{\n        workInvRow\n      }\n    })\n  }\n\n  def getFirstMappingInConfirmationReport(reportID:String,filterFunc:(JSONObject)=>Boolean,selections:Seq[FundEngagementReportTypeSelectionData]):Map[String,JSONObject] = {\n    val report = selections.filter(select=>{select.sheettypesReporttypesMapId == reportID && select.extractionFileContent.isDefined}).headOption\n    var result:Map[String,JSONObject] = Map()\n    if(report.isDefined && result.isEmpty){\n      val a = new JSONArray(report.get.extractionFileContent.get)\n      for(i1 <- a.length()-1 to 0 by -1){\n        val singleFileContent = a.get(i1).asInstanceOf[JSONObject]\n        val fileNames = singleFileContent.names()\n        for(i2 <- 0 until fileNames.length()){\n          val fileName = fileNames.get(i2).toString()\n          val fileContents = new JSONArray(singleFileContent.getString(fileName))\n          for(i3 <- 0 until fileContents.length){\n            val item = fileContents.get(i3).asInstanceOf[JSONObject]\n            if(filterFunc(item)){\n              result  = result + (fileName.split(\"\\\\|\")(0) -> item)\n            }\n          }\n        }\n      }\n    }\n    result\n  }\n\n  /**\n   *\n   * @param reportID\n   * @param filterFunc\n   * @param getFunc\n   * @return (column I, column U ,fileName)\n   */\n  def getWorkCashColumnsFromReport(reportID:String,filterFunc:(JSONObject)=>Boolean,getFunc:(JSONObject)=>(String,String),selections:Seq[FundEngagementReportTypeSelectionData]):Option[(String,String,String)] = {\n    val result = getFirstMappingInConfirmationReport(reportID,filterFunc,selections)\n    if(result.isEmpty){\n      None\n    }else{\n      var firstKey:Option[String] = None\n      var IandU = (\"\",\"\")\n      for(k <- result.keys){\n        if(firstKey.isEmpty){\n          firstKey = Some(k)\n          IandU = getFunc(result.get(k).get)\n        }\n      }\n      Some(IandU._1,IandU._2,firstKey.get)\n    }\n  }\n\n\n  /**\n   *\n   * @param reportID\n   * @param filterFunc\n   * @param getFunc\n   * @return (column J, column P,fileName)\n   */\n  def getWorkInvColumnsFromReport(reportID:String,filterFunc:(JSONObject)=>Boolean,getFunc:(JSONObject)=>(String,String),selections:Seq[FundEngagementReportTypeSelectionData]):Option[(String,String,String)] = {\n    val result = getFirstMappingInConfirmationReport(reportID,filterFunc,selections)\n    if(result.isEmpty){\n      None\n    }else{\n      var firstKey:Option[String] = None\n      var JandP = (\"\",\"\")\n      for(k <- result.keys){\n        if(firstKey.isEmpty){\n          firstKey = Some(k)\n          JandP = getFunc(result.get(k).get)\n        }\n      }\n      Some(JandP._1,JandP._2,firstKey.get)\n    }\n  }\n\n\n\n  /**\n   *\n   * @param workCashRow\n   * @param selections\n   * @return (ColumnI,ColumnU,fileName)\n   */\n  def guessingWorkCashIAndU(workCashRow:Map[String, String],selections:Seq[FundEngagementReportTypeSelectionData]) = {\n\n    val workCashInfos = generateWorkCashInfos(workCashRow)\n    var columns:Option[(String,String,String)] =  None\n\n    var glAccountName = workCashRow.get(WorkCashColumns.GL_ACCOUNT_NAME).getOrElse(\"\")\n    workCashInfos.foreach(workCashInfo => {\n      if(columns.isEmpty){\n        columns = getWorkCashColumnsFromReport(workCashInfo.reportId,workCashInfo.filterFunc,workCashInfo.getFunc,selections)\n      }\n    })\n\n\n    columns match {\n      case Some(value) => value\n      case None => (missingStr(glAccountName),missingStr(glAccountName),EMPTY_STR)\n    }\n  }\n\n  def guessingWorkInvJandP(workInvRow:Map[String, String],selections:Seq[FundEngagementReportTypeSelectionData]) = {\n\n    val workInvInfos = generateWorkInvInfos(workInvRow)\n\n\n    /**\n     * Lack of item17\n     */\n    var columns:Option[(String,String,String)] =  None\n\n    val custodian = workInvRow.get(WorkInvColumns.CUSTODIAN).getOrElse(\"\")\n    workInvInfos.foreach(workInvInfo => {\n      if(columns.isEmpty){\n        columns = getWorkInvColumnsFromReport(workInvInfo.reportId,workInvInfo.filterFunc,workInvInfo.getFunc,selections)\n      }\n    })\n\n\n    columns match {\n      case Some(value) => value\n      case None => (missingStr(custodian),missingStr(custodian),EMPTY_STR)\n    }\n  }\n\n  def generateWorkCashInfos(workCashRow:Map[String, String]) = {\n    val egaQuantity = workCashRow.get(WorkCashColumns.ACCOUNT_BALANCE_IN_SOURCE_CURRENCY).getOrElse(\"\")\n    val currency = workCashRow.getOrElse(WorkCashColumns.BANK_ACCOUNT_CURRENCY, \"\")\n\n    val item235Id = \"3003\"\n    val item235Func = (ob:JSONObject)=>{\n      ob.getString(\"Currency\").trim == currency.trim && convertStringToNumbersAndEqual(ob.getString(\"Balance\"),egaQuantity)\n    }\n    val item235GetFunc = (ob:JSONObject)=>{\n      (ob.getString(\"Account No.\") , ob.getString(\"Balance\"))\n    }\n\n    /**\n     * issues for 3001: content not right.\n     */\n    val collateralPositionByAgreementId = \"3001\"\n    val collateralPositionByAgreementFunc = (ob:JSONObject)=>{\n      ob.getString(\"Instrument Ccy\").trim == currency.trim && convertStringToNumbersAndEqual(ob.getString(\"Notional\"),egaQuantity)\n    }\n    val collateralPositionByAgreementGetFunc = (ob:JSONObject)=>{\n      (NA_STR  , ob.getString(\"Notional\"))\n    }\n\n    val ibanId = \"3009\"\n    val ibanFunc = (ob:JSONObject)=>{\n      ob.getString(\"ccy\").trim == currency.trim && convertStringToNumbersAndEqual(ob.getString(\"balance\"),egaQuantity)\n    }\n    val ibanGetFunc = (ob:JSONObject)=>{\n      (ob.getString(\"iban\") , ob.getString(\"balance\"))\n    }\n\n    /**\n     * Lack of item17\n     */\n\n    val workCashInfos = Seq(\n      WorkCashInfo(item235Id,item235Func,item235GetFunc),\n      //WorkCashInfo(collateralPositionByAgreementId,collateralPositionByAgreementFunc,collateralPositionByAgreementGetFunc),\n      WorkCashInfo(ibanId,ibanFunc,ibanGetFunc)\n    )\n    workCashInfos\n  }\n\n  def generateWorkInvInfos(workInvRow:Map[String, String]) = {\n    val description = workInvRow.get(WorkInvColumns.DESCRIPTION).getOrElse(\"\")\n    val currency = workInvRow.get(WorkInvColumns.ORI_CCY_RATE).getOrElse(\"\")\n    val fairValue = workInvRow.get(WorkInvColumns.FAIR_VALUE_PER_POSITION_REPORT).getOrElse(\"\")\n    val quantity = workInvRow.get(WorkInvColumns.QUANTITY).getOrElse(\"\")\n\n    /**\n     * Issues for 3000: What is Quantity SD? and items are not qualified.\n     */\n    val creditDefaultSwapId = \"3000\"\n    val creditDefaultSwapFilterFunc = (ob:JSONObject)=>{\n      ob.getString(\"Product Description\").trim == description.trim && convertStringToNumbersAndEqual(ob.getString(\"Currency\"),currency) && convertStringToNumbersAndEqual(ob.getString(\"NOTIONAL\"),fairValue)\n    }\n    val creditDefaultSwapGetFunc = (ob:JSONObject)=>{\n      (NA_STR , ob.getString(\"NOTIONAL\"))\n    }\n\n    /**\n     * Issue for 3002: desciption should be ~=.\n     */\n    val otcExposureId = \"3002\"\n    val otcExposureFilterFunc = (ob:JSONObject)=>{\n      (ob.getString(\"Source Reference\").trim == description.trim || ob.getString(\"Underlying Name\").trim == description.trim) && ob.getString(\"Agreement Ccy\").trim == currency.trim && convertStringToNumbersAndEqual(ob.getString(\"Exposure (Agree Ccy)\"),fairValue)\n    }\n    val otcExposureGetFunc = (ob:JSONObject)=>{\n      (ob.getString(\"Exposure (Agree Ccy)\") , NA_STR)\n    }\n\n\n    /**\n     * Issue for 3004: No 3004 example.\n     */\n    val item4Id = \"3004\"\n    val item4FilterFunc = (ob:JSONObject)=>{\n      ob.getString(\"facility\").trim == description.trim && ob.getString(\"CCY\") == currency && convertStringToNumbersAndEqual(ob.getString(\"Amount\"),quantity)\n    }\n    val item4GetFunc = (ob:JSONObject)=>{\n      (NA_STR, NA_STR)\n    }\n\n    /**\n     * 3005 seems good.\n     */\n    val moneyMarketId = \"3005\"\n    val moneyMarketFilterFunc = (ob:JSONObject)=>{\n      ob.getString(\"CCY\").trim == currency.trim && convertStringToNumbersAndEqual(ob.getString(\"Amount\"),quantity)\n    }\n    val moneyMarketGetFunc = (ob:JSONObject)=>{\n      (ob.getString(\"Amount\") , ob.getString(\"Amount\"))\n    }\n\n    /**\n     * Issues for 3006: Seems content is not consistent with doc.\n     */\n    val foreignExchangeId = \"3006\"\n    val foreignExchangeFilterFunc = (ob:JSONObject)=>{\n      ob.getString(\"CCY\").trim == currency.trim && convertStringToNumbersAndEqual(ob.getString(\"Amount\"),quantity)\n    }\n    val foreignExchangeGetFunc = (ob:JSONObject)=>{\n      (NA_STR, ob.getString(\"Amount\"))\n    }\n\n    /**\n     * Issues for 3007: TODO.\n     */\n    val item17Id = \"3007\"\n    val item17FilterFunc = (ob:JSONObject)=>{\n      ob.getString(\"CCY\").trim == currency.trim && ob.getString(\"Amount\") == quantity\n    }\n    val item17GetFunc = (ob:JSONObject)=>{\n      (NA_STR, ob.getString(\"Amount\"))\n    }\n\n    val workInvInfos = Seq(\n      WorkInvInfo(creditDefaultSwapId,creditDefaultSwapFilterFunc,creditDefaultSwapGetFunc),\n      WorkInvInfo(otcExposureId,otcExposureFilterFunc,otcExposureGetFunc) ,\n      WorkInvInfo(item4Id,item4FilterFunc,item4GetFunc),\n      WorkInvInfo(foreignExchangeId,foreignExchangeFilterFunc,foreignExchangeGetFunc),\n      WorkInvInfo(moneyMarketId,moneyMarketFilterFunc,moneyMarketGetFunc),\n      WorkInvInfo(item17Id,item17FilterFunc,item17GetFunc),\n    )\n    workInvInfos\n  }\n\n  case class WorkInvInfo(reportId:String, filterFunc:(JSONObject)=>Boolean, getFunc:(JSONObject)=>(String,String))\n  case class WorkCashInfo(reportId:String, filterFunc:(JSONObject)=>Boolean, getFunc:(JSONObject)=>(String,String))\n} FundB object FundB {\n\n  val isFund = (name:String)=>{\n    belongToSomeSelectedFunds(name,fundName)\n  }\n\n  def generate(cvg:ConfirmationValuationGSP,selections:Seq[FundEngagementReportTypeSelectionData]) = {\n    val afterGuess = cvg.copy(workCash = guessWorkCash(cvg.workCash,selections))\n    afterGuess\n  }\n\n  def guessWorkCash(workCash:Seq[Map[String,String]],selections:Seq[FundEngagementReportTypeSelectionData]) = {\n    workCash.map(workCashRow=>{\n      var glAccountName = workCashRow.get(WorkCashColumns.GL_ACCOUNT_NAME).getOrElse(\"\")\n      if(isFund(glAccountName)){\n        val IandU = guessingWorkCashIAndU(workCashRow,selections)\n        workCashRow ++ Map(\n          WorkCashColumns.BANK_ACCOUNT_NUMBER -> IandU._1,\n          WorkCashColumns.AMOUNT_PER_CONFIRMATION -> IandU._2,\n          WorkCashColumns.QUESTIONARE_FILE -> IandU._3\n        )\n      }else{\n        workCashRow\n      }\n    })\n  }\n\n  /**\n   *\n   * @param workCashRow\n   * @param selections\n   * @return (ColumnI,ColumnU,fileName)\n   */\n  def guessingWorkCashIAndU(workCashRow:Map[String, String],selections:Seq[FundEngagementReportTypeSelectionData]) = {\n\n    val workCashInfos = generateWorkCashInfos(workCashRow)\n    var columns:Option[(String,String,String)] =  None\n\n    var glAccountName = workCashRow.get(WorkCashColumns.GL_ACCOUNT_NAME).getOrElse(\"\")\n    if (isFund(glAccountName)) {\n      workCashInfos.foreach(workCashInfo => {\n        if(columns.isEmpty){\n          columns = getWorkCashColumnsFromReport(workCashInfo.reportId,workCashInfo.filterFunc,workCashInfo.getFunc,selections)\n        }\n      })\n    }\n\n    columns match {\n      case Some(value) => value\n      case None => (missingStr(glAccountName),missingStr(glAccountName),EMPTY_STR)\n    }\n  }\n\n  def generateWorkCashInfos(workCashRow:Map[String, String]) = {\n    val currency = workCashRow.getOrElse(WorkCashColumns.BANK_ACCOUNT_CURRENCY, \"\")\n\n    val reportId = \"5001\"\n    val filterFunc = (ob: JSONObject) => ob.getString(\"CURRENCY\").trim == currency.trim\n    val getFunc = (ob: JSONObject) => (ob.getString(\"ACCOUNT NUMBER\") , ob.getString(\"BALANCE\"))\n\n    Seq(WorkCashInfo(reportId, filterFunc, getFunc))\n  }\n\n  def getWorkCashColumnsFromReport(reportID:String, filterFunc: JSONObject =>Boolean, getFunc: JSONObject =>(String,String), selections:Seq[FundEngagementReportTypeSelectionData]):Option[(String,String,String)] = {\n    val report = selections.find(select => {\n      select.sheettypesReporttypesMapId == reportID && select.extractionFileContent.isDefined\n    })\n    var result:Option[(String,String,String)] = None\n    if(report.isDefined && result.isEmpty){\n      val a = new JSONArray(report.get.extractionFileContent.get)\n      for(i1 <- 0 until a.length()){\n        var balance = \"\"\n        var accNum = \"\"\n        var keep = false\n        val singleFileContent = a.get(i1).asInstanceOf[JSONObject]\n        val fileNames = singleFileContent.names()\n        for(i2 <- 0 until fileNames.length()){\n          val fileName = fileNames.get(i2).toString\n          val fileContents = singleFileContent.getJSONArray(fileName)\n          for(i3 <- 0 until fileContents.length){\n            val item = fileContents.getJSONObject(i3)\n            item.names().get(0) match {\n              case \"ACCOUNT NUMBER\" =>\n                accNum = item.getString(\"ACCOUNT NUMBER\")\n              case \"BALANCE\" =>\n                balance = item.getString(\"BALANCE\")\n              case \"CURRENCY\" =>\n                if(filterFunc(item)){\n                  keep = true\n                }\n              case _ =>\n            }\n          }\n          if(keep)\n            return Some(accNum, balance, fileName.split(\"\\\\|\")(0))\n        }\n      }\n    }\n    result\n  }\n\n  case class WorkCashInfo(reportId:String, filterFunc: JSONObject =>Boolean, getFunc: JSONObject =>(String,String))\n}","title":"Code to refine"},{"location":"/coderefineusingfp/index.html#refined","text":"Generic Method object GenericConfirmationFinder {\n  def getConfirmationRecord(reportId: String,\n                            filterFunc: (ConfirmationRecord) => Boolean,\n                            selections: Seq[FundEngagementReportTypeSelectionData]): Option[ConfirmationRecordWithFile] = {\n    val reportOpt = selections.filter(select => select.sheettypesReporttypesMapId == reportId && select.extractionFileContent.isDefined).headOption\n    val allRecords = reportOpt.flatMap {\n      report =>\n        report.extractionFileContent.map {\n          extractStr =>\n            ConfirmationStorageHelper.stringToStorage(extractStr).files.flatMap {\n              file => file.records.map(record => ConfirmationRecordWithFile(record, file.fileName))\n            }\n        }\n    }.getOrElse(Seq())\n    allRecords.filter(record => filterFunc(record.record)).headOption\n  }\n\n  def queryInfo(reportId: String, filterFunc: (ConfirmationRecord) => Boolean, getFunc: ConfirmationRecordWithFile => Map[String, String], selections: Seq[FundEngagementReportTypeSelectionData]): Map[String, String] = {\n    getConfirmationRecord(reportId, filterFunc, selections).map {\n      record => getFunc(record)\n    }.getOrElse(Map())\n  }\n\n  def getWorkCash(workCash: Seq[Map[String, String]], selections: Seq[FundEngagementReportTypeSelectionData], fundFinderConfig: FundFinderConfig) = {\n    workCash.map {\n      workCashRow =>\n        val glAccountName = workCashRow.get(WorkCashColumns.GL_ACCOUNT_NAME).getOrElse(\"\")\n        if (fundFinderConfig.belongsToFund(glAccountName)) {\n          var queriedResult: Map[String, String] = Map()\n          fundFinderConfig.workCashConfs.map {\n            findConfig => queriedResult = queriedResult ++ queryInfo(findConfig.reportId, findConfig.filterFunc(workCashRow), findConfig.getFunc, selections)\n          }\n          workCashRow ++ queriedResult\n        } else {\n          workCashRow\n        }\n    }\n  }\n\n  def getWorkInv(workInv: Seq[Map[String, String]], selections: Seq[FundEngagementReportTypeSelectionData], fundFinderConfig: FundFinderConfig) = {\n    workInv.map {\n      workInvRow =>\n        val glAccountName = workInvRow.get(WorkInvColumns.CUSTODIAN).getOrElse(\"\")\n        if (fundFinderConfig.belongsToFund(glAccountName)) {\n          var queriedResult: Map[String, String] = Map()\n          fundFinderConfig.workInvConfs.map {\n            findConfig => queriedResult = queriedResult ++ queryInfo(findConfig.reportId, findConfig.filterFunc(workInvRow), findConfig.getFunc, selections)\n          }\n          workInvRow ++ queriedResult\n        } else {\n          workInvRow\n        }\n    }\n  }\n\n}\n\ncase class FinderConfig(reportId: String, filterFunc: Map[String, String] => ConfirmationRecord => Boolean, getFunc: ConfirmationRecordWithFile => Map[String, String])\n\ncase class FundFinderConfig(belongsToFund: (String) => Boolean, workCashConfs: Seq[FinderConfig], workInvConfs: Seq[FinderConfig]) FundC： object FundC {\n  val thisfund =\"\"\n\n  def belongsToFund(name: String) = {\n    belongToSomeSelectedFunds(name, thisfund)\n  }\n\n  def cashFilter(accounts: Seq[AccountRecord])(row: Map[String, String])(record: ConfirmationRecord) = {\n    val accountNumber = accounts.filter(acc => acc.account == row.get(WorkCashColumns.GL_ACCOUNT_NUMBER)).headOption.map(_.accountNumber).getOrElse(\"\")\n    row.getOrElse(WorkCashColumns.BANK_ACCOUNT_CURRENCY, \"\") == record.currency &&\n      accountNumber == record.accountNumber\n  }\n\n  def cashGet(record: ConfirmationRecordWithFile): Map[String, String] = {\n    Map(WorkCashColumns.BANK_ACCOUNT_NUMBER -> record.record.accountNumber.getOrElse(\"\"),\n      WorkCashColumns.AMOUNT_PER_CONFIRMATION -> record.record.balance.getOrElse(\"\"),\n      WorkCashColumns.QUESTIONARE_FILE -> record.fileName)\n  }\n\n  def invFilter(accounts: Seq[AccountRecord])(row: Map[String, String])(record: ConfirmationRecord) = {\n    val accountNumber = accounts.filter(acc => acc.account == row.get(WorkInvColumns.CUSTODIAN)).headOption.map(_.accountNumber).getOrElse(\"\")\n    accountNumber == record.accountNumber &&\n      row.getOrElse(WorkInvColumns.INVEST_ID, \"\") == record.descriptionOrISIN &&\n      row.getOrElse(WorkInvColumns.ORI_CCY_RATE, \"\") == record.currency\n  }\n\n  def invGet(record: ConfirmationRecordWithFile): Map[String, String] = {\n    Map(WorkInvColumns.QUESTIONARE_FILE -> record.fileName,\n      WorkInvColumns.QUANTITY_PER_CONFIRMATION -> record.record.quantity.getOrElse(\"\"),\n      WorkInvColumns.INVESTMENT_VALUE_PER_CONFIRMATION -> record.record.balance.getOrElse(\"\"))\n  }\n\n\n  def generate(cvg: ConfirmationValuationGSP, selections: Seq[FundEngagementReportTypeSelectionData], accountNameNumberMappingParam: Seq[AccountRecord]) = {\n    val cashConfig1 = FinderConfig(\"111\", cashFilter(accountNameNumberMappingParam), cashGet)\n    val invConfig1 = FinderConfig(\"222\", invFilter(accountNameNumberMappingParam), invGet)\n    val bnyFinderConf = FundFinderConfig(belongsToFund, Seq(cashConfig1), Seq(invConfig1))\n\n\n    cvg.copy(workCash = GenericConfirmationFinder.getWorkCash(cvg.workCash, selections, bnyFinderConf),\n      workInv = GenericConfirmationFinder.getWorkInv(cvg.workInv, selections, bnyFinderConf))\n  }\n}","title":"Refined"},{"location":"/traps/index.html","text":"","title":"Traps in Scala"},{"location":"/traps/index.html#traps-in-scala","text":"","title":"Traps in Scala"},{"location":"/traps/index.html#operator-will-bypass-type-checking","text":"Filter code def invFilter(securityItems: Seq[SecurityItem])(accounts: Seq[AccountRecord])(row: Map[String, String])(record: ConfirmationRecord) = {\n  val accountNumber = accounts.filter(acc => acc.account == row.get(WorkInvColumns.CUSTODIAN)).headOption.map(_.accountNumber).getOrElse(\"\")\n  val isinStr = securityItems.filter(item => item.cname == row.getOrElse(WorkInvColumns.DESCRIPTION, \"\"))\n    .headOption.map(_.cname).getOrElse(\"\").trim\n  accountNumber == record.accountNumber &&\n    isinStr == record.descriptionOrISIN &&\n    row.getOrElse(WorkInvColumns.ORI_CCY_RATE, \"\") == record.currency\n}\n\n\n\n Storage definition case class ConfirmationRecord(accountNumber:Option[String]=None,\n                              balance:Option[String]=None,\n                              currency:Option[String]=None,\n                              quantity:Option[String]=None,\n                              descriptionOrISIN:Option[String]=None,\n                              etc:Option[String]=None)\ncase class ConfirmationRecordWithFile(record:ConfirmationRecord, fileName:String)\ncase class ConfirmationFile(fileName:String,records:Seq[ConfirmationRecord],date:Option[String])\ncase class ConfirmationStorage(files:Seq[ConfirmationFile])\nHow to fix:\nUsing function to check class type\nFix type check def invFilter(securityItems:Seq[SecurityItem])(accounts: Seq[AccountRecord])(row: Map[String, String])(record: ConfirmationRecord) = {\n  val accountNumber = accounts.filter(acc => acc.account == row.get(WorkInvColumns.CUSTODIAN).getOrElse(\"\")).headOption.map(_.accountNumber).getOrElse(\"\")\n  val isinStr= securityItems.filter(item=> item.cname == row.getOrElse(WorkInvColumns.DESCRIPTION, \"\"))\n    .headOption.map(_.isin).getOrElse(\"\").trim\n  equalString(accountNumber,record.accountNumber.getOrElse(\"\")) &&\n    equalString(isinStr,record.descriptionOrISIN.getOrElse(\"\")) &&\n    equalString(row.getOrElse(WorkInvColumns.ORI_CCY_RATE, \"\"), record.currency.getOrElse(\"\"))\n}\n\ndef equalString(a:String,b:String):Boolean={\n  a.trim==b.trim && a.length>0\n}","title":"Operator will bypass type checking"},{"location":"/alloctMemFail/index.html","text":"","title":"JVM allocate memory failed in docker"},{"location":"/alloctMemFail/index.html#jvm-allocate-memory-failed-in-docker","text":"","title":"JVM allocate memory failed in docker"},{"location":"/alloctMemFail/index.html#jvm-allocate-failed","text":"In Azure, when set Docker container memory more than 8G, JVM will throw exception as blow:\nAllocate memory failed [info] d.c.d.DriverActor - {Some(JobMeta(53fb3460-734d-11eb-91da-b59ce673c8d4))} is handled by proxy Actor[akka://clustering-cluster/user/driverService/singleton/SimpleProcess53fb3461-734d-11eb-91da-b59ce673c8d4#-734442381]\n[info] d.c.f.FsmActor - {Some(JobMeta(53fb3460-734d-11eb-91da-b59ce673c8d4))} is started in fsm worker, and will be handled by {Actor[akka://clustering-cluster/user/processTranServiceProxy613f1e40-734b-11eb-91da-b59ce673c8d4#-1398123469]}\n[error] d.u.ProcessService$ - null\nSome(JobMeta(53fb3460-734d-11eb-91da-b59ce673c8d4))\nSome(JobMeta(53fb3460-734d-11eb-91da-b59ce673c8d4))\n[info] d.c.f.FsmActor - Some(JobMeta(53fb3460-734d-11eb-91da-b59ce673c8d4)) is end\ncom.pwc.ds.awm.processor.morgan.MorganPositionProcessor\n[info] d.c.d.DriverActor - {Some(JobMeta(547ac4a0-734d-11eb-91da-b59ce673c8d4))} is handled by proxy Actor[akka://clustering-cluster/user/driverService/singleton/SimpleProcess547ac4a1-734d-11eb-91da-b59ce673c8d4#1147276305]\n[info] d.c.f.FsmActor - {Some(JobMeta(547ac4a0-734d-11eb-91da-b59ce673c8d4))} is started in fsm worker, and will be handled by {Actor[akka://clustering-cluster/user/processTranServiceProxy613f1e40-734b-11eb-91da-b59ce673c8d4#-1398123469]}\n[GC (Allocation Failure) 2996861K->175463K(12114944K), 0.1547646 secs]\n[GC (System.gc()) 261852K->180401K(12120064K), 0.0624754 secs]\n[Full GC (System.gc()) 180401K->152776K(12120064K), 0.7623755 secs]\nOpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00007f8f015e0000, 12288, 0) failed; error='Cannot allocate memory' (errno=12)\n#\n# There is insufficient memory for the Java Runtime Environment to continue.\n# Native memory allocation (mmap) failed to map 12288 bytes for committing reserved memory.\n# An error report file with more information is saved as:\n# /app/ds-awm-1.0-SNAPSHOT/hs_err_pid7.log\n\n[info] application - GET /api/fund?fundId=0798f8b9-ae7c-4af4-83f7-b0475ab757c0 took 26ms by elaine.yx.wei@cn.pwc.com and returned 200\n[debug] s.j.J.statement - Preparing statement: select `id`, `userid`, `username`, `engagementid`, `role`, `active`, `deleted`, `createdatetime`, `lastactivetime`, `disabledtime`, `meta` from `engageusers` where (`userid` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `email`, `role`, `deleted`, `firstname`, `lastname`, `createby`, `createdatetime`, `modifyby`, `modifydatetime`, `lastactivetime`, `acknowledge`, `disabledtime` from `users` where (`email` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `name`, `privilege`, `description` from `roles` where `name` = 'Admin'\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementcode`, `name`, `periodstart`, `periodend`, `auralink`, `active`, `deleted`, `createdatetime`, `meta` from `engagements` where (`id` = ?) and (`deleted` = 'false')\n[debug] s.j.J.statement - Preparing statement: select `id`, `fund_engagement_id`, `generate_status`, `generatedatetime`, `generate_file_content`, `createby`, `createdatetime`, `modifyby`, `modifydatetime`, `accunts`, `securityitems`, `etc` from `ega` where `fund_engagement_id` = ?\n[debug] s.j.J.statement - Preparing statement: select `id`, `engagementid`, `fundid`, `auralink`, `createby`, `createdatetime`, `modifyby`, `modifydatetime`, `fundrecord` from `fund_engagement` where `id` = ?\ncom.pwc.ds.awm.processor.pdfReport.MorganPDFReport.CashExposureReportProcessor\n[info] d.c.d.DriverActor - {Some(JobMeta(dbe0fe00-7352-11eb-ad2c-67a391f5eacf))} is handled by proxy Actor[akka://clustering-cluster/user/driverService/singleton/SimpleProcessdbe0fe01-7352-11eb-ad2c-67a391f5eacf#-341968932]\n[info] d.c.f.FsmActor - {Some(JobMeta(dbe0fe00-7352-11eb-ad2c-67a391f5eacf))} is started in fsm worker, and will be handled by {Actor[akka://clustering-cluster/user/processTranServiceProxy601adad0-7351-11eb-ad2c-67a391f5eacf#727263119]}\n[error] d.u.ProcessService$ - null\nSome(JobMeta(dbe0fe00-7352-11eb-ad2c-67a391f5eacf))\nSome(JobMeta(dbe0fe00-7352-11eb-ad2c-67a391f5eacf))\n[info] d.c.f.FsmActor - Some(JobMeta(dbe0fe00-7352-11eb-ad2c-67a391f5eacf)) is end\ncom.pwc.ds.awm.processor.morgan.MorganPositionProcessor\n[info] d.c.d.DriverActor - {Some(JobMeta(dc305680-7352-11eb-ad2c-67a391f5eacf))} is handled by proxy Actor[akka://clustering-cluster/user/driverService/singleton/SimpleProcessdc305681-7352-11eb-ad2c-67a391f5eacf#134702494]\n[info] d.c.f.FsmActor - {Some(JobMeta(dc305680-7352-11eb-ad2c-67a391f5eacf))} is started in fsm worker, and will be handled by {Actor[akka://clustering-cluster/user/processTranServiceProxy601adad0-7351-11eb-ad2c-67a391f5eacf#727263119]}\n[GC (Allocation Failure) 1868409K->110147K(12231168K), 0.0416277 secs]\n[GC (System.gc()) OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x000000069cb00000, 61865984, 0) failed; error='Cannot allocate memory' (errno=12)\n#\n# There is insufficient memory for the Java Runtime Environment to continue.\n# Native memory allocation (mmap) failed to map 61865984 bytes for committing reserved memory.\n# An error report file with more information is saved as:\n# /app/ds-awm-1.0-SNAPSHOT/hs_err_pid7.log","title":"JVM allocate failed"},{"location":"/alloctMemFail/index.html#vm-setting","text":"The crash happened in some docker container hosted in specified host.\nroot cause:\n1 crashed host setting:\n2 Not crashed host setting:\nAnswer from link","title":"VM setting"},{"location":"/extractorDesign/index.html","text":"","title":"How to structure a extractor process."},{"location":"/extractorDesign/index.html#how-to-structure-a-extractor-process-","text":"","title":"How to structure a extractor process."},{"location":"/extractorDesign/index.html#using-oo-design","text":"Caller method import java.io.File\n\nval genevaExtractorMap = Map[Seq[String], (AbstractProcessor, ExtractorConfig)](\n  Seq(\"Trial Balance\") -> (new TrialBalanceExcelReportProcessor, TrialBalanceReportConfig.extractorConfig),\n  Seq(\"Detailed General Ledger\") -> (new DetailedGeneralLedgerExcelReportProcessor, DetailedGeneralLedgerReportConfig.extractorConfig),\n  Seq(\"Position Appraisal Report\") -> (new PositionAppraisalReportProcessor, PositionAppraisalReportConfig.extractorConfig),\n  Seq(\"Cash Appraisal Report\") -> (new CashAppraisalReportProcessor, CashAppraisalReportConfig.extractorConfig),\n  Seq(\"Purchase and Sale Transaction Report\") -> (new PurchaseAndSaleTransactionReportProcessor, PurchaseAndSaleTransactionReportConfig.extractorConfig),\n  Seq(\"Dividends Detail Report\") -> (new DividendsDetailReportProcessor, DividendsDetailReportConfig.extractorConfig),\n  Seq(\"Realized Gain Loss Report\") -> (new RealisedGainLossReportProcessor, RealisedGainLossReportConfig.extractorConfig),\n  Seq(\"Realized Gain/Loss Report\") -> (new RealisedGainLossReportProcessor, RealisedGainLossReportConfig.extractorConfig)\n)\n\n\ndef processGenevaFiles(request: Request[MultipartFormData[Files.TemporaryFile]], fundEngagement: FundEngagementData, fund: Fund): Result = {\n  request.body.file(\"file\").map(file => {\n    ...\n    if (filenames.length <= 1) {\n      encapErrorResponse(\n        play.api.mvc.Results.UnprocessableEntity,\n        ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION\n      )\n    } else {\n      ....\n      if (filenames.last == \"xls\") {\n        methodName = \"readFileAndExtractToObjectForPeriod\"\n      } else {\n        methodName = \"readCSVFileAndExtractToObject\"\n      }\n      extractGenevaFileAndStoreDataInDB(content, fundEngagement, fund, targetFile.getPath, userEmail, methodName)\n    }\n  })\n    ...\n}\n\ndef extractGenevaFileAndStoreDataInDB(content: String, fundEngagement: FundEngagementData, fund: Fund, targetFilePath: String, userEmail: String, methodName: String): Result = {\n  //filter the extractorMap with report header\n  val someExtractor = genevaExtractorMap.find((kv) => {\n    kv._1.map(k => content.contains(k)).reduce(_ && _)\n  })\n  someExtractor.map((kv) => {\n    val periodStart = fund.auditPeriodBegin\n    val periodEnd = fund.auditPeriodEnd\n    val paras = List(targetFilePath, kv._2._2, fund.name, periodStart, periodEnd)\n    val result = doraServer.runProcess(paras, kv._2._1.getClass.getCanonicalName.stripSuffix(\"$\"), methodName)\n    val newStorage = Await.result(result, ConstVar.ProcessJobWaitTime seconds)\n      ....\n  })\n}\nProcess design using OO\nPositionAppraisalReportProcessor package com.pwc.ds.awm.processor.excelReport\n\nimport java.io.FileOutputStream\nimport java.sql.Date\nimport java.text.SimpleDateFormat\nimport java.time.LocalDate\nimport java.util.TimeZone\n\nimport com.pwc.ds.awm.component.safelogger.SafeLogger\nimport com.pwc.ds.awm.const.ExtractionErrorCode\nimport com.pwc.ds.awm.processor.date2UTCLocalDate\nimport com.pwc.ds.awm.processor.exceptions.{ExtractionError, ExtractionException}\nimport com.pwc.ds.awm.processor.generateEGA.basicReport.GenevaSingleEGAStorage\nimport com.pwc.ds.awm.processor.reportconfigs.extractorschema.{BlockConfig, ColumnConfig, ExtractorConfig, TableConfig}\nimport com.pwc.ds.awm.processor.singleegarow.PositionRow\nimport org.apache.poi.ss.usermodel.CellStyle\nimport org.apache.poi.xssf.usermodel.XSSFSheet\nimport play.api.Logger\n\nimport scala.collection.Map\nimport scala.util.control.Breaks.{break, breakable}\n\nclass PositionAppraisalReportProcessor extends BaseExcelReportProcessor {\n\n  override  def outputTableBodyRowIntoObjectForPeriod(tableHeaderColumns: Seq[Seq[ColumnConfig]], bodyBlocks: Seq[BlockConfig], lineBreaker: String, frontEndPeriodStart: Date, frontEndPeriodEnd: Date, fileStartDate: LocalDate, fileEndDate: LocalDate, isCSV: Boolean): Any = {\n    var newStorage = new GenevaSingleEGAStorage()\n\n    var regex = \"\\\\|\"\n    if(isCSV) {\n      regex = \",(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\"\n    }\n\n    if(fileEndDate.isBefore(date2UTCLocalDate(frontEndPeriodStart))){\n      throw ExtractionException(\"Report date found to be outside the audit period!\")\n    } else if (!date2UTCLocalDate(frontEndPeriodStart).isAfter(fileEndDate) && !fileEndDate.isAfter(date2UTCLocalDate(frontEndPeriodEnd))){\n      var positionRows: Seq[Map[String, String]] = Seq()\n\n      for (block <- bodyBlocks) {\n        var positionRow: Map[String, String] = Map()\n\n        var blocklines = block.content.split(regex, -1);\n        var headerLine = tableHeaderColumns(0);\n        positionRow = fillPositionRow(blocklines, headerLine)\n\n        if (positionRow != null && !positionRow.isEmpty)\n          positionRows = positionRows :+ positionRow\n      }\n      newStorage.positionAppraisalReportPositionData = positionRows\n    }else if (fileEndDate.isAfter(date2UTCLocalDate(frontEndPeriodEnd))) {\n      throw ExtractionError(ExtractionErrorCode.AUDIT_PERIOD_MISMATCH)\n    }\n    newStorage\n  }\n\n  def fillPositionRow(bodyLineList: Seq[String], headerLine: Seq[ColumnConfig]): Map[String, String] = {\n    var positionRow = PositionRow.createPositionRowMap()\n    for (headerColumnNum <- 0 until headerLine.length) {\n      var cellValue = bodyLineList(headerColumnNum)\n      if(cellValue.startsWith(\"\\\"\")) {\n        cellValue = cellValue.replace(\"\\\"\", \"\")\n      }\n      headerLine(headerColumnNum).title match {\n        case \"Portfolio\" => {positionRow.put(PositionRow.Group1, cellValue); positionRow.put(PositionRow.Portfolio, cellValue)}\n        case \"Investment Type\"=>positionRow.put(PositionRow.Group2, cellValue)\n        case \"Security ID\" => positionRow.put(PositionRow.InvestID, cellValue)\n        case \"Investment\" => positionRow.put(PositionRow.Description, cellValue)\n        case \"Quantity\" => positionRow.put(PositionRow.Quantity, cellValue)\n        case \"Local Market Price\" => positionRow.put(PositionRow.MarketPrice, cellValue)\n        case \"Current Book Cost\" => positionRow.put(PositionRow.CostBook, cellValue)\n        case \"Local Market Value\" => positionRow.put(PositionRow.MarketValueLocal, cellValue)\n        case \"Book Market Value\" => positionRow.put(PositionRow.MarketValueBook, cellValue)\n        case \"Book Unrealized Gain/Loss\" => positionRow.put(PositionRow.UnrealizedGainOrLoss, cellValue)\n        case \"% NAV\" => positionRow.put(PositionRow.PercentAssets, cellValue)\n        case \"Sedol\" => positionRow.put(PositionRow.Sedol, cellValue)\n        case \"Isin\" => positionRow.put(PositionRow.ISIN, cellValue)\n        case \"Ticker\" => positionRow.put(PositionRow.Ticker, cellValue)\n        case \"Exchange Rate\" => {positionRow.put(PositionRow.FXRate, cellValue); positionRow.put(PositionRow.FXRate2, cellValue)}\n        case \"Long/Short\" => positionRow.put(PositionRow.LongShort, cellValue)\n        case \"Currency\" => positionRow.put(PositionRow.Currency, cellValue)\n        case \"Custodian\" => positionRow.put(PositionRow.Custodian, cellValue)\n        case \"Security Exchange Listing\" => positionRow.put(PositionRow.SecurityExchangeListing, cellValue)\n        case _ => {}\n      }\n    }\n    positionRow\n  }\n\n  override def outputExcelTableBodyRow(sheet: XSSFSheet, bodyBlocks: Seq[BlockConfig], cellStyle: CellStyle): Unit = {\n    var rowNum = 1\n    for(block <- bodyBlocks){\n      var row = sheet.createRow(rowNum);\n      var blockLine = block.content;\n      var bodyLineList = blockLine.split(\"\\\\|\", -1)\n      row.createCell(0).setCellValue(bodyLineList(0))\n      row.createCell(1).setCellValue(bodyLineList(28))\n      row.createCell(2).setCellValue(bodyLineList(9))\n      row.createCell(3).setCellValue(bodyLineList(0))\n      row.createCell(4).setCellValue(bodyLineList(8))\n      val cell = row.createCell(5)\n      if(bodyLineList(16) != \"\"){\n        cell.setCellValue(bodyLineList(16).toDouble)\n      }else {\n        cell.setCellValue(bodyLineList(16))\n      }\n      val cell2 = row.createCell(6)\n      if(bodyLineList(17) != \"\"){\n        cell2.setCellValue(bodyLineList(17).toDouble)\n      }else{\n        cell2.setCellValue(bodyLineList(17))\n      }\n      val cell3 = row.createCell(7)\n      if(bodyLineList(21) != \"\"){\n        cell3.setCellValue(bodyLineList(21).toDouble)\n      }else{\n        cell3.setCellValue(bodyLineList(21))\n      }\n      val cell4 = row.createCell(8)\n      if(bodyLineList(20) != \"\"){\n        cell4.setCellValue(bodyLineList(20).toDouble)\n      }else{\n        cell4.setCellValue(bodyLineList(20))\n      }\n      val cell5 = row.createCell(9)\n      if(bodyLineList(22) != \"\"){\n        cell5.setCellValue(bodyLineList(22).toDouble)\n      }else{\n        cell5.setCellValue(bodyLineList(22))\n      }\n      val cell6 = row.createCell(10)\n      if(bodyLineList(23) != \"\"){\n        cell6.setCellValue(bodyLineList(23).toDouble)\n      }else{\n        cell6.setCellValue(bodyLineList(23))\n      }\n      val cell7 = row.createCell(11)\n      if(bodyLineList(25) != \"\"){\n        cell7.setCellValue(bodyLineList(25).toDouble)\n      }else{\n        cell7.setCellValue(bodyLineList(25))\n      }\n      row.createCell(12).setCellValue(\"N/A\")\n      row.createCell(13).setCellValue(\"N/A\")\n      row.createCell(14).setCellValue(bodyLineList(11))\n      row.createCell(15).setCellValue(bodyLineList(12))\n      row.createCell(16).setCellValue(bodyLineList(14))\n      val cell8 = row.createCell(17)\n      if(bodyLineList(34) != \"\"){\n        cell7.setCellValue(bodyLineList(34).toDouble)\n      }else{\n        cell7.setCellValue(bodyLineList(34))\n      }\n      row.createCell(18).setCellValue(bodyLineList(4))\n      row.createCell(19).setCellValue(bodyLineList(7))\n      row.createCell(20).setCellValue(bodyLineList(5))\n      row.createCell(21).setCellValue(bodyLineList(27))\n      val cell9 = row.createCell(22)\n      if(bodyLineList(34) != \"\"){\n        cell7.setCellValue(bodyLineList(34).toDouble)\n      }else{\n        cell7.setCellValue(bodyLineList(34))\n      }\n\n      rowNum = rowNum + 1;\n    }\n  }\n} BaseExcelReportProcessor package com.pwc.ds.awm.processor.excelReport\n\nimport java.io.{File, FileInputStream, FileOutputStream}\nimport java.sql.Date\nimport java.text.SimpleDateFormat\nimport java.time.LocalDate\nimport java.util.TimeZone\n\nimport com.pwc.ds.awm.component.safelogger.SafeLogger\nimport com.pwc.ds.awm.processor.exceptions.ExtractionException\nimport com.pwc.ds.awm.processor.generateEGA.basicReport.GenevaSingleEGAStorage\nimport com.pwc.ds.awm.processor.reportconfigs.extractorschema.{BlockConfig, ColumnConfig, ExtractorConfig}\nimport com.pwc.ds.awm.processor.{BaseReportProcessor, date2UTCLocalDate}\nimport org.apache.commons.lang.StringUtils\nimport org.apache.poi.hssf.usermodel.{HSSFDateUtil, HSSFWorkbook}\nimport org.apache.poi.ss.usermodel.{CellStyle, CellType, DateUtil, Row}\nimport org.apache.poi.xssf.usermodel.{XSSFSheet, XSSFWorkbook}\nimport play.api.Logger\n\nimport scala.util.control.Breaks.{break, breakable}\n\nclass BaseExcelReportProcessor extends BaseReportProcessor{\n\n  val excelFormatter = new SimpleDateFormat(\"MM/dd/yyyy\")\n  val csvFormatter = new SimpleDateFormat(\"MM-dd-yyyy\")\n  val outputFormatter = new SimpleDateFormat(\"dd/MM/yyyy\")\n\n  override def extractToObjectForPeriod (sourceFilePath: String, frontEndFundName: String, frontEndPeriodStart: Date, frontEndPeriodEnd: Date): Any = {\n\n    val inputStream = new FileInputStream(new File(sourceFilePath))\n    val workbook = new HSSFWorkbook(inputStream)\n\n    var sheetIterator = workbook.sheetIterator()\n    var hasReportFound = false\n\n    var isHeader = true\n    var isTableHeader = true\n\n    var newStorage: Any = new GenevaSingleEGAStorage()\n    var tableHeaderColumns = reportConfig.tableConfig.tableBodyConfig\n    var headerList = tableHeaderColumns(0);\n    var headerNum = headerList.length\n\n    var reportHeaders = Seq[String]()\n    var tableHeaders = Seq[String]()\n    var tablebodies = Seq[BlockConfig]()\n\n    while(sheetIterator.hasNext){\n      var sheet = sheetIterator.next()\n      var lastIndex = -1\n      var rowIterator = sheet.rowIterator()\n      while(rowIterator.hasNext){\n        var row = rowIterator.next()\n        var index = row.getRowNum\n        if(index != lastIndex +1){\n          isHeader =false\n        }\n        lastIndex = index\n        if(checkIfRowIsEmpty(row)){\n          isHeader = false\n        }\n        if(reportHeaders.contains(\"Dividends Detail Report:\")){\n          if(row.getCell(0).getStringCellValue == \"Portfolio\"){\n            isHeader = false\n          }\n        }\n        if(isHeader){\n          reportHeaders = reportHeaders :+ getReportHeader(row)\n        }else{\n          if(isTableHeader){\n            var nextRow = rowIterator.next()\n            if(!checkIfRowIsEmpty(nextRow)){\n              tableHeaders = getTableHeaders(row, headerNum)\n              isTableHeader = false\n            }else{\n              tableHeaders = getTableHeaders(rowIterator.next(), headerNum)\n              isTableHeader = false\n            }\n          }else{\n            if(!checkIfRowIsEmpty(row)){\n              tablebodies = tablebodies :+ getTableContent(row, headerNum)\n            }\n          }\n        }\n      }\n      var reportHeadersWithContent = reportHeaders.filter(header => {\n        header.trim.length > 0\n      })\n      var tableHeadersWithContent = tableHeaders.filter(header => {\n        header.trim.length > 0\n      })\n      if(tablebodies.length == 0) {\n        throw ExtractionException(\"File contains 0 records, please check your file and upload again.\")\n      }\n      if(reportHeadersWithContent.contains(\"Report Type: Receivable Summary:\")){\n        throw ExtractionException(\"Please upload Dividends Detail Report in income summary format.\")\n      }\n      if (reportHeadersWithContent.length > 0) {\n        hasReportFound = true\n\n        //verify whether the uploaded excel is valid\n        import java.text.SimpleDateFormat\n        var formatter = new SimpleDateFormat(\"MM/dd/yyyy\")\n        formatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"))\n        var excelPeriodStartStrList = Seq[String]()\n        var excelPeriodStartDate = \"\"\n        var excelPeriodEndStrList = Seq[String]()\n        var excelPeriodEndDate = \"\"\n        var fileStartDate = LocalDate.now()\n        var fileEndDate = LocalDate.now()\n        breakable{\n          for(i <-0 to reportHeadersWithContent.length-1){\n            if(reportHeadersWithContent(i).contains(\"Period Start Date\")) {\n              excelPeriodStartStrList = reportHeadersWithContent(i).split(\":\")\n              excelPeriodStartDate = excelPeriodStartStrList(1)\n              fileStartDate = date2UTCLocalDate(formatter.parse(excelPeriodStartDate))\n            }\n            if(reportHeadersWithContent(i).contains(\"Period End Date\")){\n              excelPeriodEndStrList = reportHeadersWithContent(i).split(\":\")\n              excelPeriodEndDate = excelPeriodEndStrList(1)\n              fileEndDate = date2UTCLocalDate(formatter.parse(excelPeriodEndDate))\n              break()\n            }\n          }\n        }\n\n        newStorage = outputTableBodyRowIntoObjectForPeriod(tableHeaderColumns, tablebodies, this.lineBreaker, frontEndPeriodStart, frontEndPeriodEnd, fileStartDate, fileEndDate, false)\n      }\n    }\n    if (!hasReportFound) {\n      SafeLogger.logString(Logger, s\"No report found for fund ${frontEndFundName} in period ${frontEndPeriodStart} ${frontEndPeriodEnd}\")\n    }\n    newStorage\n  }\n\n  def getReportHeader(row: Row): String = {\n    var reportHeader = \"\"\n    val cellIterator = row.cellIterator()\n    while(cellIterator.hasNext){\n      var cell = cellIterator.next()\n      cell.getCellType match {\n        case CellType.NUMERIC => reportHeader = reportHeader + cell.getNumericCellValue + \":\"\n        case CellType.STRING => reportHeader = reportHeader + cell.getStringCellValue + \":\"\n        case _ => {}\n      }\n    }\n    reportHeader\n  }\n  def getTableHeaders(row: Row, headerNum: Int): Seq[String] = {\n    var tableHeaders = Seq[String]()\n\n    for(cn <- 0 to headerNum-1) {\n      var cell = row.getCell(cn, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);\n      cell.getCellType() match {\n        case CellType.STRING => {tableHeaders = tableHeaders :+ cell.getStringCellValue}\n        case CellType.BOOLEAN => {tableHeaders = tableHeaders :+ cell.getBooleanCellValue.toString}\n        case CellType.NUMERIC => {tableHeaders = tableHeaders :+ cell.getNumericCellValue.toString}\n        case CellType.BLANK => {\n          if(cn == headerNum-1){\n            tableHeaders = tableHeaders :+ \"null\"\n          } else {\n            tableHeaders = tableHeaders :+ \"\"\n          }\n        }\n      }\n    }\n    tableHeaders\n  }\n\n  def getTableContent(row: Row, headerNum: Int): BlockConfig = {\n    var rowValues = Seq[String]()\n\n    for(cn <- 0 to headerNum-1) {\n      var cell = row.getCell(cn, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);\n      cell.getCellType() match {\n        case CellType.STRING => {rowValues = rowValues :+ cell.getStringCellValue}\n        case CellType.BOOLEAN => {rowValues = rowValues :+ cell.getBooleanCellValue.toString}\n        case CellType.NUMERIC => {\n          if (DateUtil.isCellDateFormatted(cell)) {\n            rowValues = rowValues :+ excelFormatter.format(cell.getDateCellValue)\n          } else {\n            rowValues = rowValues :+ cell.getNumericCellValue.toString\n          }\n        }\n        case CellType.BLANK => {\n          if(cn == headerNum-1){\n            rowValues = rowValues :+ \"null\"\n          } else {\n            rowValues = rowValues :+ \"\"\n          }\n        }\n      }\n    }\n\n    BlockConfig(rowValues.mkString(\"|\"))\n  }\n\n  def checkIfRowIsEmpty(row: Row): Boolean = {\n    if(row == null) {\n      return true\n    }\n    if(row.getLastCellNum <= 0){\n      return true\n    }\n    val cellIterator = row.cellIterator()\n    while(cellIterator.hasNext){\n      val cell = cellIterator.next()\n      if(cell != null && cell.getCellTypeEnum() != CellType.BLANK && StringUtils.isNotBlank(cell.toString())){\n        return false\n      }\n    }\n    true\n  }\n\n  def outputTableBodyRowIntoObjectForPeriod(tableHeaderColumns: Seq[Seq[ColumnConfig]], bodyBlocks: Seq[BlockConfig], lineBreaker: String, frontEndPeriodStart: Date, frontEndPeriodEnd: Date, fileStartDate: LocalDate, fileEndDate: LocalDate, isCSV: Boolean): Any = {\n    new GenevaSingleEGAStorage()\n  }\n\n  override def extractToExcel(sourceFilePath: String): XSSFWorkbook = {\n    val workbook = new XSSFWorkbook()\n\n    val cellStyle = workbook.createCellStyle\n    val createHelper = workbook.getCreationHelper\n    cellStyle.setDataFormat(createHelper.createDataFormat.getFormat(\"MM/dd/yyyy\"))\n\n    val inputStream = new FileInputStream(new File(sourceFilePath))\n    val workbookSource = new HSSFWorkbook(inputStream)\n\n    var sheetIterator = workbookSource.sheetIterator()\n\n    var isHeader = true\n    var isTableHeader = true\n\n    var tableHeaderColumns = reportConfig.tableConfig.tableBodyConfig\n    var headerList = tableHeaderColumns(0);\n    var headerNum = headerList.length\n\n    var reportHeaders = Seq[String]()\n    var tableHeaders = Seq[String]()\n    var tablebodies = Seq[BlockConfig]()\n    while(sheetIterator.hasNext) {\n      var sheet = sheetIterator.next()\n      var rowIterator = sheet.rowIterator()\n      while (rowIterator.hasNext) {\n        var row = rowIterator.next()\n        if (checkIfRowIsEmpty(row)) {\n          isHeader = false\n        }\n        if (isHeader) {\n          reportHeaders = reportHeaders :+ getReportHeader(row)\n        } else {\n          if (isTableHeader) {\n            var nextRow = rowIterator.next()\n            if(!checkIfRowIsEmpty(nextRow)){\n              tableHeaders = getTableHeaders(nextRow, headerNum)\n              isTableHeader = false\n            }else{\n              tableHeaders = getTableHeaders(rowIterator.next(), headerNum)\n              isTableHeader = false\n            }\n          } else {\n            tablebodies = tablebodies :+ getTableContent(row, headerNum)\n          }\n        }\n      }\n      var reportHeadersWithContent = reportHeaders.filter(header => {\n        header.trim.length > 0\n      })\n      var tableHeadersWithContent = tableHeaders.filter(header => {\n        header.trim.length > 0\n      })\n    }\n\n    var reportName = reportConfig.reportType\n    var bodySheet = workbook.createSheet(reportName)\n    outputExcelTableHeaderRow(bodySheet, tableHeaderColumns)\n    outputExcelTableBodyRow(bodySheet, tablebodies, cellStyle)\n    workbook\n  }\n\n  def outputExcelTableHeaderRow(sheet: XSSFSheet, tableHeaderColumns: Seq[Seq[ColumnConfig]]):Unit = {\n\n    var rowNum = 0\n    var row = sheet.createRow(rowNum);\n\n    reportConfig.reportType match {\n      case \"Trial balance\" => {\n        row.createCell(0).setCellValue(\"Group1\")\n        row.createCell(1).setCellValue(\"Group2\")\n        row.createCell(2).setCellValue(\"FinancialAccount_Detail\")\n        row.createCell(3).setCellValue(\"Description_Detail\")\n        row.createCell(4).setCellValue(\"OpeningBalance_Detail\")\n        row.createCell(5).setCellValue(\"Debits_Detail\")\n        row.createCell(6).setCellValue(\"Credits_Detail\")\n        row.createCell(7).setCellValue(\"ClosingBalance_Detail\")\n        row.createCell(8).setCellValue(\"Account name\")\n        row.createCell(9).setCellValue(\"Balance\")\n      }\n      case \"Detailed general ledger\" => {\n        row.createCell(0).setCellValue(\"BeginingBalanceDescription\")\n        row.createCell(1).setCellValue(\"BeginingBalanceAmount\")\n        row.createCell(2).setCellValue(\"Tran Date\")\n        row.createCell(3).setCellValue(\"Tran ID\")\n        row.createCell(4).setCellValue(\"Tran Description\")\n        row.createCell(5).setCellValue(\"Investment\")\n        row.createCell(6).setCellValue(\"Loc\")\n        row.createCell(7).setCellValue(\"Currency\")\n        row.createCell(8).setCellValue(\"Local Amount\")\n        row.createCell(9).setCellValue(\"Book Amount\")\n        row.createCell(10).setCellValue(\"Balance\")\n        row.createCell(11).setCellValue(\"EndingBalanceDescription\")\n        row.createCell(12).setCellValue(\"EndingBalanceAmount\")\n      }\n      case \"Position appraisal report\" => {\n        row.createCell(0).setCellValue(\"Group1\")\n        row.createCell(1).setCellValue(\"Group2\")\n        row.createCell(2).setCellValue(\"InvestID\")\n        row.createCell(3).setCellValue(\"Portfolio\")\n        row.createCell(4).setCellValue(\"Description\")\n        row.createCell(5).setCellValue(\"Quantity\")\n        row.createCell(6).setCellValue(\"MarketPrice\")\n        row.createCell(7).setCellValue(\"CostBook\")\n        row.createCell(8).setCellValue(\"MarketValueLocal\")\n        row.createCell(9).setCellValue(\"MarketValueBook\")\n        row.createCell(10).setCellValue(\"UnrealizedGainOrLoss\")\n        row.createCell(11).setCellValue(\"PercentAssets\")\n        row.createCell(12).setCellValue(\"ExtendedDescription\")\n        row.createCell(13).setCellValue(\"Description3\")\n        row.createCell(14).setCellValue(\"Sedol\")\n        row.createCell(15).setCellValue(\"ISIN\")\n        row.createCell(16).setCellValue(\"Ticker\")\n        row.createCell(17).setCellValue(\"FX rate\")\n        row.createCell(18).setCellValue(\"Long/Short\")\n        row.createCell(19).setCellValue(\"Currency\")\n        row.createCell(20).setCellValue(\"Custodian\")\n        row.createCell(21).setCellValue(\"Security Exchange Listing\")\n        row.createCell(22).setCellValue(\"FX rate\")\n      }\n      case \"Cash appraisal report\" => {\n        row.createCell(0).setCellValue(\"LongShortDescription\")\n        row.createCell(1).setCellValue(\"GroupByInfo\")\n        row.createCell(2).setCellValue(\"InvestDescription\")\n        row.createCell(3).setCellValue(\"InvestID\")\n        row.createCell(4).setCellValue(\"Quantity\")\n        row.createCell(5).setCellValue(\"FXRate\")\n        row.createCell(6).setCellValue(\"CostBook\")\n        row.createCell(7).setCellValue(\"MarketValueBook\")\n        row.createCell(8).setCellValue(\"BookUnrealizedGrainLoss\")\n        row.createCell(9).setCellValue(\"percentInvest\")\n        row.createCell(10).setCellValue(\"percentsign\")\n        row.createCell(11).setCellValue(\"TB name\")\n        row.createCell(12).setCellValue(\"PwC Mapping\")\n      }\n      case \"Purchase and sale transaction report\" => {\n        row.createCell(0).setCellValue(\"TradeDate\")\n        row.createCell(1).setCellValue(\"SettleDate\")\n        row.createCell(2).setCellValue(\"TranType\")\n        row.createCell(3).setCellValue(\"InvestID\")\n        row.createCell(4).setCellValue(\"Investment\")\n        row.createCell(5).setCellValue(\"CustodianAccount\")\n        row.createCell(6).setCellValue(\"Quantity\")\n        row.createCell(7).setCellValue(\"Price\")\n        row.createCell(8).setCellValue(\"SEC\")\n        row.createCell(9).setCellValue(\"LocalAmount\")\n        row.createCell(10).setCellValue(\"BookAmount\")\n        row.createCell(11).setCellValue(\"ContractDate\")\n        row.createCell(12).setCellValue(\"TranID\")\n        row.createCell(13).setCellValue(\"GenericInvestment\")\n        row.createCell(14).setCellValue(\"Broker\")\n        row.createCell(15).setCellValue(\"Trader\")\n        row.createCell(16).setCellValue(\"Commission\")\n        row.createCell(17).setCellValue(\"Expenses\")\n        row.createCell(18).setCellValue(\"LocalCurrency\")\n        row.createCell(19).setCellValue(\"TotalBookAmount\")\n        row.createCell(20).setCellValue(\"Portfolio\")\n        row.createCell(21).setCellValue(\"Fund Currency\")\n        row.createCell(22).setCellValue(\"Long/Short\")\n        row.createCell(23).setCellValue(\"Sedol\")\n        row.createCell(24).setCellValue(\"ISIN\")\n        row.createCell(25).setCellValue(\"Ticker\")\n      }\n      case \"Dividends Detail Report\" => {\n        row.createCell(0).setCellValue(\"Sort\")\n        row.createCell(1).setCellValue(\"Currency\")\n        row.createCell(2).setCellValue(\"CustAccount\")\n        row.createCell(3).setCellValue(\"Investment\")\n        row.createCell(4).setCellValue(\"InvID\")\n        row.createCell(5).setCellValue(\"TransID\")\n        row.createCell(6).setCellValue(\"ExDate\")\n        row.createCell(7).setCellValue(\"ExDateQuantity\")\n        row.createCell(8).setCellValue(\"LocalDividendPerShareAmount\")\n        row.createCell(9).setCellValue(\"WHTaxRate\")\n        row.createCell(10).setCellValue(\"LocalGrossDividendIncExp\")\n        row.createCell(11).setCellValue(\"LocalNetDividendIncExp\")\n        row.createCell(12).setCellValue(\"LocalWHTax\")\n        row.createCell(13).setCellValue(\"BookGrossDividendIncExp\")\n        row.createCell(14).setCellValue(\"BookNetDividendIncExp\")\n        row.createCell(15).setCellValue(\"BookWHTax\")\n        row.createCell(16).setCellValue(\"PayDate\")\n        row.createCell(17).setCellValue(\"LocalReclaim\")\n        row.createCell(18).setCellValue(\"BookReclaim\")\n        row.createCell(19).setCellValue(\"Sedol\")\n        row.createCell(20).setCellValue(\"ISIN\")\n        row.createCell(21).setCellValue(\"Ticker\")\n        row.createCell(22).setCellValue(\"ISIN\")\n        row.createCell(23).setCellValue(\"Ticker\")\n        row.createCell(24).setCellValue(\"Investment\")\n      }\n      case \"Realised Gain Loss report\" => {\n        row.createCell(0).setCellValue(\"Group1\")\n        row.createCell(1).setCellValue(\"InvestmentCode\")\n        row.createCell(2).setCellValue(\"CloseDate\")\n        row.createCell(3).setCellValue(\"ClosingID\")\n        row.createCell(4).setCellValue(\"TransactionType\")\n        row.createCell(5).setCellValue(\"TaxLotDate\")\n        row.createCell(6).setCellValue(\"TaxLotID\")\n        row.createCell(7).setCellValue(\"TaxLotPrice\")\n        row.createCell(8).setCellValue(\"ClosingPrice\")\n        row.createCell(9).setCellValue(\"OriginalFace\")\n        row.createCell(10).setCellValue(\"QuantityOrCurrentFace\")\n        row.createCell(11).setCellValue(\"NetProceedsBook\")\n        row.createCell(12).setCellValue(\"CostBook\")\n        row.createCell(13).setCellValue(\"PriceGLBook\")\n        row.createCell(14).setCellValue(\"FXGainLoss\")\n        row.createCell(15).setCellValue(\"STCapitalGL\")\n        row.createCell(16).setCellValue(\"LTCapitalGL\")\n        row.createCell(17).setCellValue(\"OrdinaryIncome\")\n        row.createCell(18).setCellValue(\"TotalGLBook\")\n        row.createCell(19).setCellValue(\"NetProceedsLocal\")\n        row.createCell(20).setCellValue(\"CostLocal\")\n        row.createCell(21).setCellValue(\"PriceGLLocal\")\n        row.createCell(22).setCellValue(\"Sedol\")\n        row.createCell(23).setCellValue(\"ISIN\")\n        row.createCell(24).setCellValue(\"Ticker\")\n        row.createCell(25).setCellValue(\"Currency\")\n      }\n      case _ => {}\n    }\n\n  }\n\n  def outputExcelTableBodyRow(sheet: XSSFSheet, bodyBlocks: Seq[BlockConfig], cellStyle: CellStyle):Unit = {}\n\n  def readCSVFileAndExtractToObject(sourceFilePath: String, extractorConfig: ExtractorConfig, fundEngagementId:String, auditPeriodBegin: Date, auditPeriodEnd: Date):Any = {\n    var ofstream: FileOutputStream = null\n    this.reportConfig = extractorConfig\n    //extract csv file\n    val newStorage = extractToObject(sourceFilePath, fundEngagementId, auditPeriodBegin, auditPeriodEnd)\n    newStorage\n  }\n\n  def extractToObject(sourceFilePath: String, frontEndFundName:String, auditPeriodBegin: Date, auditPeriodEnd: Date) = {\n    val content = fileReader.extractTextFromFile(sourceFilePath)\n    this.setLineBreaker(dataSanitizer.detectLinebreaker(content))\n\n    var hasReportFound = false\n    var newStorage: Any = new GenevaSingleEGAStorage()\n\n    var tableConfig = reportConfig.tableConfig\n    var (reportHeaders, tableHeaders, tablebodies): (String, String, Seq[BlockConfig]) = getReportDetails(content, tableConfig)\n\n    if(tablebodies.length == 0 || (tablebodies.length == 1 && tablebodies(0).content == \"\")) {\n      throw ExtractionException(\"File contains 0 records, please check your file and upload again.\")\n    }\n    var headerStrList = reportHeaders.split(\"\\r\\n\")\n    //verify whether the uploaded excel is valid\n    import java.text.SimpleDateFormat\n    var formatter = new SimpleDateFormat(\"MM/dd/yyyy\")\n    formatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"))\n    var excelPeriodStartStrList = Seq[String]()\n    var excelPeriodStartDate = \"\"\n    var excelPeriodEndStrList = Seq[String]()\n    var excelPeriodEndDate = \"\"\n    var fileStartDate = LocalDate.now()\n    var fileEndDate = LocalDate.now()\n    breakable{\n      for(i <-0 to headerStrList.length-1){\n        if(headerStrList(i).contains(\"Period Start Date\")) {\n          if(headerStrList(i).contains(\",\")) {\n            excelPeriodStartStrList = headerStrList(i).split(\",\")\n          } else if(headerStrList(i).contains(\":\")) {\n            excelPeriodStartStrList = headerStrList(i).split(\":\")\n          }\n          if(excelPeriodStartStrList.length > 1) {\n            excelPeriodStartDate = excelPeriodStartStrList(1).replace(\"\\\"\", \"\")\n            println(\"MG: excelPeriodStartDate IS\" + excelPeriodStartDate.substring(1, excelPeriodStartDate.length-1))\n            fileStartDate = date2UTCLocalDate(formatter.parse(excelPeriodStartDate))\n          }\n        }\n        if(headerStrList(i).contains(\"Period End Date\")){\n          if(headerStrList(i).contains(\",\")) {\n            excelPeriodEndStrList = headerStrList(i).split(\",\")\n          } else if(headerStrList(i).contains(\":\")) {\n            excelPeriodEndStrList = headerStrList(i).split(\":\")\n          }\n          if(excelPeriodEndStrList.length > 1) {\n            excelPeriodEndDate = excelPeriodEndStrList(1).replace(\"\\\"\", \"\")\n            fileEndDate = date2UTCLocalDate(formatter.parse(excelPeriodEndDate))\n          }\n          break()\n        }\n      }\n    }\n\n    if(tableHeaders != \"\"){\n      hasReportFound = true\n      reportConfigGenerator.initiateTableHeaderStartIndex(tableHeaders, tableConfig.tableBodyConfig,this.lineBreaker)\n      newStorage = outputTableBodyRowIntoObjectForPeriod(tableConfig.tableBodyConfig, tablebodies, this.lineBreaker, auditPeriodBegin, auditPeriodEnd, fileStartDate, fileEndDate, true)\n    }\n    if(!hasReportFound){\n      SafeLogger.logString(Logger, s\"No report found for fund ${frontEndFundName} in period from ${new Date(auditPeriodBegin.getTime)} to ${new Date(auditPeriodEnd.getTime)}\")\n    }\n\n    newStorage\n  }\n\n} BaseReportProcessor package com.pwc.ds.awm.processor\n\nimport java.io.{File, FileOutputStream, IOException}\nimport java.sql.Date\nimport java.time.LocalDate\nimport java.util.TimeZone\nimport com.pwc.ds.awm.component.safelogger.SafeLogger\nimport com.pwc.ds.awm.const.ExtractionErrorCode\nimport com.pwc.ds.awm.processor.OutputMode.Type\nimport com.pwc.ds.awm.processor.utils.{BaseFileReader, FileReader}\nimport com.pwc.ds.awm.processor.reportconfigs.extractorschema._\nimport com.pwc.ds.awm.processor._\nimport com.pwc.ds.awm.processor.exceptions.{ExtractionError, ExtractionException}\nimport com.pwc.ds.awm.processor.generateEGA.basicReport.SingleEGAStorage\nimport org.apache.poi.xssf.usermodel.{XSSFSheet, XSSFWorkbook}\nimport play.api.Logger\n\nimport util.control.Breaks._\n\n\nabstract class BaseReportProcessor() extends AbstractProcessor {\n\n\n  var lineBreaker:String = \"\"\n\n  var reportConfig: ExtractorConfig = null\n  val outputExcel:BaseExcelOutput = new BaseExcelOutput;\n  val reportConfigGenerator: ReportConfigGenerator = new ReportConfigGeneratorImpl {}\n  val dataSanitizer:BaseDataSanitizerImpl = new BaseDataSanitizerImpl {}\n  val blockSeporator:BlockSeparatorImpl = new BlockSeparatorImpl {}\n  val fileReader = new FileReader\n\n  /**\n   * child class need to implement this function\n   * @param reportHeader\n   * @param lineBreaker\n   * @return\n   */\n  def outputTableBodyRowIntoMemory(tableHeaderColumns: Seq[Seq[ColumnConfig]], txtTableBodyPages: Seq[Seq[BlockConfig]], txtReportHeaders:Seq[String], lineBreaker:String) = {\n\n  }\n\n  def outputTableBodyRowIntoObjectForPeriod(tableHeaderColumns: Seq[Seq[ColumnConfig]], txtTableBodyPages: Seq[Seq[BlockConfig]], txtReportHeaders:Seq[String], lineBreaker:String, frontEndPeriodStart: Date, frontEndPeriodEnd: Date):Any = {\n    new SingleEGAStorage()\n  }\n  /**\n   * child class need to implement this function\n   * @param reportHeader\n   * @param lineBreaker\n   * @return\n   */\n  def getFundName(reportHeader:String, lineBreaker:String):String = {\n    \"\"\n  }\n\n  /**\n   * child class need to implement this function\n   * @param reportHeader\n   * @param lineBreaker\n   * @return\n   */\n  def getReportYear(reportHeader:String, lineBreaker:String): Int = {\n    2018\n  }\n\n  def isReportYearValid(txtYear:Integer, frontEndYear:Integer):Boolean ={\n    return true\n  }\n\n  /**\n   * to decide if the fund name is same with the fund name from front end\n   * @param txtFundName\n   * @param frontEndFundName\n   * @return\n   */\n  def isFundNameValid(txtFundName:String, frontEndFundName:String):Boolean = {\n    txtFundName.trim.toUpperCase.contains(frontEndFundName.trim.toUpperCase())\n  }\n\n\n  def setLineBreaker(content: String) = {\n    this.lineBreaker = dataSanitizer.detectLinebreaker(content)\n  }\n\n  /**\n   * 1. remove the empty lines in the start or end of in the block content.\n   * 2. also replace dailytotal,grandtotal these words with whitespaces in case it affects the column span setting afterwards\n   *\n   * @param block\n   * @return\n   */\n  def organizeBlock(block: BlockConfig): BlockConfig ={\n\n    block.content = block.content.replaceAll(\"RESTRICTED\\\\.*\",\"\")\n    if(!dataSanitizer.isTableContent(block.content)){\n      block.blockType = BlockType.discard\n    }\n    else if(block.content.contains(BlockType.grandTotal.toString)){\n      block.content = block.content.replaceAll(BlockType.grandTotal.toString, \"           \")\n      block.blockType = BlockType.grandTotal\n    }\n    var content = dataSanitizer.trimEmptyStartLines(block.content, lineBreaker)\n    content = dataSanitizer.trimEmptyEndLines(content, lineBreaker)\n    block.content = content\n    block\n  }\n\n\n  def extractToExcel(sourceFilePath: String): XSSFWorkbook = {\n\n    val workbook = new XSSFWorkbook()\n\n    val content = fileReader.extractTextFromFile(sourceFilePath)\n\n    this.setLineBreaker(dataSanitizer.detectLinebreaker(content))\n\n    var sheets:Array[String] = blockSeporator.splitContentIntoSheets(content);\n\n    for(sheetNum <- 0 until sheets.length){\n\n      var sheetContent = sheets(sheetNum);\n\n      var pages:Array[String] = blockSeporator.splitContentIntoPages(sheetContent, this.lineBreaker) // the pages must contain word \"PAGE\"\n\n      var bodySheet = workbook.createSheet(\"result_\" + (sheetNum + 1))\n\n      var hasSummary = reportConfig.summaryConfig.isDefined\n      var summaries = getPageBlocksAndInputToExcel(bodySheet, pages, reportConfig.tableConfig, pages.length, hasSummary)\n\n\n      if(reportConfig.summaryConfig.isDefined && summaries.filter(_.trim.length>0).length > 0){\n\n        var summaryConfig = reportConfig.summaryConfig.get\n        var summarySheet = workbook.createSheet(\"summary_for_report_\" + (sheetNum + 1))\n        getPageBlocksAndInputToExcel(summarySheet, summaries.toArray, summaryConfig, pages.length)\n      }\n\n    }\n    workbook\n  }\n\n  def extractToMemory(sourceFilePath: String, frontEndFundName:String, frontEndYear:Integer) = {\n    val content = fileReader.extractTextFromFile(sourceFilePath)\n    this.setLineBreaker(dataSanitizer.detectLinebreaker(content))\n    var sheets:Array[String] = blockSeporator.splitContentIntoSheets(content).filter(content => content.contains(frontEndFundName))\n    var hasReportFound = false\n    breakable{\n      for(sheet <- sheets){\n        var pages:Array[String] = blockSeporator.splitContentIntoPages(sheet, this.lineBreaker) // the pages must contain word \"PAGE\"\n        var hasSummary = reportConfig.summaryConfig.isDefined\n        var (txtReportHeaders,txtTableHeaders, txtTablebodies, sumaries):(Array[String],Array[String],Seq[Seq[BlockConfig]], Seq[String]) = getPageDetailedBlocks(pages, reportConfig.tableConfig, hasSummary);\n\n        var txtReportHeadersWithContent = txtReportHeaders.filter(header => {header.trim.length > 0})\n        var txtTableHeadersWithContent = txtTableHeaders.filter(header => {header.trim.length > 0})\n        if(txtReportHeadersWithContent.length > 0){\n          var txtYear = this.getReportYear(txtReportHeadersWithContent(0), this.lineBreaker)\n          var txtFundName = this.getFundName(txtReportHeadersWithContent(0), this.lineBreaker)\n          if(isReportYearValid(txtYear, frontEndYear) && isFundNameValid(txtFundName, frontEndFundName)){\n            hasReportFound = true\n            var tableHeaderColumns = reportConfig.tableConfig.tableBodyConfig\n            reportConfigGenerator.initiateTableHeaderStartIndex(txtTableHeadersWithContent(0), tableHeaderColumns,this.lineBreaker)\n            reportConfigGenerator.setColumnStartAccordingToTableContent(txtTablebodies, tableHeaderColumns, this.lineBreaker)\n            reportConfigGenerator.setColumnEndIndex(tableHeaderColumns)\n            outputTableBodyRowIntoMemory(tableHeaderColumns, txtTablebodies, txtReportHeaders, this.lineBreaker)\n            break\n          }\n        }\n\n      }\n    }\n    if(!hasReportFound){\n      SafeLogger.logString(Logger, s\"No report found for fund ${frontEndFundName} in year ${frontEndYear}\")\n    }\n  }\n\n\n  def getPageBlocksAndInputToExcel(sheet:XSSFSheet, pages:Array[String],\n                                   tableConfig: TableConfig, totalPageNum :Int= 0, hasSummary:Boolean = false):Seq[String] = {\n\n    var tableHeaderColumns = tableConfig.tableBodyConfig\n\n    var (txtReportHeaders,txtTableHeaders, txtTablebodies, sumaries):(Array[String],Array[String],Seq[Seq[BlockConfig]], Seq[String]) = getPageDetailedBlocks(pages, tableConfig, hasSummary);\n\n    var txtHeadersWithContent = txtTableHeaders.filter(header => {\n      header.trim.length > 0\n    })\n\n    if(txtTablebodies.flatten.length >0 && txtHeadersWithContent.length > 0 && txtTableHeaders.length > 0){ //only there are contents, we output to the excel\n      reportConfigGenerator.initiateTableHeaderStartIndex(txtHeadersWithContent(0), tableHeaderColumns,this.lineBreaker)\n\n      reportConfigGenerator.setColumnStartAccordingToTableContent(txtTablebodies, tableHeaderColumns, this.lineBreaker)\n\n      reportConfigGenerator.setColumnEndIndex(tableHeaderColumns)\n\n      outputExcel.outputExcelTableHeaderRow(sheet, tableHeaderColumns, Some(0));\n      outputExcel.outputExcelTableBodyRow(sheet, tableHeaderColumns, txtTablebodies,txtReportHeaders,this.lineBreaker, totalPageNum)\n    }\n    sumaries\n  }\n\n  /**\n   * @param pages: separate pages into reportHeaders, tableHeaders, tableBodies, summaries. (summary must be embraced with star(*) lines.\n   * @param blockType: define how many line breaks exist in table body.\n   * @param reportHeaderLineNum\n   * @param tableHeaderLineNum\n   * @return  reportHeaders, tableHeaders, summaries are aligned with page number\n   */\n  def getPageDetailedBlocks(pages:Array[String], tableConfig:TableConfig, hasSummary:Boolean): (Array[String],Array[String],Seq[Seq[BlockConfig]], Seq[String])={\n    var reportHeaders = new Array[String](pages.length)\n    var tableHeaders = new Array[String](pages.length)\n    var tablebodies = Seq[Seq[BlockConfig]]()\n    var summaries = Seq[String]()\n    for(pageNum <- 0 until pages.length){\n\n      var headerStr = \"\"\n      var txtTableHeaderStr = \"\"\n      var pageBlocks = Seq[BlockConfig]()\n      if(!dataSanitizer.isGarbageContent(pages(pageNum))){ // when page is summary page, it's empty content\n        var page = pages(pageNum)\n        var left = dataSanitizer.trimEmptyStartLines(page, this.lineBreaker)\n        var reportHeaderLastIndex = blockSeporator.getReportHeaderEndIndex(left,tableConfig.reportHeaderLineNumber, lineBreaker);\n        headerStr = left.substring(0, reportHeaderLastIndex);\n        left = left.substring(reportHeaderLastIndex)\n\n        var (summaryContent:String, tableBodyContent:String) = if(hasSummary) blockSeporator.getSummaryContent(left,lineBreaker) else (\"\",left)// here get summary content by star (*) lines\n        summaries = summaries :+ summaryContent\n        left = dataSanitizer.trimEmptyStartLines(tableBodyContent, this.lineBreaker);\n\n        var tableHeaderLastIndex = blockSeporator.getTableHeaderEndIndex(left,tableConfig.tableHeaderLineNumber, lineBreaker);\n        txtTableHeaderStr = if(tableHeaderLastIndex>0)left.substring(0, tableHeaderLastIndex) else \"\";\n        left = if(tableHeaderLastIndex>0)left.substring(tableHeaderLastIndex) else \"\"\n\n        pageBlocks = blockSeporator.splitTableContentIntoBlocks(tableConfig.blockSeperatorNumber, tableConfig.tableHeaderLineNumber, left, lineBreaker);\n\n        pageBlocks = pageBlocks.map(block => {\n          block.pageNum = pageNum + 1;\n          organizeBlock(block)\n        })\n\n        pageBlocks = pageBlocks.filter(block => {\n          block.blockType != BlockType.discard\n        })\n      }\n      reportHeaders(pageNum) = headerStr;\n      tableHeaders(pageNum) = txtTableHeaderStr;\n      tablebodies = tablebodies :+ pageBlocks\n    }\n    return (reportHeaders, tableHeaders, tablebodies, summaries)\n  }\n\n\n  def readFileAndExtract(sourceFilePath: String, destFilePath: String, mode: Type, extractorConfig: ExtractorConfig, fundName:String, year: Integer): Unit = {\n    var ofstream: FileOutputStream = null\n    this.reportConfig = extractorConfig\n    try {\n      mode match {\n        case OutputMode.Excel =>{\n          val workbook = extractToExcel(sourceFilePath)\n          val outfile = new File(destFilePath)\n          ofstream = new FileOutputStream(outfile)\n          if (!outfile.exists()) outfile.createNewFile()\n          workbook.write(ofstream)\n          ofstream.flush()\n          ofstream.close()\n        }\n        case OutputMode.Memory =>{\n          extractToMemory(sourceFilePath, fundName, year)\n        }\n      }\n\n    } catch {\n      case e: Exception => SafeLogger.logStringError(Logger, s\"Error when extracting ${extractorConfig.reportType} for fund(${fundName}) year ${year}\", e)\n    } finally {\n      try {\n        if (ofstream != null) ofstream.close()\n      } catch {\n        case e: IOException => SafeLogger.logStringError(Logger, s\"Error when saving file for ${extractorConfig.reportType} for fund(${fundName}) year ${year}\", e)\n      }\n    }\n  }\n\n  def isReportDateValid( periodStart: Date, periodEnd: Date, date1: Date, date2: Date = null): Boolean = {\n    !date2UTCLocalDate(date1).isAfter(date2UTCLocalDate(periodEnd)) && !date2UTCLocalDate(date1).isBefore(date2UTCLocalDate(periodStart))\n  }\n\n  def isCurrentYear(periodStart: Date, periodEnd: Date, date1: Date, date2:Date = null): Boolean = {\n    !date2UTCLocalDate(date2).isAfter(date2UTCLocalDate(periodEnd)) && !date2UTCLocalDate(date1).isBefore(date2UTCLocalDate(periodStart))\n  }\n\n  def isPreviousYear(periodStart: Date, periodEnd: Date, date1: Date, date2:Date = null): Boolean = {\n    date2UTCLocalDate(date1).isBefore(date2UTCLocalDate(periodStart))\n  }\n  def isAfterYear(periodStart: Date, periodEnd: Date, date1: Date, date2:Date = null): Boolean = {\n    date2UTCLocalDate(date1).isAfter(date2UTCLocalDate(periodEnd))\n  }\n\n  def getReportStartDate(reportHeader: String, lineBreaker: String): Date = {\n    null\n  }\n  def getReportEndDate(reportHeader: String, lineBreaker: String): Date = {\n    null\n  }\n\n\n  /**\n   *\n   * Below is the methods to extract to object, this is for HSBC IMS extraction\n   */\n\n  def extractToObjectForPeriod(sourceFilePath: String, frontEndFundName: String, frontEndPeriodStart: Date, frontEndPeriodEnd: Date): Any = {\n    val content = fileReader.extractTextFromFile(sourceFilePath)\n    this.setLineBreaker(dataSanitizer.detectLinebreaker(content))\n    var sheets:Array[String] = blockSeporator.splitContentIntoSheets(content).filter(content => content.contains(frontEndFundName))\n\n    var hasReportFound = false\n    var newStorage:Any = null\n    breakable{\n      for(sheet <- sheets){\n        var pages:Array[String] = blockSeporator.splitContentIntoPages(sheet, this.lineBreaker) // the pages must contain word \"PAGE\"\n        var hasSummary = reportConfig.summaryConfig.isDefined\n        var (txtReportHeaders,txtTableHeaders, txtTablebodies, sumaries):(Array[String],Array[String],Seq[Seq[BlockConfig]], Seq[String]) = getPageDetailedBlocks(pages, reportConfig.tableConfig, hasSummary);\n\n        var txtReportHeadersWithContent = txtReportHeaders.filter(header => {header.trim.length > 0})\n        var txtTableHeadersWithContent = txtTableHeaders.filter(header => {header.trim.length > 0})\n        if(txtReportHeadersWithContent.length > 0){\n          var date1 = this.getReportStartDate(txtReportHeadersWithContent(0), this.lineBreaker)\n          var date2 =  this.getReportEndDate(txtReportHeadersWithContent(0), this.lineBreaker)\n          var txtFundName = this.getFundName(txtReportHeadersWithContent(0), this.lineBreaker)\n          if (isFundNameValid(txtFundName, frontEndFundName) && isReportDateValid(frontEndPeriodStart, frontEndPeriodEnd, date1, date2)) {\n            hasReportFound = true\n            var tableHeaderColumns = reportConfig.tableConfig.tableBodyConfig\n            reportConfigGenerator.initiateTableHeaderStartIndex(txtTableHeadersWithContent(0), tableHeaderColumns,this.lineBreaker)\n            reportConfigGenerator.setColumnStartAccordingToTableContent(txtTablebodies, tableHeaderColumns, this.lineBreaker)\n            reportConfigGenerator.setColumnEndIndex(tableHeaderColumns)\n            newStorage = outputTableBodyRowIntoObjectForPeriod(tableHeaderColumns, txtTablebodies, txtReportHeaders, this.lineBreaker, frontEndPeriodStart, frontEndPeriodEnd)\n            break\n          }\n        }\n      }\n    }\n\n    if(!hasReportFound){\n      SafeLogger.logString(Logger, s\"No report found for fund ${frontEndFundName} in period ${frontEndPeriodStart} ${frontEndPeriodEnd}\")\n      throw ExtractionError(ExtractionErrorCode.ZERO_RECORDS_EXTRACTED)\n      //throw ExtractionException(s\"No report found for fund ${frontEndFundName}.\")\n    }\n\n    newStorage\n  }\n\n  override def readFileAndExtractToObjectForPeriod(sourceFilePath: String, extractorConfig: ExtractorConfig, fundName: String, frontEndPeriodStart: Date, frontEndPeriodEnd: Date): Any = {\n    var ofstream: FileOutputStream = null\n    this.reportConfig = extractorConfig\n    val newStorage = extractToObjectForPeriod(sourceFilePath, fundName, frontEndPeriodStart, frontEndPeriodEnd)\n    newStorage\n  }\n\n  /**\n   * @param content     : separate csv file content into reportHeaders, tableHeaders, tableBodies.\n   * @param tableConfig\n   * @return reportHeaders, tableHeaders, tableBodies\n   */\n  def getReportDetails(content: String, tableConfig: TableConfig): (String, String, Seq[BlockConfig]) = {\n    var reportHeaders = \"\"\n    var tableHeaders = \"\"\n    var tablebodies = Seq[BlockConfig]()\n\n    var tableConfig = reportConfig.tableConfig\n    //trim empty start lines\n    var left = dataSanitizer.trimEmptyStartLines(content, lineBreaker);\n    //get the report header end index\n    var reportHeaderLastIndex = blockSeporator.getReportHeaderEndIndex(left, tableConfig.reportHeaderLineNumber, lineBreaker);\n    //get the report header string which contains multiple lines\n    reportHeaders = left.substring(0, reportHeaderLastIndex);\n\n    //get the string without the report headers\n    left = left.substring(reportHeaderLastIndex)\n\n    left = dataSanitizer.trimEmptyStartLines(left, this.lineBreaker);\n    var tableHeaderLastIndex = blockSeporator.getTableHeaderEndIndex(left, tableConfig.tableHeaderLineNumber, this.lineBreaker);\n    tableHeaders = if (tableHeaderLastIndex > 0) left.substring(0, tableHeaderLastIndex) else \"\";\n\n    //get the string without the report headers and table headers\n    left = if (tableHeaderLastIndex > 0) left.substring(tableHeaderLastIndex) else \"\"\n\n    if (tableHeaders.length > 0) {\n      left = dataSanitizer.trimEmptyStartLines(left, lineBreaker)\n      tablebodies = blockSeporator.splitTableContentIntoBlocks(tableConfig.blockSeperatorNumber, tableConfig.tableHeaderLineNumber, left, this.lineBreaker)\n      tablebodies = tablebodies.map(block => {\n        organizeBlock(block)\n      })\n    }\n    return (reportHeaders, tableHeaders, tablebodies)\n  }\n\n\n} AbstractProcessor package com.pwc.ds.awm.processor\n\nimport java.sql.Date\nimport java.time.LocalDate\n\nimport com.pwc.ds.awm.processor.OutputMode.Type\nimport com.pwc.ds.awm.processor.reportconfigs.extractorschema.ExtractorConfig\n\nobject OutputMode extends Enumeration {\n  type Type = Value\n  val Excel = Value(\"Excel\")\n  val Memory = Value(\"Memory\")\n}\n\ntrait AbstractProcessor {\n  def readFileAndExtract(sourceFilePath: String, destFilePath: String, mode: Type, extractorConfig: ExtractorConfig, fundName:String, year:Integer): Unit\n\n  def readFileAndExtractToObjectForPeriod(sourceFilePath: String, extractorConfig: ExtractorConfig, fundName: String, frontEndPeriodStart: Date, frontEndPeriodEnd: Date):Any\n}\nConfiguration file\nPositionAppraisalReportConfig import com.pwc.ds.awm.processor.reportconfigs.extractorschema\nimport com.pwc.ds.awm.processor.reportconfigs.extractorschema.{ColumnConfig, DataType, TableConfig}\n\nobject PositionAppraisalReportConfig {\n        var reportName = \"Position appraisal report\"\n\n        var tableHeaderColumns: Seq[Seq[ColumnConfig]] = Seq(\n        Seq(ColumnConfig(\"Portfolio\", -1, -1,span = 1, columnNum = 0, rowNum = 0),\n        ColumnConfig(\"Fund Structure\", -1, -1,span = 1, columnNum = 1, rowNum = 0),\n        ColumnConfig(\"Portfolio Currency\",-1, -1, span = 1, columnNum = 2, rowNum = 0),\n        ColumnConfig(\"Period End Date\",-1, -1, span = 1, columnNum = 3, rowNum = 0, columnType = DataType.Date),\n        ColumnConfig(\"Long/Short\",-1, -1, span = 1, columnNum = 4, rowNum = 0),\n        ColumnConfig(\"Custodian\",-1, -1, span = 1, columnNum = 5, rowNum = 0),\n        ColumnConfig(\"Sort Key\",-1, -1, span = 1, columnNum = 6, rowNum = 0),\n        ColumnConfig(\"Currency\",-1, -1, span = 1, columnNum = 7, rowNum = 0),\n        ColumnConfig(\"Investment\",-1, -1, span = 1, columnNum = 8, rowNum = 0),\n        ColumnConfig(\"Security ID\",-1, -1, span = 1, columnNum = 9, rowNum = 0),\n        ColumnConfig(\"Underlying ID\",-1, -1, span = 1, columnNum = 10, rowNum = 0),\n        ColumnConfig(\"Sedol\",-1, -1, span = 1, columnNum = 11, rowNum = 0),\n        ColumnConfig(\"Isin\",-1, -1, span = 1, columnNum = 12, rowNum = 0),\n        ColumnConfig(\"Cusip\",-1, -1, span = 1, columnNum = 13, rowNum = 0),\n        ColumnConfig(\"Ticker\",-1, -1, span = 1, columnNum = 14, rowNum = 0),\n        ColumnConfig(\"ALT2\",-1, -1, span = 1, columnNum = 15, rowNum = 0),\n        ColumnConfig(\"Quantity\",-1, -1, span = 1, columnNum = 16, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"Local Market Price\",-1, -1, span = 1, columnNum = 17, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"In Element Currency\",-1, -1, span = 1, columnNum = 18, rowNum = 0),\n        ColumnConfig(\"Current Local Cost\",-1, -1, span = 1, columnNum = 19, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"Local Market Value\",-1, -1, span = 1, columnNum = 20, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"Current Book Cost\",-1, -1, span = 1, columnNum = 21, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"Book Market Value\",-1, -1, span = 1, columnNum = 22, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"Book Unrealized Gain/Loss\",-1, -1, span = 1, columnNum = 23, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"% Invest\",-1, -1, span = 1, columnNum = 24, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"% NAV\",-1, -1, span = 1, columnNum = 25, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"Transaction Type\",-1, -1, span = 1, columnNum = 26, rowNum = 0),\n        ColumnConfig(\"Security Exchange Listing\",-1, -1, span = 1, columnNum = 27, rowNum = 0),\n        ColumnConfig(\"Investment Type\",-1, -1, span = 1, columnNum = 28, rowNum = 0),\n        ColumnConfig(\"Country\",-1, -1, span = 1, columnNum = 29, rowNum = 0),\n        ColumnConfig(\"Issue Date\",-1, -1, span = 1, columnNum = 30, rowNum = 0, columnType = DataType.Date),\n        ColumnConfig(\"Client Type\",-1, -1, span = 1, columnNum = 31, rowNum = 0),\n        ColumnConfig(\"Client Residency/Country Code\",-1, -1, span = 1, columnNum = 32, rowNum = 0),\n        ColumnConfig(\"Security Issuer Country Code\",-1, -1, span = 1, columnNum = 33, rowNum = 0),\n        ColumnConfig(\"Exchange Rate\",-1, -1, span = 1, columnNum = 34, rowNum = 0, columnType = DataType.Number),\n        ColumnConfig(\"Notional Cost\",-1, -1, span = 1, columnNum = 35, rowNum = 0),\n        ColumnConfig(\"Swap Book Price\",-1, -1, span = 1, columnNum = 36, rowNum = 0)\n        ));\n\n        var extractorConfig = new extractorschema.ExtractorConfig(reportType = reportName,\n        tableConfig = TableConfig(tableHeaderLineNumber = 1, tableBodyConfig = tableHeaderColumns, reportHeaderLineNumber = 10, blockSeperatorNumber = 1))\n        } ExtractorConfig case class ExtractorConfig (reportType: String,\n                            headerColumns: Seq[Seq[ColumnConfig]] = Seq[Seq[ColumnConfig]](), // report header span config\n        tableConfig: TableConfig,\n        summaryConfig: Option[TableConfig] = None,\n        summarySeparator: String = \"********\",\n        pageLineNumber: Int = 1,\n        nextReportType: String = \"\",\n        tableFirstHeaderWithContent: String = \"\"\n        )","title":"Using OO design"},{"location":"/extractorDesign/index.html#another-way-of-design","text":"Caller method var morganExtractorMap = Map[Seq[String], (AbstractProcessor, ExtractorConfig)](\n  Seq(\"Trial Balance\") -> (new MorganTBProcessor, ReportFundTrialBalanceReportConfig.extractorConfig),\n  Seq(\"Position Appraisal\") -> (new MorganPositionProcessor, LongShortPositionAppraisalReportConfig.extractorConfig),\n  Seq(\"Purchases and Sales\") -> (new MorganPSRProcessor, ReportPurchaseAndSalesConfig.extractorConfig),\n  Seq(\"Ledger movement\") -> (new MorganGLProcessor, ReportPurchaseAndSalesConfig.extractorConfig),\n  Seq(\"Realized Gain Loss\") -> (new MorganRGLProcessor, ReportRealizedGainLossReportConfig.extractorConfig),\n  Seq(\"DAILY CASH EXPOSURE\") -> (new CashExposureReportProcessor, CashExposureReportConfig.extractorConfig),\n  Seq(\"DIVIDEND INCOME AND EXPENSE\") -> (new DividendIncomeAndExpenseReportProcessor, DividendIncomeAndExpenseReportConfig.extractorConfig)\n)\n\n\ndef processFiles(request: Request[MultipartFormData[Files.TemporaryFile]], fundEngagement: FundEngagementData, fund: Fund,\n                 multifondsUploadHelper: MultifondsUploadHelper,\n                 doraServer: DoraServer,\n                 fundEngagementReportTypeSelectionRead: FundEngagementReportTypeSelectionRead,\n                 fundEngagementReportTypeSelectionWrite: FundEngagementReportTypeSelectionWrite): Result = {\n  request.body.file(\"file\").map(file => {\n    ...\n      if (filenames.last == \"xlsx\" || filenames.last == \"xlsm\" || filenames.last == \"xls\") {\n        methodName = \"readFileAndExtractToObjectForPeriod\"\n      } else if (filenames.last == \"pdf\") {\n        methodName = \"readPDFFileAndExtractToObject\"\n      } else {\n        methodName = \"readCSVFileAndExtractToObject\"\n      }\n\n      extractFileAndStoreDataInDB(file.filename, fundEngagement, fund, targetFile.getPath, userEmail, methodName,\n        multifondsUploadHelper,\n        doraServer,\n        fundEngagementReportTypeSelectionRead,\n        fundEngagementReportTypeSelectionWrite)\n    }\n  })\n\n}\n\n\ndef extractFileAndStoreDataInDB(content: String, fundEngagement: FundEngagementData, fund: Fund, targetFilePath: String, userEmail: String, methodName: String,\n                                multifondsUploadHelper: MultifondsUploadHelper,\n                                doraServer: DoraServer,\n                                fundEngagementReportTypeSelectionRead: FundEngagementReportTypeSelectionRead,\n                                fundEngagementReportTypeSelectionWrite: FundEngagementReportTypeSelectionWrite): Result = {\n  //filter the extractorMap with report header\n  var someExtractor = morganExtractorMap\n\n    ...\n  someExtractor.map((kv) => {\n    val periodStart = fund.auditPeriodBegin\n    val periodEnd = fund.auditPeriodEnd\n    val paras = List(targetFilePath, kv._2._2, fund.name, periodStart, periodEnd)\n    val result = doraServer.runProcess(paras, kv._2._1.getClass.getCanonicalName.stripSuffix(\"$\"), methodName)\n    val newStorage = Await.result(result, ConstVar.ProcessJobWaitTime seconds)\n      ...s\n\n  })\n\n\n}\nMorganPSRProcessor import java.sql.Date\nimport com.pwc.ds.awm.const.ExtractionWarningCode\nimport com.pwc.ds.awm.processor.BaseReportProcessor\nimport com.pwc.ds.awm.processor.exceptions.ExtractionWarning\nimport com.pwc.ds.awm.processor.generateEGA.basicReport.{GeneralSingleEGAStorage, MorgenSingleEGAStorage, WarningStatus}\nimport com.pwc.ds.awm.processor.morgan.excelreader.MorganExcelPSRReader\nimport com.pwc.ds.awm.processor.singleegarow.PSRRow.TradeDate\n\nclass MorganPSRProcessor extends BaseReportProcessor {\n  override def extractToObjectForPeriod(sourceFilePath: String, frontEndFundName: String, frontEndPeriodStart: Date, frontEndPeriodEnd: Date): GeneralSingleEGAStorage = {\n    val storage = new MorgenSingleEGAStorage()\n    val psrTable = MorganExcelPSRReader.readPSRSheet(sourceFilePath, frontEndFundName)\n    val (row, rowAE, _) = GeneralSingleEGAStorage.splitTimeRange(psrTable, TradeDate, frontEndPeriodStart, frontEndPeriodEnd)\n    storage.purchaseAndSaleTransactionReportPSRData = row\n    storage.purchaseAndSaleTransactionReportPSRAfterYEData = rowAE\n    if(row.length != 0 && rowAE.length !=0){\n      //throw  ExtractionWarning(ExtractionWarningCode.AFTER_YE_DATA)\n      storage.warningMsg=WarningStatus(true,s\"PSR and PSR (after YE)\")\n    }\n    storage\n  }\n} MorganExcelPSRReader package com.pwc.ds.awm.processor.morgan.excelreader\n\nimport com.pwc.ds.awm.component.excel.{ExcelField, ExcelToArray}\nimport com.pwc.ds.awm.const.ExtractionErrorCode\nimport com.pwc.ds.awm.processor.SSCexcelReport.excelreader.ExcelReaderHelper\nimport com.pwc.ds.awm.processor.SSCexcelReport.excelreader.ExcelReaderHelper.getValueOfExcelField\nimport com.pwc.ds.awm.processor.exceptions.{AWMNameException, ExtractionError}\nimport com.pwc.ds.awm.processor.fargo.excelreader.FargoExcelCashReader.{getFXRate, getLongShortDescription}\nimport com.pwc.ds.awm.processor.singleegarow.PSRRow.{BookAmount, Broker, Commission, ContractDate, CustodianAccount, Expenses, FundCurrenty, GenericInvestment, ISIN, InvestID, Investment, LocalAmount, LocalCurrency, LongShort, Portfolio, Price, Quantity, SEC, Sedol, SettleDate, Ticker, TotalBookAmount, TradeDate, Trader, TranID, TranType}\nimport com.pwc.ds.awm.processor.{NA_STR, convertDateStringToYMDString}\n\nobject MorganExcelPSRReader {\n  val psrHeaderOrg = \"Portfolio ID\\tPortfolio Name\\tCategory Desc1\\tCategory Desc2\\tCUSIP\\tSecurity Description\\tTransaction Category\\tBuy Sell Ind\\tOpen/Close Ind\\tTrade Date\\tSettlement Date\\tDate Acquired\\tIssue Currency\\tQuantity\\tCost Change (Issue)\\tCost Change (Base)\\tLedger Journal Amount(Issue)\\tLedger Journal Amount(Base)\\tNet Amount (Settlement)\\tTransaction Journal Desc\\tOrder No\\tGroup ID\\tLedger Account Number\\tLedger Account Name\\tProcess Date\\tCustodian\\tMoney Manager\\tDeal ID\\tContract ID\\tPosition Type\\tAsset Type\\tAsset Class Level1\\tAsset Class Level2\\tDebit/Credit\\tCancel Ind\\tHas Been Cancelled\\tisManual\"\n  val psrHeader = ExcelReaderHelper.stringNormalizer(psrHeaderOrg)\n\n  def readPSRSheet(filePath:String, fundName:String):Seq[Map[String,String]]={\n    val psrSheet = ExcelToArray.multiSheetToArray(filePath)\n    val psrSheetVerify = ExcelReaderHelper.getSpecifiedSheet(psrSheet,psrHeader)\n    val res= psrSheetVerify.filter(row =>row.length >2 && row(1).field.toLowerCase.trim == fundName.toLowerCase.trim).map{\n      row => createPSRRow(row)\n    }\n    if(psrSheetVerify.length >1 && res.length ==0){\n      throw ExtractionError(ExtractionErrorCode.FUND_NAME_MISMATCH)\n    }\n    res\n  }\n\n  def createPSRRow(row:Seq[ExcelField])={\n    Map(\n      TradeDate -> convertDateStringToYMDString(getValueOfExcelField(row,9)),\n      SettleDate -> convertDateStringToYMDString(getValueOfExcelField(row,10)),\n      TranType -> getValueOfExcelField(row,7),\n      InvestID -> getValueOfExcelField(row,4),\n      Investment -> getValueOfExcelField(row,5),\n      CustodianAccount -> getValueOfExcelField(row,25),\n      Quantity -> getValueOfExcelField(row,13),\n      Price -> NA_STR,\n      SEC -> NA_STR,\n      LocalAmount -> getValueOfExcelField(row,14),\n      BookAmount -> getValueOfExcelField(row,15),\n      ContractDate -> NA_STR,\n      TranID -> getValueOfExcelField(row,28),\n      GenericInvestment ->  getValueOfExcelField(row,32),\n      Broker ->NA_STR,\n      Trader -> NA_STR,\n      Commission ->NA_STR ,\n      Expenses -> NA_STR,\n      LocalCurrency -> getValueOfExcelField(row,12),\n      TotalBookAmount -> NA_STR,\n      Portfolio -> getValueOfExcelField(row,1),\n      FundCurrenty -> NA_STR,\n      LongShort ->getValueOfExcelField(row,23),\n      Sedol -> NA_STR,\n      ISIN -> NA_STR,\n      Ticker -> NA_STR\n    )\n  }\n}","title":"Another way of design"},{"location":"/extractorDesign/index.html#how-to-compare-the-two-ways","text":"The two ways achieves same result.\nThe OO way use a big configuration to control all behaviors. The functions in configuration are:\n1. convert excel to standard input \n2. located the target field in input\n3. extract target input into result\n4. format the result value\nThe another way combines the configuration of different functions.","title":"How to compare the two ways"},{"location":"/extractorDesign/index.html#pdf-different-type","text":"From beginning, we use pdf reader to read pdf contents to text lines:\nRead PDF for type1 def readPDF(sourceFile:String)={\n  extractAllTextFromPdfFile(sourceFile,EmptyConfigForPDF.extractorConfig)\n}\n\ndef extractAllTextFromPdfFile(sourceFilePath: String, reportConfig: ExtractorConfig): String = {\n  try {\n    var content = \"\"\n    if (isPdfFileExtension(sourceFilePath)) {\n      var file = new File(sourceFilePath);\n      val document = PDDocument.load(file);\n      var stripper:LayoutPdfTextStripper = new LayoutPdfTextStripper;\n      stripper.setReportConfig(reportConfig)\n      stripper.setSortByPosition(true);\n      content = stripper.getText(document);\n      document.close()\n    }\n    content\n  } catch {\n    case e: IOException => throw new IOException(\"read source pdf file IO error\")\n    case e: Exception => throw new Exception(JsError(\"read source pdf file IO error\"))\n  }\n}\nThe pdf reader will return text content in formatted way:\nWhile there is another type of pdf which will return unformatted result:\nThen the reader need be change, def readRawPDF(sourceFile:String):String={\n  val document = PDDocument.load(new File(sourceFile))\n  val striper = new PDFTextStripper()\n  striper.setSortByPosition(true)\n  val content = striper.getText(document)\n  document.close()\n  content\n}\nThe result will be:\nThis way return result in line format, but lost formatted information(the space information is lost)\nSo the configuration way has more complex configuration when deal with the different reader. While the combination way will have more flexibility to handle different type of input in different way.","title":"PDF different type"},{"location":"/extractorDesign/index.html#remove-duplicated-code-using-function-programming","text":"Using first way could reduce the duplicated code, but all different processor will increase the configuration file’s complexity to unmanageable. When using the second way will split each configuration to each processor, meanwhile introduce duplicated code in each processor and extractor.\nSo we create a structure to for the generic workflow:\ncase class BasicExcelReader(\n        header: String,\n        filter: Seq[(Seq[ExcelField], String) => Boolean],\n        mapper: Seq[ExcelField] => Map[String, String],\n        readerOpt: Option[String => Seq[Seq[ExcelField]]]\n    )\nCode as below:\nWorkdayProcessor object WorkdayProcessor {\n  val extractorMap = Map[Seq[String], (AbstractProcessor, ExtractorConfig)](\n    Seq(\"TB\") -> (new WorkdayTBProcessor, ReportPurchaseAndSalesConfig.extractorConfig),\n    Seq(\"GL\") -> (new WorkdayGLProcessor, ReportPurchaseAndSalesConfig.extractorConfig)\n  )\n\n  val processFiles = BasicProcessFile.processFiles(extractorMap) _\n\n  val getStorage = BasicProcessFile.getStorageBase(new FundManagerSingleEGAStorage) _\n} TBProcessor class WorkdayTBProcessor extends BaseReportProcessor {\n  override def extractToObjectForPeriod(\n                                         sourceFilePath: String,\n                                         frontEndFundName: String,\n                                         frontEndPeriodStart: Date,\n                                         frontEndPeriodEnd: Date\n                                       ): GeneralSingleEGAStorage = {\n    val storage = new FundManagerSingleEGAStorage()\n    val tableRow = {\n      BasicExcelReaderHelper.processFileOnExcelReader(\n        sourceFilePath,\n        frontEndFundName,\n        WorkdayTBReader.setting\n      )\n    }\n    BasicTBProcessor.processFile(\n      tableRow,\n      frontEndPeriodStart,\n      frontEndPeriodEnd,\n      \"NoUse\",\n      storage\n    )\n  }\n} TBReader object WorkdayTBReader {\n  val headerStr =\n    \"\\tLedger Account\\tTransaction Currency\\tBook Code\\tTransaction Balance\\tLedger Balance\"\n  val lengthFilter      = BasicExcelReaderHelper.basicRowLengthFilter(3)\n  val headerTitleFilter = BasicExcelReaderHelper.basicHeaderTitleFilter(2, \"Transaction Currency\")\n  val emptyFilter       = BasicExcelReaderHelper.basicEmptyFilter(4)\n\n  def createRow(row: Seq[ExcelField]) = {\n    (createTBRowMap() ++ Map(\n      Description_Detail    -> getValueOfExcelField(row, 2),\n      ClosingBalance_Detail -> getValueOfExcelField(row, 4),\n      AccountName           -> getValueOfExcelField(row, 1),\n      Balance               -> getValueOfExcelField(row, 5)\n    )).toMap\n  }\n\n  val setting = BasicExcelReader(\n    headerStr,\n    Seq(lengthFilter, headerTitleFilter, emptyFilter),\n    createRow,\n    None\n  )\n} GLProcessor import java.sql.Date\n\nclass WorkdayGLProcessor extends BaseReportProcessor {\n  override def extractToObjectForPeriod(\n                                         sourceFilePath: String,\n                                         frontEndFundName: String,\n                                         frontEndPeriodStart: Date,\n                                         frontEndPeriodEnd: Date\n                                       ): GeneralSingleEGAStorage = {\n    val storage = new FundManagerSingleEGAStorage()\n    val tableRow =\n      BasicExcelReaderHelper.processFileOnExcelReader(\n        sourceFilePath,\n        frontEndFundName,\n        WorkdayGLReader.setting\n      )\n\n    val currency      = WorkdayGLReader2.getCurrency(sourceFilePath)\n    val groupedRecord = WorkdayGLReader2.getGroupedValue(sourceFilePath)\n    val tableRow2 = BasicExcelReaderHelper.processFileOnExcelReader(\n      sourceFilePath,\n      frontEndFundName,\n      WorkdayGLReader2.setting(currency, groupedRecord)\n    )\n    BasicGLProcessor.processFile(\n      tableRow ++ tableRow2,\n      frontEndPeriodStart,\n      frontEndPeriodEnd,\n      TranDate,\n      storage\n    )\n  }\n} GLReader object WorkdayGLReader {\n  val headerStr =\n    \"\\tLedger/Budget Period\\tJournal\\tJournal Source\\tTransaction\\tAccounting Date\\tLedger Account\\tBook Code\\tTransaction Debit Amount\\tTransaction Credit Amount\\tTransaction Debit minus Credit\\tTransaction Currency\\tJournal Line Exchange Rate\\tLedger/Budget Debit Amount\\tLedger/Budget Credit Amount\\tLedger/Budget Debit minus Credit\\tLedger Currency\\tMemo\\tLine Memo\\tWorktags\"\n  val lenthFilter       = BasicExcelReaderHelper.basicRowLengthFilter(20)\n  val headerTitleFilter = BasicExcelReaderHelper.basicHeaderTitleFilter(2, \"Journal\")\n  val emptyFilter       = BasicExcelReaderHelper.basicEmptyFilter(2)\n\n  def createRow(row: Seq[ExcelField]) = {\n    (createGLRowMap() ++ Map(\n      BeginingBalanceDescriptiton -> getValueOfExcelField(row, 6),\n      TranDate                    -> convertDateStringToYMDString(getValueOfExcelField(row, 5)),\n      TranDescription             -> getValueOfExcelField(row, 19),\n      Currency                    -> getValueOfExcelField(row, 11),\n      LocalAmount                 -> getValueOfExcelField(row, 10),\n      BookAmount                  -> getValueOfExcelField(row, 15)\n    )).toMap\n  }\n\n  val setting = BasicExcelReader(\n    headerStr,\n    Seq(lenthFilter, headerTitleFilter, emptyFilter),\n    createRow,\n    None\n  )\n} GLReader2 object WorkdayGLReader2 {\n  val headerStr =\n    \"Ledger Account\\tJournal Entry\\tCompany\\tJournal Source\\tTransaction\\tAccounting Date\\tMemo\\tDebit\\tCredit\\tBalance\\tNet Amount\"\n  val lengthFilter      = BasicExcelReaderHelper.basicRowLengthFilter(4)\n  val headerTitleFilter = BasicExcelReaderHelper.basicHeaderTitleFilter(1, \"Journal Entry\")\n  val emptyFilter       = BasicExcelReaderHelper.basicEmptyFilter(9)\n\n  def getCurrency(inputFile: String): String = {\n    val seqListValue = BasicExcelReaderHelper.defaultExcelReaderForExcel(headerStr)(inputFile)\n    getValueOfExcelField(seqListValue(6), 1) //Hardcode for header value of \"Translation Currency\"\n  }\n\n  def getGroupedValue(inputFile: String): Map[String, Seq[Seq[ExcelField]]] = {\n    val seqListValue = BasicExcelReaderHelper.defaultExcelReaderForExcel(headerStr)(inputFile)\n    seqListValue.groupBy(list => list(0).field)\n  }\n\n  def getAmount(groupedRecord: Map[String, Seq[Seq[ExcelField]]], account: String): String = {\n    val lastRow = groupedRecord.filter(tempGroup => tempGroup._1 == account).head._2.last\n    getValueOfExcelField(lastRow, 9)\n  }\n\n  def createRow(currency: String, groupedRecord: Map[String, Seq[Seq[ExcelField]]]) =\n    (row: Seq[ExcelField]) => {\n      (createGLRowMap() ++ Map(\n        BeginingBalanceDescriptiton -> getValueOfExcelField(row, 0),\n        TranDate                    -> convertDateStringToYMDString(getValueOfExcelField(row, 5)),\n        TranID                      -> getValueOfExcelField(row, 1),\n        TranDescription             -> getValueOfExcelField(row, 6),\n        Currency                    -> currency,\n        LocalAmount                 -> getValueOfExcelFieldWithDefault(row, 10, Some(\"\")),\n        BookAmount                  -> getValueOfExcelFieldWithDefault(row, 10, Some(\"\")),\n        Balance                     -> getValueOfExcelField(row, 9),\n        EndingBalanceAmount         -> getAmount(groupedRecord, getValueOfExcelField(row, 0))\n      )).toMap\n    }\n\n  def setting = (currency: String, groupedRecord: Map[String, Seq[Seq[ExcelField]]]) => {\n    BasicExcelReader(\n      headerStr,\n      Seq(lengthFilter, headerTitleFilter, emptyFilter),\n      createRow(currency, groupedRecord),\n      None\n    )\n  }\n} BasicExcelReaderHelper object BasicExcelReaderHelper {\n  def processFileOnExcelReader(\n                                filePath: String,\n                                fundName: String,\n                                excelReader: BasicExcelReader\n                              ): Seq[Map[String, String]] = {\n    val reader       = excelReader.readerOpt.getOrElse(defaultExcelReaderForExcel(excelReader.header))\n    val excelContent = reader(filePath)\n    val targetContent = excelReader.filter.foldLeft(excelContent) { (excelContent, filter) =>\n      excelContent.filter(row => filter(row, fundName))\n    }\n    targetContent.map { row =>\n      excelReader.mapper(row)\n    }\n  }\n\n  def defaultExcelReaderForExcel(header: String): String => Seq[Seq[ExcelField]] =\n    (filePath: String) => {\n      val allSheet         = ExcelToArray.multiSheetToArray(filePath)\n      val headerNormalized = ExcelReaderHelper.stringNormalizer(header)\n      ExcelReaderHelper.getSpecifiedSheetWithoutReplacement(allSheet, headerNormalized)\n    }\n\n  def basicRowLengthFilter(length: Int) =\n    (row: Seq[ExcelField], fundName: String) => {\n      row.length >= length\n    }\n\n  def basicHeaderTitleFilter(index: Int, value: String) =\n    (row: Seq[ExcelField], fundName: String) => {\n      row(index).field.toLowerCase.trim != value.toLowerCase.trim\n    }\n\n  def basicEmptyFilter(index: Int) = (row: Seq[ExcelField], fundName: String) => {\n    row(index).field.trim.length > 0\n  }\n}\n\ncase class BasicExcelReader(\n                             header: String,\n                             filter: Seq[(Seq[ExcelField], String) => Boolean],\n                             mapper: Seq[ExcelField] => Map[String, String],\n                             readerOpt: Option[String => Seq[Seq[ExcelField]]]\n                           ) BasicProcessFile import java.io.File\nimport scala.concurrent.Await\n\nobject BasicProcessFile {\n\n  def getStorageBase(singleEGAStorage: GeneralSingleEGAStorage)(\n    selection: Seq[FundEngagementReportTypeSelectionData],\n    sheetTypesReportTypesMapRead: SheetTypesReportTypesMapRead\n  ) = {\n    GeneralSingleEGAHelper.rowToStorage(selection, singleEGAStorage, sheetTypesReportTypesMapRead)\n    singleEGAStorage\n  }\n\n  def extractFileAndStoreDataInDB(\n                                   content: String,\n                                   fundEngagement: FundEngagementData,\n                                   fund: Fund,\n                                   targetFilePath: String,\n                                   userEmail: String,\n                                   methodName: String,\n                                   multifondsUploadHelper: MultifondsUploadHelper,\n                                   doraServer: DoraServer,\n                                   fundEngagementReportTypeSelectionRead: FundEngagementReportTypeSelectionRead,\n                                   fundEngagementReportTypeSelectionWrite: FundEngagementReportTypeSelectionWrite,\n                                   sheetTypesReportTypesMapRead: SheetTypesReportTypesMapRead,\n                                   disabledAfterYEReports: Map[String, Boolean],\n                                   someExtractor: Map[Seq[String], (AbstractProcessor, ExtractorConfig)]\n                                 ): Result = {\n    //filter the extractorMap with report header\n    //var someExtractor = morganExtractorMap\n\n    var warningMsg: Seq[Result] = Seq()\n    var exceptions: Seq[Result] = Seq()\n    var noWarning: Seq[Result]  = Seq()\n    var allEmpty                = true\n    someExtractor.map((kv) => {\n      val periodStart = fund.auditPeriodBegin\n      val periodEnd   = fund.auditPeriodEnd\n      val paras       = List(targetFilePath, kv._2._2, fund.name, periodStart, periodEnd)\n      val result = doraServer.runProcess(\n        paras,\n        kv._2._1.getClass.getCanonicalName.stripSuffix(\"$\"),\n        methodName\n      )\n      val newStorage = Await.result(result, ConstVar.ProcessJobWaitTime seconds)\n      try {\n        //check whether the result has exception\n        multifondsUploadHelper.checkJobResultException(newStorage)\n        if (newStorage.result.isInstanceOf[ProcessResult]) {\n          val newStorageResult = newStorage.result.asInstanceOf[ProcessResult]\n          if (newStorageResult.jobStatus.toString != \"Failed\") {\n            if (newStorageResult.result.isInstanceOf[GeneralSingleEGAStorage]) {\n              if (\n                newStorageResult.result.asInstanceOf[GeneralSingleEGAStorage].isStorageNotEmpty()\n              ) {\n                allEmpty = false\n              }\n              filterAfterYEDataSH(\n                newStorageResult.result.asInstanceOf[GeneralSingleEGAStorage],\n                disabledAfterYEReports\n              )\n              //store the extracted data in database\n              Await.result(\n                GeneralSingleEGAHelper.exportExcelToDatabase(\n                  newStorageResult.result.asInstanceOf[GeneralSingleEGAStorage],\n                  fundEngagement.id,\n                  userEmail,\n                  fundEngagementReportTypeSelectionRead,\n                  fundEngagementReportTypeSelectionWrite,\n                  sheetTypesReportTypesMapRead\n                ),\n                100 seconds\n              )\n              if (newStorageResult.result.asInstanceOf[GeneralSingleEGAStorage].errorMsg.hasError) {\n                return BadRequest(\n                  newStorageResult.result.asInstanceOf[GeneralSingleEGAStorage].errorMsg.Msg\n                )\n              }\n              val res = Ok(\n                \"Extract Success\" + \",\" + newStorageResult.result\n                  .asInstanceOf[GeneralSingleEGAStorage]\n                  .warningMsg\n                  .Msg + \",\" + fund.name + \",\" + periodStart + \",\" + periodEnd\n              )\n              if (\n                newStorageResult.result\n                  .asInstanceOf[GeneralSingleEGAStorage]\n                  .warningMsg\n                  .Msg\n                  .length > 0\n              ) {\n                val warningMsgs =\n                  newStorageResult.result.asInstanceOf[GeneralSingleEGAStorage].warningMsg\n                warningMsg = ModelChangeHelper\n                  .handleOldWarningMsgToWarningObject(warningMsgs, warningMsg, fund)\n              } else {\n                noWarning = noWarning :+ res\n              }\n            } else {\n              exceptions :+= encapErrorResponse(\n                UnprocessableEntity,\n                ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION\n              )\n\n            }\n          }\n        } else {\n          exceptions :+= encapErrorResponse(\n            UnprocessableEntity,\n            ExtractionErrorCode.UNRECOGNISED_ERROR\n          )\n        }\n      } catch {\n        //        case e:ExtractionWarning=>{\n        //          Ok( Json.obj(\"errorCodes\" -> Seq(e.errorCode).distinct))\n        //        }\n        case e: ExtractionError => {\n          encapErrorResponse(\n            UnprocessableEntity,\n            e.errorCode\n          )\n        }\n        case e: Exception => {\n          if (e.getMessage.indexOf(\"no newline character detected\") < 0) {\n            encapErrorResponse(\n              UnprocessableEntity,\n              ExtractionErrorCode.UNRECOGNISED_ERROR\n            )\n          }\n        }\n      }\n    })\n\n    if (exceptions.length > 0) {\n      exceptions(0)\n    } else if (warningMsg.length > 0) {\n      warningMsg(0)\n    } else if (allEmpty == true) {\n      encapErrorResponse(\n        UnprocessableEntity,\n        ExtractionErrorCode.UNRECOGNISED_ERROR\n      )\n    } else {\n      noWarning(0)\n    }\n  }\n\n  def processFiles(someExtractor: Map[Seq[String], (AbstractProcessor, ExtractorConfig)])(\n    request: Request[MultipartFormData[Files.TemporaryFile]],\n    fundEngagement: FundEngagementData,\n    fund: Fund,\n    multifondsUploadHelper: MultifondsUploadHelper,\n    doraServer: DoraServer,\n    fundEngagementReportTypeSelectionRead: FundEngagementReportTypeSelectionRead,\n    fundEngagementReportTypeSelectionWrite: FundEngagementReportTypeSelectionWrite,\n    sheetTypesReportTypesMapRead: SheetTypesReportTypesMapRead,\n    disabledAfterYEReports: Map[String, Boolean]\n  ): Result = {\n    request.body\n      .file(\"file\")\n      .map(file => {\n        val userEmail  = request.session.get(\"email\").getOrElse(\"\")\n        val sourceFile = file.ref.toFile\n        val filenames  = file.filename.split('.')\n        if (filenames.length <= 1) {\n          encapErrorResponse(\n            UnprocessableEntity,\n            ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION\n          )\n        } else {\n          val targetFile = new File(s\"${sourceFile.getPath}.${filenames.last}\")\n          sourceFile.renameTo(targetFile)\n          var methodName = \"\"\n\n          if (filenames.last == \"xlsx\" || filenames.last == \"xlsm\" || filenames.last == \"xls\") {\n            methodName = \"readFileAndExtractToObjectForPeriod\"\n          } else if (filenames.last == \"pdf\") {\n            methodName = \"readPDFFileAndExtractToObject\"\n          } else {\n            methodName = \"readCSVFileAndExtractToObject\"\n          }\n\n          extractFileAndStoreDataInDB(\n            file.filename,\n            fundEngagement,\n            fund,\n            targetFile.getPath,\n            userEmail,\n            methodName,\n            multifondsUploadHelper,\n            doraServer,\n            fundEngagementReportTypeSelectionRead,\n            fundEngagementReportTypeSelectionWrite,\n            sheetTypesReportTypesMapRead,\n            disabledAfterYEReports,\n            someExtractor\n          )\n        }\n      })\n      .getOrElse(\n        encapErrorResponse(\n          UnprocessableEntity,\n          ExtractionErrorCode.UNRECOGNISED_ERROR\n        )\n      )\n  }\n}\nFor all Excel file, go throw filter=>mapper process as above.\nFor GL type 1 fil as blow:\nthe code will work perfectly to extract all information using one Excel row:\ndef createRow(row: Seq[ExcelField]) = {\n    (createGLRowMap() ++ Map(\n      BeginingBalanceDescriptiton -> getValueOfExcelField(row, 6),\n      TranDate                    -> convertDateStringToYMDString(getValueOfExcelField(row, 5)),\n      TranDescription             -> getValueOfExcelField(row, 19),\n      Currency                    -> getValueOfExcelField(row, 11),\n      LocalAmount                 -> getValueOfExcelField(row, 10),\n      BookAmount                  -> getValueOfExcelField(row, 15)\n    )).toMap\n  }\nBut for GL type2 input:\nThere is need another input for currency and EndingBalanceAmount need additional information, but we don’t want to change interface, then curry is used:\ndef getGroupedValue(inputFile: String): Map[String, Seq[Seq[ExcelField]]] = {\n    val seqListValue = BasicExcelReaderHelper.defaultExcelReaderForExcel(headerStr)(inputFile)\n    seqListValue.groupBy(list => list(0).field)\n  }\n\n  def getAmount(groupedRecord: Map[String, Seq[Seq[ExcelField]]], account: String): String = {\n    val lastRow = groupedRecord.filter(tempGroup => tempGroup._1 == account).head._2.last\n    getValueOfExcelField(lastRow, 9)\n  }\n\n  def createRow(currency: String, groupedRecord: Map[String, Seq[Seq[ExcelField]]]) =\n    (row: Seq[ExcelField]) => {\n      (createGLRowMap() ++ Map(\n        BeginingBalanceDescriptiton -> getValueOfExcelField(row, 0),\n        TranDate                    -> convertDateStringToYMDString(getValueOfExcelField(row, 5)),\n        TranID                      -> getValueOfExcelField(row, 1),\n        TranDescription             -> getValueOfExcelField(row, 6),\n        Currency                    -> currency,\n        LocalAmount                 -> getValueOfExcelFieldWithDefault(row, 10, Some(\"\")),\n        BookAmount                  -> getValueOfExcelFieldWithDefault(row, 10, Some(\"\")),\n        Balance                     -> getValueOfExcelField(row, 9),\n        EndingBalanceAmount         -> getAmount(groupedRecord, getValueOfExcelField(row, 0))\n      )).toMap\n    }","title":"Remove duplicated code using function programming"},{"location":"/extractorDesign/index.html#bug-in-processor-design","text":"There is bug in processor design for getStorage function\nobject WorkdayProcessor {\n  val extractorMap = Map[Seq[String], (AbstractProcessor, ExtractorConfig)](\n    Seq(\"TB\") -> (new WorkdayTBProcessor, ReportPurchaseAndSalesConfig.extractorConfig),\n    Seq(\"GL\") -> (new WorkdayGLProcessor, ReportPurchaseAndSalesConfig.extractorConfig)\n  )\n\n  val processFiles = BasicProcessFile.processFiles(extractorMap) _\n\n  //What's will be when create an instance in val\n  val getStorage = BasicProcessFile.getStorageBase(new FundManagerSingleEGAStorage) _\n}\nneed change to\nobject WorkdayProcessor {\n  val extractorMap = Map[Seq[String], (AbstractProcessor, ExtractorConfig)](\n    Seq(\"TB\") -> (new WorkdayTBProcessor, ReportPurchaseAndSalesConfig.extractorConfig),\n    Seq(\"GL\") -> (new WorkdayGLProcessor, ReportPurchaseAndSalesConfig.extractorConfig)\n  )\n\n  val processFiles = BasicProcessFile.processFiles(extractorMap) _\n\n  def getStorage = BasicProcessFile.getStorageBase(new FundManagerSingleEGAStorage) _\n}\nIf the getStorage is val, then the “new FundManagerSingleEGAStorage” will only create once.","title":"Bug in processor design"},{"location":"/bugs/index.html","text":"","title":"Bugs"},{"location":"/bugs/index.html#bugs","text":"Unexpected value show up Page can’t retrieve Add features leads system fail Wrong notification Hosting issue for IE Number add for round up Function and Val in code Excel formula issue nginx config for domain Regex failed in frontend Most awful code when use OO Java related Load issue for valuation Read PDF Redundant DB operation project status update issue UI crash UI test Statistics load issue Initial crash","title":"Bugs"},{"location":"/bugs/unexpectedvalue/index.html","text":"","title":"Unexpected value show up"},{"location":"/bugs/unexpectedvalue/index.html#unexpected-value-show-up","text":"","title":"Unexpected value show up"},{"location":"/bugs/unexpectedvalue/index.html#issue","text":"","title":"Issue"},{"location":"/bugs/unexpectedvalue/index.html#whats-the-bug-about-","text":"From very beginning the “Noncurrent assets” is a col which user could input value. As client’s request, the field is promoted to title of section which can’t accept user’s input.\nFrontend code export const BalanceSheetDataRows_asset_subtitle:string[] = [\n    \"current_assets\",\n    \"noncurrent_assets\",  //The col is a subtitle\n]\n\n  const Rule_total_noncurrent_assets:Calculation = {\n      resultRowKey:\"total_noncurrent_assets\",\n      rule:[\n          {\n              rowKey:\"available_for_sale\",\n              type:\"plus\"\n          },{\n              rowKey:\"held_to_maturity\",\n              type:\"plus\"\n          },\n          {\n              rowKey:\"longterm_equity_investment\",\n              type:\"plus\"\n          },{\n              rowKey:\"longterm_debt_investment\",\n              type:\"plus\"\n          },{\n              rowKey:\"other_equity_instrument_investment\",\n              type:\"plus\"\n          },{\n              rowKey:\"fixed_assets_net_of_AD_and_impairment\",\n              type:\"plus\"\n          },{\n              rowKey:\"fixed_assets_to_be_disposed\",\n              type:\"plus\"\n          },{\n              rowKey:\"construction_materials\",\n              type:\"plus\"\n          },{\n              rowKey:\"construction_in_progress\",\n              type:\"plus\"\n          },{\n              rowKey:\"intangible_assets_net_of_amortization\",\n              type:\"plus\"\n          },{\n              rowKey:\"development_cost\",\n              type:\"plus\"\n          },{\n              rowKey:\"goodwill\",\n              type:\"plus\"\n          },{\n              rowKey:\"long_term_prepayments\",\n              type:\"plus\"\n          },{\n              rowKey:\"long_term_receivable\",\n              type:\"plus\"\n          },{\n              rowKey:\"deferred_assets\",\n              type:\"plus\"\n          },{\n              rowKey:\"other_noncurrent_assets\",\n              type:\"plus\"\n          },{\n              rowKey:\"deferred_tax_assets\",\n              type:\"plus\"\n          },\n      ]\n  }\n Backend code val passiveAssetRelatedRows = Seq(\"cash_and_cash_equivalents\",\n  \"shortterm_marketable_securities\",\n  \"shortterm_debt_investment\",\n  \"notes_receivable\",\n  \"dividend_receivable\",\n  \"interest_receivable\",\n  \"other_receivables\",\n  \"current_portion_of_longterm_debt_investment\",\n  \"other_current_assets\",\n  \"noncurrent_assets\", // The col could be added\n  \"available_for_sale\",\n  \"held_to_maturity\",\n  \"longterm_equity_investment\",\n  \"longterm_debt_investment\",\n  \"other_equity_instrument_investment\",\n  \"long_term_receivable\",\n  \"other_noncurrent_assets\")\nFrontend code shows the “Noncurrent assets” is title which can’t be modified, while the backend code still keep the filed as original design. The “Noncurrent assets” is the title of section, which is not available for user’s input.\nSo user could not input the value of “Noncurrent assets” in frontend page. The inconsistent can’t be detected.\nWhen new feature added that user can input via excel file upload:\nThen the bug happens.","title":"What’s the bug about?"},{"location":"/bugs/unexpectedvalue/index.html#whats-cause-for-the-bug-","text":"From the implementation code. We could see there are two rule logic on both frontend and backend.\nFor frontend, user need to see instant value change. The backend contains another rule for the subset of the data.\nHow to avoid such issue:\nMove the logic to backend.","title":"What’s cause for the bug."},{"location":"/bugs/pagecantget/index.html","text":"","title":"Page cant retrieve"},{"location":"/bugs/pagecantget/index.html#page-cant-retrieve","text":"","title":"Page can’t retrieve"},{"location":"/bugs/pagecantget/index.html#page-cant-get-when-using-idam","text":"In PFIC system, in UAT environment, the page can’t be retrieved:\nBut in another environment, the login function works well.\nAnd if disable IdAM service, the login function also works.\nThe IdAM service works in local.\nThen the chrome log shows:","title":"Page can’t get when using IdAM"},{"location":"/bugs/pagecantget/index.html#whats-happened-","text":"The UAT nginx server has configuration of a rule for security check:\nadd_header Content-Security-Policy \"default-src 'self' cdn.plyr.io; style-src 'self' 'unsafe-inline'; script-src 'self' www.googletagmanager.com; img-src 'self' data:\" always;\nBut for “www.googletagmanager.com” the sha value will change from time to time.\nSo the integrity value is removed:\nSo the nginx will block the page, and chrome will not load the page correctly.","title":"What’s happened?"},{"location":"/bugs/addfeature/index.html","text":"","title":"Add features leads system fail"},{"location":"/bugs/addfeature/index.html#add-features-leads-system-fail","text":"","title":"Add features leads system fail"},{"location":"/bugs/addfeature/index.html#investor-list-function-failed","text":"User reports the list investor feature failed:\nThe following change cause the bug:\nAfter the change the request url will be:\nWhat’s the code for the query:\nController import scala.concurrent.Future\n\ndef queryPage(page: Int, pageSize: Int, name: Option[String], country: Option[String], city: Option[String], sorterfield: Option[String], sorterorder: Option[String], investorType: Option[String], includeInActive: Option[Boolean]) =\n  deadbolt.Pattern(value = \"(v_pwc)|(v_myfi)\", patternType = PatternType.REGEX)() { implicit request => {\n  ParameterCheck.pageChecker(page,pageSize)\n  var filterMap = Map[String, String]()\n  name.map(someName => filterMap += (\"name\" -> someName))\n  country.map(someCountry => filterMap += (\"country\" -> someCountry))\n  city.map(someCity => filterMap += (\"city\" -> someCity))\n  investorType.map(someType => filterMap += (\"investorType\" -> someType))\n  includeInActive.map(include => filterMap += (\"includeInActive\" -> include.toString))\n  investorServiceRead.listPage(page, pageSize, filterMap, sorterfield, sorterorder).map(page => {\n    Ok(Json.obj(\"investors\" -> Json.toJson(page.items), \"total\" -> page.total))\n  })\n}\n} InvestorUserDao import scala.concurrent.Future\n\ndef listPage(pageNum: Int = 0, pageSize: Int = 10, filterMap: Map[String, String], sortField: Option[String], sortOrder: Option[String]): Future[Page[Investoruser]] = {\n\n  val offset = pageSize * (pageNum - 1)\n\n  var filteredQuery = Investorusers.filter { user => filterMap.get(\"city\").map(someCity => user.city.asColumnOf[String] like s\"%$someCity%\").getOrElse(true: Rep[Boolean]) }\n    .filter { user => filterMap.get(\"name\").map(f = someName => user.name like s\"%$someName%\").getOrElse(true: Rep[Boolean]) }\n    .filter { user => filterMap.get(\"includeInActive\").map(includes => {\n      if(includes == \"true\"){\n        true: Rep[Boolean]\n      }else{\n        user.activestatus === true\n      }\n    }).getOrElse(user.activestatus === true)} // not include inactive investor user by default\n\n  if(filterMap.get(\"investorType\").nonEmpty){\n    var investorType = InvestorType.getIntInvestorType(filterMap.get(\"investorType\"))\n    filteredQuery = filteredQuery.filter(_.investorType === investorType)\n  }\n\n  var oder = sortOrder.map({\n    _ match {\n      case \"ascend\" => Ordering(Ordering.Asc)\n      case _ => Ordering(Ordering.Desc)\n    }\n  })\n  var columnOrder = ColumnOrdered[String](_: Rep[String], Ordering(Ordering.Asc));\n  val sortQuery = sortField match {\n    case Some(\"name\") => filteredQuery.sortBy(_.name)(columnOrder)\n    case Some(\"city\") => filteredQuery.sortBy(_.city.asColumnOf[String])(columnOrder)\n    case _ => filteredQuery.sortBy(_.createdAt.desc)\n  }\n\n  var query = sortQuery.drop(offset).take(pageSize)\n  for {\n    totalRows <- db.run(filteredQuery.length.result)\n    result <- db.run(query.result).map(rows => rows.collect { case userRow => convertUseRowToUser(userRow) })\n  } yield Page(result, pageNum, offset, totalRows)\n}\nWhat’s the value in passed in the search is:\nActually, there are some tricky value generated:\nsortField,sortOrder is Some() , while in DAO, these fields are handled correctly.\n\nWhile in filterMap, the \"investorType\" value is \"\", which is not handle correctly.\nThe bug is very obviously, the skipNull option in stringify function will remove null query parameters. After removed this option, the query url contains some empty parameters, the DB query can’t handle some cases.\nThe more question will be asked is how to avoid Some() or Some(null), Map(“a”->\"\") in user’s input.","title":"Investor list function failed"},{"location":"/bugs/addfeature/index.html#upload-function-is-blocked","text":"User report the upload function is broken when apply a new feature:\nWhile the log in backend is:\nThe bug is more obvious:\nUpload controller import java.io.{ByteArrayOutputStream, FileInputStream}\nimport java.nio.file.{Files, Paths}\nimport java.util.Calendar\nimport java.util.UUID.randomUUID\nimport javax.sql.rowset.serial.SerialBlob\nimport scala.concurrent.{Await, Future, duration}\nimport scala.concurrent.duration.Duration\n\ndef uploadOriginalFile(year: Int, companyId: String, uploaderType: String, operationType: String) = Action.andThen(ipRateLimitFilterPerDay).async(parse.multipartFormData(maxLength = 1024 * 1024 * 1)) { implicit request =>\n  ...\n  val financialData = Await.result(companyfinancialdataServiceRead.lookup(companyId, year), 10 second)\n\n  var financialDataFromFrontEnd: FinancialdataGetFromFrontend = FinancialdataGetFromFrontend.financialDataToFrontEnd(financialData.get, operationType)\n  var companyUser = companyuserServiceRead.waitForLookup(companyId)\n  /**\n   * Financial Data Ratio.\n   */\n  val workbook = WorkbookFactory.create(filetest)\n  val financialDataSource = FinancialDataUtils.extractFinancialDataFromFile(workbook)\n\n}.getOrElse(Future(BadRequest(\"Unable to Read File\"))) val fdSourceStr = Json.toJson(financialDataSource).toString()\n\n...\ncompanyNameCell.setCellValue(companyName)\nval yearCell = sheet.getRow(3).getCell(1)\nyearCell.setCellValue(yearStr)\nval bstream = new ByteArrayOutputStream()\nratioWB.write(bstream)\nval ratioFileContent = new SerialBlob(bstream.toByteArray)\n/**\n * End of Financial Ratio.\n */\n\nvar inputStream = new FileInputStream(filetest)\nvar byteArray = FileUtils.inputStreamToByte(inputStream)\nvar fileContentId = randomUUID().toString\nvar fileContent = new OriginalFinancialFileContent(fileContentId, file.filename, new javax.sql.rowset.serial.SerialBlob(byteArray), Some(fdSourceStr), Some(ratioResultStr), Some(ratioFileContent))\nvar fileRecord = new OriginalFinancialFile(randomUUID().toString, \"\", financialDataFromFrontEnd.year, financialDataFromFrontEnd.companyId.toString, file.filename, fileContentId, true, emailOption, Some(TimeService.currentTime))\n\n} Code from a new feature def extractBalanceSheetFromExcel(workbook: Workbook) = {\n  val balanceSheet = workbook.getSheet(\"Balance Sheet\")\n  val (assetStartRow: Int, assetStartColumn: Int) = ExcelReader.findExcelRowAndColumnWithCellValue(balanceSheet, \"Current assets\", true)\n  val (assetEndRow: Int, _: Int) = ExcelReader.findExcelRowAndColumnWithCellValue(balanceSheet, \"Total assets\", true)\n    ...\n}\nThe upload function is an existed feature in our system. After that new feature is added to process specified type of Excel document.\nThen Excel file not match the new feature will fail.","title":"Upload function is blocked"},{"location":"/bugs/wrongnotification/index.html","text":"","title":"Wrong notification"},{"location":"/bugs/wrongnotification/index.html#wrong-notification","text":"","title":"Wrong notification"},{"location":"/bugs/wrongnotification/index.html#issue","text":"The client complains that the notification message is send to some internal user but the user login to system they can’t find pending task\nSubject: FW: PFIC system notification\n\nHi Steven,\n\nPlease find below feedback from our team member.  Could you please check if there is any update to email notification since we update the setting to approver of mapping rules?\n\nBest regards,\nPenny\nHow this bug introduces?\nInternal user (reviewer or approver) could see all notification from all engagements at first. And notification email will send to all internal users.\ndef queryForApprover(lastSendTimestampString: String)={\n  var  notificationFilter = Map[String,String]()\n  notificationFilter +=(\"notificationType\" -> NotificationType.approver.toString)\n  notificationFilter +=(\"timestamp\" -> lastSendTimestampString)\n  notificationRead.listNotifications(notificationFilter).map{\n    notificationSeq => if(notificationSeq.length >0){\n      Logger.debug(\"Send mail to approver\")\n      sendMailToRole(\"PwCApprover\")\n    }\n  }\n}\n\n\ndef sendMailToRole(roleStr:String)={\n  var  userFilter = Map[String,String]()\n  userFilter +=(\"enable\" ->\"true\")\n  userFilter += (\"role\"->roleStr)\n  userRead.userFilterQuery(userFilter).map{\n    seqUser=> val emailSeq = seqUser.map{\n      user => user.email\n    }\n      emailSeq.map{\n        emailTmp =>\n          val email = mailSender.getTestEmail(Seq(emailTmp))\n          mailSender.sendEmail(email)\n      }\n      println(s\"send mail to $emailSeq\")\n  }\n}\nFor the internal user notification, the client want to only engagement user could see the notification. The UI part of the filter is enabled:\nimport scala.concurrent.Future\ndef listNotification(notificationDataType:Option[NotificationDataType.NotificationDataType],year:Option[Int], entityId:Option[String]) = deadbolt.SubjectPresent()(parse.anyContent) {request => {\n  ...\n  notificationServiceRead.listNotifications(filterMap).flatMap(notifications => {\n    if (isPwC || isPwCRE || isPwCAP || isAdmin) {\n      notificationServiceRead.filterInternalNotifications(notifications, request.session.get(\"email\").getOrElse(\"\"))\n    } else Future(notifications)\n  })\n}\n\noverride def filterInternalNotifications(notifications: Seq[Notification], email: String): Future[Seq[Notification]] = {\n  userRead.getUser(Some(email)).flatMap(usero => {\n    usero.map(user => {\n      userFundServiceRead.lookupFundsByUserId(user.id, Map()).map(funds => {\n        notifications.filter(notification => {\n          notification.notificationDataType match {\n            case NotificationDataType.fiInvestment | NotificationDataType.agreedFiInvestment | NotificationDataType.disagreedFiInvestment |\n                 NotificationDataType.externalFiInvestment | NotificationDataType.investorInvestment | NotificationDataType.externalInvestorInvestment |\n                 NotificationDataType.agreedInvestorInvestment | NotificationDataType.disagreedInvestorInvestment | NotificationDataType.statementWorkpaper => {\n              funds.find(_.id == notification.link).nonEmpty\n            }\n            case NotificationDataType.financialData | NotificationDataType.agreedFinancialData | NotificationDataType.disagreedFinancialData | NotificationDataType.externalFinancialData | NotificationDataType.externalFundFinancialFile => {\n              Await.result(userFundServiceRead.verifyForComapany(email, notification.link, Some(notification.year)), 10 seconds)\n            }\n            case _ => true\n          }\n        })\n      })\n    }).getOrElse(Future(notifications))\n  })\n}\n}\nWhile this change applied, only specified user could see the notification, and other user will still get notification by email because email send is using role base.\nHow to fix:\nimport scala.concurrent.Future\n\ndef sendMailToRole(roleStr: String, notifications: Seq[Notification]) = {\n  var userFilter = Map[String, String]()\n  userFilter += (\"enable\" -> \"true\")\n  userFilter += (\"role\" -> roleStr)\n  userRead.userFilterQuery(userFilter).map {\n    seqUser =>\n      val emailSeq = seqUser.map {\n        user => user.email\n      }\n      Future.sequence(emailSeq.map {\n        emailTmp =>\n          val filterdNotificaionF = notificationServiceRead.filterInternalNotifications(notifications, emailTmp)\n          filterdNotificaionF.map {\n            filterdNotificaion =>\n              if (filterdNotificaion.length > 0) {\n                val email = mailSender.getTestEmail(Seq(emailTmp))\n                mailSender.sendEmail(email)\n              }\n          }\n      })\n  }.flatten\n}","title":"Issue"},{"location":"/bugs/ieissue/index.html","text":"","title":"Hosting issue for IE"},{"location":"/bugs/ieissue/index.html#hosting-issue-for-ie","text":"","title":"Hosting issue for IE"},{"location":"/bugs/ieissue/index.html#issue-for-ie","text":"The site can open in IE as\nand can’t be loaded when reopen the same link:\nThis behavior can’t be reproduced when the site is hosted in python server.","title":"Issue for IE"},{"location":"/bugs/ieissue/index.html#fix-the-issue","text":"IE don’t support flat operation.","title":"Fix the issue"},{"location":"/bugs/numberAdd/index.html","text":"","title":"Number add for round up"},{"location":"/bugs/numberAdd/index.html#number-add-for-round-up","text":"","title":"Number add for round up"},{"location":"/bugs/numberAdd/index.html#issue-found","text":"The parent company has two types share, and the child company need to display the total of two types share value. For the round up issue, the number is not equal.","title":"Issue found"},{"location":"/bugs/numberAdd/index.html#code","text":"Original code if(parentInvesment.companyId == company.id || companyInvestment.data.flatMap(_.valueOfShares).isDefined){ //parentInvestment uses this company id, means this is parentCompany, so show separate value of shares.\n  firstValueOfShares = PficReportCalculator.formatDecimalIntoIntString(Some(investorEndingCommitment * companyInvestment.data.flatMap(_.valueOfShares).getOrElse(BigDecimal(0))), \"0\")\n  secondValueOfShares = PficReportCalculator.formatDecimalIntoIntString(Some(investorEndingCommitment * companyInvestment.data.flatMap(_.secondValueOfShares).getOrElse(BigDecimal(0))), \"0\")\n}\nelse { //it's child company. both value of shares show seenotes, show proRataShareOfShareholder of total parent valueOfShares in the note.\n  val totalValueOfShares:BigDecimal = parentInvesment.data.flatMap(_.valueOfShares).getOrElse(BigDecimal(0)) + parentInvesment.data.flatMap(_.secondValueOfShares).getOrElse(BigDecimal(0))\n}\n\n\n\ndef formatDecimalIntoIntString(number: Option[BigDecimal], noneString: String): String = {\n  number match {\n    case Some(value) => {\n      roundUpBigDecimal(value)\n    }\n    case _ => noneString\n  }\n}\n\ndef roundUpBigDecimal(value: BigDecimal): String = {\n  val decimalFormat: DecimalFormat = new DecimalFormat(\"#,##0\")\n  var roundUp = value.setScale(0, BigDecimal.RoundingMode.HALF_UP)\n  decimalFormat.format(roundUp)\n} Fix code if(parentInvesment.companyId == company.id || companyInvestment.data.flatMap(_.valueOfShares).isDefined){ //parentInvestment uses this company id, means this is parentCompany, so show separate value of shares.\n  firstValueOfShares = PficReportCalculator.formatDecimalIntoIntString(Some(investorEndingCommitment * companyInvestment.data.flatMap(_.valueOfShares).getOrElse(BigDecimal(0))), \"0\")\n  secondValueOfShares = PficReportCalculator.formatDecimalIntoIntString(Some(investorEndingCommitment * companyInvestment.data.flatMap(_.secondValueOfShares).getOrElse(BigDecimal(0))), \"0\")\n}\nelse {\n  val totalValueOfShares = (parentInvesment.data.flatMap(_.valueOfShares).getOrElse(BigDecimal(0)) * investorEndingCommitment).setScale(0, BigDecimal.RoundingMode.HALF_UP) +\n    (parentInvesment.data.flatMap(_.secondValueOfShares).getOrElse(BigDecimal(0)) *investorEndingCommitment).setScale(0, BigDecimal.RoundingMode.HALF_UP)\n}","title":"code"},{"location":"/bugs/functionandval/index.html","text":"","title":"Function and Val in code"},{"location":"/bugs/functionandval/index.html#function-and-val-in-code","text":"","title":"Function and Val in code"},{"location":"/bugs/functionandval/index.html#issue","text":"In scala function and val are quiet equal as below:\ndef f1 = (a: Int) => { a *2} val f1 = (a: Int) => { a *2}\nIn some case the two will have different feature:\nWhen use function, every thing as expected:\nWhen use val, the null pointer error show up:\nThe code as below:\nExtractorConfig import io.github.jonathanlink.PDFLayoutTextStripper\nimport org.apache.pdfbox.pdmodel.PDDocument\n\nimport java.io.File\n\ncase class HSBCMFLikeExtractor(\n                                removeHeader: Seq[String],\n                                splitPosition: Seq[Int],\n                                trimContentLine: Option[Int] = None,\n                                tableToRecode: Option[(Seq[String], Int) => Seq[Seq[String]]] = None,\n                                splitSeq: Seq[(Int, (String => Seq[String]))] = Seq()\n                              )\n\nobject HSBCMFLikeExtractor {\n  def getContentStr(filePath: String) = {\n    val file        = new File(filePath);\n    val document    = PDDocument.load(file);\n    val pdfStripper = new PDFLayoutTextStripper()\n    pdfStripper.getText(document)\n  }\n\n  def getTableContent(listStr: Seq[String], removeStr: Seq[String]) = {\n    val items = splitByEmptyLine(listStr)\n    items.filter(item => {\n      removeStr.foldLeft(true)((b, str1) => b && item(0).indexOf(str1) < 0)\n    })\n  }\n\n  private def splitByEmptyLine(listStr: Seq[String]): Seq[Seq[String]] = {\n    var res     = Seq[Seq[String]]()\n    var tempRes = Seq[String]()\n    for (line <- listStr) {\n      if (line.trim().length == 0) {\n        if (tempRes.length > 0) {\n          res = res :+ tempRes\n          tempRes = Seq()\n        }\n      } else {\n        tempRes = tempRes :+ line\n      }\n    }\n    if (tempRes.length > 0) {\n      res = res :+ tempRes\n    }\n    res\n  }\n\n  private def getModifiedSplitPoint(strLine: String, splitPoint: Seq[Int]) = {\n    splitPoint.map { point =>\n      var pointTemp = point - 1\n      while (pointTemp < strLine.length - 1 && strLine(pointTemp) != ' ') {\n        pointTemp = pointTemp + 1\n      }\n      pointTemp\n    }\n  }\n\n  //suppose every record has the one none-empty beginning value for the record number at line 1.\n  val splitTableToRecords = (tableStr: Seq[String], sectionIndex: Int) => {\n    var res: Seq[Seq[String]] = Seq()\n    var tempRes: Seq[String]  = Seq()\n    for (line <- tableStr) {\n      if (line.substring(0, sectionIndex).trim.length != 0 && tempRes.length > 0) {\n        res = res :+ tempRes\n        tempRes = Seq(line)\n      } else {\n        tempRes = tempRes :+ line\n      }\n    }\n    if (tempRes.length > 0) {\n      res = res :+ tempRes\n    }\n    res\n  }\n\n  def splitLine(\n                 strLine: String,\n                 splitPoint: Seq[Int],\n                 splitFunSeq: Seq[(Int, (String => Seq[String]))]\n               ) = {\n    var res: Seq[String] = Seq()\n    var start            = 0\n    for (point <- splitPoint) {\n      res = res :+ strLine.substring(start, point)\n      start = point\n    }\n    res = res :+ strLine.substring(start)\n    val functionMap = splitFunSeq.toMap\n    res.zipWithIndex.flatMap {\n      case (line, index) => {\n        functionMap.get(index) match {\n          case Some(fn) =>\n            fn(line)\n          case _ => Seq(line)\n        }\n      }\n    }\n  }\n\n  def splitSectionAndJoin(\n                           itemLines: Seq[String],\n                           splitPoint: Seq[Int],\n                           splitFunSeq: Seq[(Int, (String => Seq[String]))] = Seq()\n                         ) = {\n    val res = itemLines\n      .map { itemline =>\n        val modifiedPoints = getModifiedSplitPoint(itemline, splitPoint)\n        splitLine(itemline, modifiedPoints, splitFunSeq)\n      }\n    res.tail.foldLeft(res.head)((r, itemLine) => jointSeqStr(r, itemLine))\n  }\n\n  private def jointSeqStr(seqS1: Seq[String], seqS2: Seq[String]) = {\n    seqS1.zip(seqS2).map { case (a, b) => (a.trim + \" \" + b.trim).trim }\n  }\n\n  def extractRecord(hsbcMFLikeExtractor: HSBCMFLikeExtractor, content: String): Seq[Seq[String]] = {\n    val isContentSuit =\n      hsbcMFLikeExtractor.removeHeader.foldLeft(true)((b, str1) => content.indexOf(str1) >= 0 && b)\n    val recordSpliterFn = hsbcMFLikeExtractor.tableToRecode.getOrElse(splitTableToRecords)\n    isContentSuit match {\n      case true =>\n        val lines         = SinglePageExtractor.splitToLines(content)\n        val tableContents = getTableContent(lines, hsbcMFLikeExtractor.removeHeader)\n        val afterTrimTableHeader = hsbcMFLikeExtractor.trimContentLine match {\n          case Some(lineNumber) =>\n            tableContents.map { tableContent =>\n              tableContent.slice(lineNumber, tableContent.length)\n            }\n          case _ => tableContents\n        }\n        afterTrimTableHeader\n          .flatMap { tableContent =>\n            recordSpliterFn(tableContent, hsbcMFLikeExtractor.splitPosition(0))\n          }\n          .map { record =>\n            splitSectionAndJoin(\n              record,\n              hsbcMFLikeExtractor.splitPosition,\n              hsbcMFLikeExtractor.splitSeq\n            )\n          }\n          .map { record =>\n            record.map { x => x.trim }\n          }\n      case _ => Seq()\n    }\n  }\n\n  def extractRecordsFromFile(\n                              hsbcMFLikeExtractor: HSBCMFLikeExtractor,\n                              fileName: String\n                            ): Seq[Seq[String]] = {\n    val content = getContentStr(fileName)\n    extractRecord(hsbcMFLikeExtractor, content)\n  }\n} Reader Instance import com.pwc.ds.awm.processor.pdfExtractorMethods.HSBCMFLikeExtractor\nimport com.pwc.ds.awm.processor.secHSBCMulti.reader.SecHSBCMultiTBReader.readerConfig\nimport com.pwc.ds.awm.processor.singleegarow.TBRow.{AccountName, Balance, ClosingBalance_Detail, Description_Detail, Group1, createTBRowMap}\n\nobject SecHSBCMultiTBReader2 {\n  val removeStr =\n    Seq(\n      \"HSBC         Securities             Services\",\n      \"Equity,     Income       and    Expense        Report\",\n      \"Fund code                 Valuation  date          Ledger  description/Securities  Ledger group  description/ Ledger  code                 Balance  in base             %  of  NAV Client  ID\"\n    )\n\n  val splitPoints = Seq(26, 51, 102, 139, 168).map(x => x + 4)\n  val readerConfig = HSBCMFLikeExtractor(\n    removeStr,\n    splitPoints,\n    Some(4),\n    Some(HSBCMFLikeExtractor.splitTableToRecords),\n    splitSeq = Seq((2, splitString))\n  )\n  val splitWords = Seq(\n    \"EQUITY\",\n    \"EXPENSES\",\n    \"DISTRIBUTION\",\n    \"UNREALISED\",\n    \"RESERVES\",\n    \"INVESTMENT\",\n    \"SUBSCRIPTION\",\n    \"DISTRIBUTABLE\",\n    \"REALISED\",\n    \"ACCUMULATED\"\n  )\n\n  def splitString = (str: String) => {\n    try {\n      val wordFind = splitWords.filter(word => str.indexOf(word) > 0).head\n      val index    = str.lastIndexOf(wordFind)\n      Seq(str.substring(0, index), str.substring(index, str.length))\n    } catch {\n      case _: Throwable =>\n        //println(\"*\" * 100 + \" \" + str)\n        Seq(str, \"   \")\n    }\n  }\n\n  def getRecord(filePath: String) = {\n    val res = HSBCMFLikeExtractor.extractRecordsFromFile(readerConfig, filePath)\n    res.map(row => getRow(row))\n  }\n\n  def getRow(row: Seq[String]): Map[String, String] = {\n    (\n      createTBRowMap() ++ Map(\n        Group1                -> row(0),\n        Description_Detail    -> row(2),\n        ClosingBalance_Detail -> row(5),\n        AccountName           -> row(3),\n        Balance               -> row(5)\n      )\n      ).toMap\n  }\n}","title":"Issue"},{"location":"/bugs/excelBug/index.html","text":"","title":"Excel formula issue"},{"location":"/bugs/excelBug/index.html#excel-formula-issue","text":"","title":"Excel formula issue"},{"location":"/bugs/excelBug/index.html#issue","text":"In AWM downloaded EGA Excel file will have display issue in Windows system but not in Mac. The issue as below:\nThe Sedol and ISIN field is formula, but show as value 0. After “enable editing” the formula will not evaluate correctly.\nWhat’s the expected behavior:\nThe formula should be empty at beginning, after “enable editing”, the value will evaluate correctly.","title":"Issue"},{"location":"/bugs/excelBug/index.html#issue-code","text":"The issue of display is introduced by the code change:\nFor the sbt change to include the streaming lib and code change to add function using streaming method to read excel. While the read function is not used.\nSo the lib which introduce the display issue in windows.","title":"Issue code"},{"location":"/bugs/excelBug/index.html#why-","text":"The lib may have a function to evaluate value when write cell to excel, when the formula can’t be evaluated correctly, then use 0 as default.","title":"Why?"},{"location":"/bugs/nginxDomain/index.html","text":"","title":"nginx config for domain"},{"location":"/bugs/nginxDomain/index.html#nginx-config-for-domain","text":"","title":"nginx config for domain"},{"location":"/bugs/nginxDomain/index.html#upload-failure","text":"In novus project, the frontend could call get method to backend server, but for post api call the quest always failed.\nFor the nginx setting as below:\nFrom frontend, the POST quest is use the api request:\nSo the server name in nginx should use domain name.\nAfter that, we could see the post body can be cached in nginx server:","title":"Upload failure"},{"location":"/bugs/regexsearch/index.html","text":"","title":"Regex failed in frontend"},{"location":"/bugs/regexsearch/index.html#regex-failed-in-frontend","text":"","title":"Regex failed in frontend"},{"location":"/bugs/regexsearch/index.html#issue","text":"Search without bracket success :\nSearch failed with bracket:\nWhen search with half bracket, the UI will crash:\nThe reason for the failed is using regex in frontend, when in backend the search will success.\nWhen search in backend, Slick can handle the special letter; while in frontend, the input should be verified. Don’t trust user’s input.","title":"Issue"},{"location":"/bugs/regexsearch/index.html#think-more-about-the-regex","text":"Why the bug happens? The regex use user’s “random input”, regex expression is very powerful tool in route or other server side use case but can’t handle the simple user input.\nWhich will introduce similarly philosophy thinking: “With great power comes great responsibility”.\nThe “great responsibility” is which client’s random input can’t afford. So the regex used in client side is not good choice. Similar to the thread pool management, these powerful feature should be thoughtful and careful treated.","title":"Think more about the regex"},{"location":"/bugs/mostAwfulCode/index.html","text":"","title":"Most awful code when use OO"},{"location":"/bugs/mostAwfulCode/index.html#most-awful-code-when-use-oo","text":"","title":"Most awful code when use OO"},{"location":"/bugs/mostAwfulCode/index.html#code","text":"Controller maybeFund\n  .map(fund => {\n    val fundStrategy: Option[FundReportStrategy] = {\n      fundReportStrategyFactory.getFundReportStrategy(fund.fundAdmin)\n    }\n    fundStrategy match {\n      case Some(strategy) =>\n        strategy\n          .processFundReport(request, disabledAfterYEReports)(fundEngagement, fund)\n      case None => {\n        val processResult: Result =\n          FundAdminName.withNameWithDefault(fund.fundAdmin) match {\n            case HSBC_IMS => {\n              processIMSFiles(request, fundEngagement, fund, disabledAfterYEReports)\n            } FundReportStrategyFactory package com.pwc.ds.awm.strategy.fundadmin\n\ntrait FundReportStrategyFactory {\n\n  def getFundReportStrategy(name: String): Option[FundReportStrategy]\n} FundReportStrategy import java.io.File\nimport scala.collection.Map\n\nclass FundReportStrategyBase @Inject() (\n                                         doraServer: DoraServer,\n                                         securityItemRead: SecurityItemRead,\n                                         fundEngagementReportTypeSelectionRead: FundEngagementReportTypeSelectionRead,\n                                         fundEngagementReportTypeSelectionWrite: FundEngagementReportTypeSelectionWrite\n                                       ) extends FundReportStrategy {\n\n  var disabledAfterYEReports: Map[String, Boolean] = Map[String, Boolean]()\n\n  override def processFundReport(\n                                  request: Request[MultipartFormData[Files.TemporaryFile]],\n                                  disabledAfterYEReports: Map[String, Boolean]\n                                )(implicit fundEngagement: FundEngagementData, fund: Fund): Result = {\n    implicit val userEmail: String = request.session.get(\"email\").getOrElse(\"\")\n    this.disabledAfterYEReports = disabledAfterYEReports\n    request.body\n      .file(\"file\")\n      .map(file => {\n        FileType.withNameOpt(file.contentType.getOrElse(\"\")) match {\n          case Some(contentType) =>\n            var fileContentType = contentType\n\n            // This below handle some cases where uploading csv from window gives excel contentType due to the Window registry settings.\n            if (\n              (fileContentType == FileType.XLS || fileContentType == FileType.XLSX) && FilenameUtils\n                .getExtension(file.filename)\n                .toLowerCase == \"csv\"\n            ) {\n              fileContentType = FileType.TextCSV\n            }\n\n            processFile(file.ref.toFile, file.filename, fileContentType, disabledAfterYEReports)  //No 3.\n\n          case None =>\n            encapErrorResponse(\n              UnprocessableEntity,\n              ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION\n            )\n        }\n      })\n      .getOrElse(\n        encapErrorResponse(\n          UnprocessableEntity,\n          ExtractionErrorCode.UNRECOGNISED_ERROR\n        )\n      )\n  }\n\n\n\n  def processFile(\n                   file: File,\n                   fileName: String,\n                   fileType: FileType,\n                   disabledAfterYEReports: Map[String, Boolean]\n                 )(implicit\n                   fundEngagement: FundEngagementData,\n                   fund: Fund,\n                   userEmail: String\n                 ): Result = encapErrorResponse(\n    UnprocessableEntity,\n    ExtractionErrorCode.UNRECOGNISED_ERROR\n  )\n\n\n\n  def processExcelFile(\n                        filePath: String,\n                        contentType: String,\n                        disabledAfterYEReports: Map[String, Boolean]\n                      )(implicit\n                        fundEngagement: FundEngagementData,\n                        fund: Fund,\n                        userEmail: String\n                      ): Result = {\n    val workbook = GeneralExcelExtractor\n      .extract(filePath, contentType)\n      .getOrElse(\n        throw ExtractionTabError(None, ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION) // Why the UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION throw??\n      )\n\n    val periodStart = date2UTCLocalDate(fund.auditPeriodBegin)\n    val periodEnd   = date2UTCLocalDate(fund.auditPeriodEnd)\n\n    val sheetIterator = workbook.sheetIterator()\n\n    var updatedTab         = ListBuffer[String]()\n    var successWithWarning = new ListBuffer[WarningTabStatus]()\n    var errorList          = new ListBuffer[ExtractionTabError]()\n\n    while (sheetIterator.hasNext) {\n      val sheet = sheetIterator.next()\n      getTabProcessorExec(sheet, disabledAfterYEReports) match {\n        case Success(value) =>\n          value match {\n            case (tabs, warning) =>\n              if (tabs.nonEmpty) updatedTab ++= tabs\n              if (warning.nonEmpty) successWithWarning ++= warning\n            case _ =>\n          }\n        case Failure(e) =>\n          e match {\n            case fErr: ExtractionError =>\n              errorList += ExtractionTabError(None, fErr.errorCode)\n            case eErr: ExtractionTabError =>\n              SafeLogger.logStringError(\n                Logger,\n                s\"Extraction failed for fund engagement ${fundEngagement.id}\",\n                eErr\n              )\n              errorList += eErr\n            case eErr: Exception =>\n              SafeLogger.logStringError(\n                Logger,\n                s\"Extraction failed for fund engagement ${fundEngagement.id}\",\n                eErr\n              )\n              errorList += ExtractionTabError(None, ExtractionErrorCode.UNRECOGNISED_ERROR)\n          }\n      }\n    }\n\n    if (successWithWarning.nonEmpty || errorList.nonEmpty || updatedTab.nonEmpty) {\n      encapExtractionResult(\n        massageWarning(updatedTab, successWithWarning.toList),\n        fund.name,\n        periodStart,\n        periodEnd,\n        massageError(updatedTab, errorList.toList)\n      )\n    } else {\n      SafeLogger.logStringError(\n        Logger,\n        s\"Extraction failed for fund engagement ${fundEngagement.id}\",\n        ExtractionException(\"No result & error\")\n      )\n      encapErrorResponse(\n        UnprocessableEntity,\n        ExtractionErrorCode.UNRECOGNISED_ERROR\n      )\n    }\n  }\n\n  def getExcelReportProcessorClass(\n                                    sheet: Sheet,\n                                    fundName: String,\n                                    fundEngagementId: String\n                                  ): Option[String] = None\n\n  def ruleMatchProcess(\n                        reportMap: Map[EGATab, (String, Seq[(String, Seq[MatchRule])])],\n                        fundEngagementId: String,\n                        matchLogic: (MatchRule, EGATab) => Boolean\n                      ): Option[String] = {\n    val selectedTypeId = getSelectedReportTypeId(fundEngagementId)\n    reportMap.foreach { case (reportType, config) =>\n      if (\n        Option(config._2).isDefined && Option(config._2).nonEmpty && selectedTypeId.contains(\n          config._1\n        )\n      )\n        config._2.foreach(processor_rule => {\n          if (processor_rule._2.exists(rule => matchLogic(rule, reportType)))\n            return Some(processor_rule._1)\n        })\n    }\n    None\n  } BNPFundReportStrategy import java.io.File\nimport scala.collection.Map\n\noverride def processFile(\n                          file: File,\n                          fileName: String,\n                          fileType: FileType,\n                          disabledAfterYEReports: Map[String, Boolean]\n                        )(implicit\n                          fundEngagement: FundEngagementData,\n                          fund: Fund,\n                          userEmail: String\n                        ): Result = {\n  fileType match {\n    case contentType if contentType == FileType.XLSX || contentType == FileType.XLS =>\n      processExcelFile(file.getPath, contentType.toString, disabledAfterYEReports)\n    case _ =>\n      encapErrorResponse(\n        UnprocessableEntity,\n        ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION\n      )\n  }\n}\n\noverride def getExcelReportProcessorClass(\n                                           sheet: Sheet,\n                                           fundName: String,\n                                           fundEngagementId: String\n                                         ): Option[String] = {\n\n  ruleMatchProcess(\n    map,\n    fundEngagementId,\n    (rule: MatchRule, reportType: EGATab) =>\n      rule match {\n        // check fund name and worksheet name\n        case ExcelMatchRule(name, rnameCell, None, (-1, -1), None, _) =>\n          isReportNameMatch(name, sheet, rnameCell)\n        // checks fund name but no checking on worksheet name\n        case ExcelMatchRule(name, rnameCell, None, fundCell, None, _) =>\n          if (isReportNameMatch(name, sheet, rnameCell))\n            isFundNameMatch(fundName, sheet, fundCell, reportType)\n          else false\n        // check worksheet name but no checking on fund name\n        case ExcelMatchRule(name, rnameCell, Some(sheetRegex), (-1, -1), None, _) =>\n          isReportNameMatch(name, sheet, rnameCell) && regexMatch(sheetRegex, sheet.getSheetName)\n        // check both fund name and worksheet name\n        case ExcelMatchRule(name, rnameCell, Some(sheetRegex), fundCell, None, _) =>\n          if (\n            isReportNameMatch(name, sheet, rnameCell) && regexMatch(\n              sheetRegex,\n              sheet.getSheetName\n            )\n          )\n            isFundNameMatch(fundName, sheet, fundCell, reportType)\n          else false\n        // check table header & sheet name\n        case ExcelMatchRule(\n        _,\n        (-1, -1),\n        Some(sheetRegex),\n        (-1, -1),\n        Some(headerRowRule),\n        headerRowRange\n        ) =>\n          regexMatch(sheetRegex, sheet.getSheetName) && isHeaderRowMatch(\n            sheet,\n            headerRowRule,\n            headerRowRange\n          )\n        // check table header\n        case ExcelMatchRule(_, (-1, -1), None, (-1, -1), Some(headerRowRule), headerRowRange) =>\n          isHeaderRowMatch(sheet, headerRowRule, headerRowRange)\n        case _ => false\n      }\n  )\n}\nWhen encounter error, we want to debug issue goes to Controller\nfundStrategy match {\n      case Some(strategy) =>\n        strategy\n          .processFundReport(request, disabledAfterYEReports)(fundEngagement, fund)\nBut the processFundReport is an interface\ntrait FundReportStrategyFactory {\n\n  def getFundReportStrategy(name: String): Option[FundReportStrategy]\n}\nWhich means you can’t use IDE tool to goto the right code section, when you go with debug tool which will go to FundReportStrategy File\noverride def processFundReport(\n                                  request: Request[MultipartFormData[Files.TemporaryFile]],\n                                  disabledAfterYEReports: Map[String, Boolean]\n                                )(implicit fundEngagement: FundEngagementData, fund: Fund): Result = {\n    implicit val userEmail: String = request.session.get(\"email\").getOrElse(\"\")\n    this.disabledAfterYEReports = disabledAfterYEReports\n    request.body\n      .file(\"file\")\n      .map(file => {\n        FileType.withNameOpt(file.contentType.getOrElse(\"\")) match {\n          case Some(contentType) =>\n            var fileContentType = contentType\n\n            // This below handle some cases where uploading csv from window gives excel contentType due to the Window registry settings.\n            if (\n              (fileContentType == FileType.XLS || fileContentType == FileType.XLSX) && FilenameUtils\n                .getExtension(file.filename)\n                .toLowerCase == \"csv\"\n            ) {\n              fileContentType = FileType.TextCSV\n            }\n\n            processFile(file.ref.toFile, file.filename, fileContentType, disabledAfterYEReports)  //No 3. Ok, we will go to here\nOK, we trace “processFile”, but the function is still another interface:\ndef processFile(\n      file: File,\n      fileName: String,\n      fileType: FileType,\n      disabledAfterYEReports: Map[String, Boolean]\n  )(implicit\n      fundEngagement: FundEngagementData,\n      fund: Fund,\n      userEmail: String\n  ): Result = encapErrorResponse(\n    UnprocessableEntity,\n    ExtractionErrorCode.UNRECOGNISED_ERROR\n  )\ngo with the same debugger, we will go to BNPFundReportStrategy file\noverride def processFile(\n                          file: File,\n                          fileName: String,\n                          fileType: FileType,\n                          disabledAfterYEReports: Map[String, Boolean]\n                        )(implicit\n                          fundEngagement: FundEngagementData,\n                          fund: Fund,\n                          userEmail: String\n                        ): Result = {\n  fileType match {\n    case contentType if contentType == FileType.XLSX || contentType == FileType.XLS =>\n      processExcelFile(file.getPath, contentType.toString, disabledAfterYEReports)\n    case _ =>\n      encapErrorResponse(\n        UnprocessableEntity,\n        ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION\n      )\n  }\n}\nAnd “processExcelFile” will lead you back to FundReportStrategy\ndef processExcelFile(\n                        filePath: String,\n                        contentType: String,\n                        disabledAfterYEReports: Map[String, Boolean]\n                      )(implicit\n                        fundEngagement: FundEngagementData,\n                        fund: Fund,\n                        userEmail: String\n                      ): Result = {\n    val workbook = GeneralExcelExtractor\n      .extract(filePath, contentType)\n      .getOrElse(\n        throw ExtractionTabError(None, ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION) // Why the UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION throw??\n      )\n\n    val periodStart = date2UTCLocalDate(fund.auditPeriodBegin)\n    val periodEnd   = date2UTCLocalDate(fund.auditPeriodEnd)\n\n    val sheetIterator = workbook.sheetIterator()\n\n    var updatedTab         = ListBuffer[String]()\n    var successWithWarning = new ListBuffer[WarningTabStatus]()\n    var errorList          = new ListBuffer[ExtractionTabError]()\n\n    while (sheetIterator.hasNext) {\n      val sheet = sheetIterator.next()\n      getTabProcessorExec(sheet, disabledAfterYEReports) match {\n        case Success(value) =>\n          value match {\n            case (tabs, warning) =>\n              if (tabs.nonEmpty) updatedTab ++= tabs\n              if (warning.nonEmpty) successWithWarning ++= warning\n            case _ =>\n          }\n        case Failure(e) =>\n          e match {\n            case fErr: ExtractionError =>\n              errorList += ExtractionTabError(None, fErr.errorCode)\n            case eErr: ExtractionTabError =>\n              SafeLogger.logStringError(\n                Logger,\n                s\"Extraction failed for fund engagement ${fundEngagement.id}\",\n                eErr\n              )\nThen “getTabProcessorExec” will leads you to the function getTabProcessorExec in same file:\ndef getTabProcessorExec(sheet: Sheet, disabledAfterYEReports: Map[String, Boolean])(implicit\n      fundEngagement: FundEngagementData,\n      fund: Fund,\n      userEmail: String\n  ): Try[(Seq[String], Seq[WarningTabStatus])] = Try {\n    val processorClass =\n      getExcelReportProcessorClass(sheet, fund.name, fundEngagement.id).getOrElse(\n        throw ExtractionTabError(None, ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION)\n      )\nThe most interesting thing happens, when the getExcelReportProcessorClass get None, then throw wrong exceptions. HAHAHA~~~\ngetOrElse(\n        throw ExtractionTabError(None, ExtractionErrorCode.UNSUPPORTED_REPORT_TYPE_FILE_EXTENSION)\n      )\nOk, we ignore the issue and go to the implementation. Well, “getExcelReportProcessorClass” also an interface.\ndef getExcelReportProcessorClass(\n      sheet: Sheet,\n      fundName: String,\n      fundEngagementId: String\n  ): Option[String] = None\nThe implementation of getExcelReportProcessorClass will goes to BNPFundReportStrategy file\noverride def getExcelReportProcessorClass(\n      sheet: Sheet,\n      fundName: String,\n      fundEngagementId: String\n  ): Option[String] = {\n\n    ruleMatchProcess(\n      map,\n      fundEngagementId,\n      (rule: MatchRule, reportType: EGATab) =>\n        rule match {\n          // check fund name and worksheet name\n          case ExcelMatchRule(name, rnameCell, None, (-1, -1), None, _) =>\n            isReportNameMatch(name, sheet, rnameCell)\n          // checks fund name but no checking on worksheet name\n          case ExcelMatchRule(name, rnameCell, None, fundCell, None, _) =>\n            if (isReportNameMatch(name, sheet, rnameCell))\n              isFundNameMatch(fundName, sheet, fundCell, reportType)\n            else false\n          // check worksheet name but no checking on fund name\n          case ExcelMatchRule(name, rnameCell, Some(sheetRegex), (-1, -1), None, _) =>\n            isReportNameMatch(name, sheet, rnameCell) && regexMatch(sheetRegex, sheet.getSheetName)\n          // check both fund name and worksheet name\n          case ExcelMatchRule(name, rnameCell, Some(sheetRegex), fundCell, None, _) =>\n            if (\n              isReportNameMatch(name, sheet, rnameCell) && regexMatch(\n                sheetRegex,\n                sheet.getSheetName\n              )\n            )\n              isFundNameMatch(fundName, sheet, fundCell, reportType)\n            else false\n          // check table header & sheet name\n          case ExcelMatchRule(\n                _,\n                (-1, -1),\n                Some(sheetRegex),\n                (-1, -1),\n                Some(headerRowRule),\n                headerRowRange\n              ) =>\n            regexMatch(sheetRegex, sheet.getSheetName) && isHeaderRowMatch(\n              sheet,\n              headerRowRule,\n              headerRowRange\n            )\n          // check table header\n          case ExcelMatchRule(_, (-1, -1), None, (-1, -1), Some(headerRowRule), headerRowRange) =>\n            isHeaderRowMatch(sheet, headerRowRule, headerRowRange)\n          case _ => false\n        }\n    )\n  }\nHere is almost interesting things, for “ruleMatchProcess” we need to go back “FundReportStrategy” file\ndef ruleMatchProcess(\n      reportMap: Map[EGATab, (String, Seq[(String, Seq[MatchRule])])],\n      fundEngagementId: String,\n      matchLogic: (MatchRule, EGATab) => Boolean\n  ): Option[String] = {\n    val selectedTypeId = getSelectedReportTypeId(fundEngagementId)\n    reportMap.foreach { case (reportType, config) =>\n      if (\n        Option(config._2).isDefined && Option(config._2).nonEmpty && selectedTypeId.contains(\n          config._1\n        )\n      )\n        config._2.foreach(processor_rule => {\n          if (processor_rule._2.exists(rule => matchLogic(rule, reportType)))\n            return Some(processor_rule._1)\n        })\n    }\n    None\n  }\nThe function has three parameters, that’s matchLogic is the function return by BNPFundReportStrategy.\n(rule: MatchRule, reportType: EGATab) =>\n        rule match {\n          // check fund name and worksheet name\n          case ExcelMatchRule(name, rnameCell, None, (-1, -1), None, _) =>\n            isReportNameMatch(name, sheet, rnameCell)\n          // checks fund name but no checking on worksheet name\n          case ExcelMatchRule(name, rnameCell, None, fundCell, None, _) =>\n            if (isReportNameMatch(name, sheet, rnameCell))\n              isFundNameMatch(fundName, sheet, fundCell, reportType)\n            else false\n          // check worksheet name but no checking on fund name\n          case ExcelMatchRule(name, rnameCell, Some(sheetRegex), (-1, -1), None, _) =>\n            isReportNameMatch(name, sheet, rnameCell) && regexMatch(sheetRegex, sheet.getSheetName)\n          // check both fund name and worksheet name\n          case ExcelMatchRule(name, rnameCell, Some(sheetRegex), fundCell, None, _) =>\n            if (\n              isReportNameMatch(name, sheet, rnameCell) && regexMatch(\n                sheetRegex,\n                sheet.getSheetName\n              )\n            )\n              isFundNameMatch(fundName, sheet, fundCell, reportType)\n            else false\n          // check table header & sheet name\n          case ExcelMatchRule(\n                _,\n                (-1, -1),\n                Some(sheetRegex),\n                (-1, -1),\n                Some(headerRowRule),\n                headerRowRange\n              ) =>\n            regexMatch(sheetRegex, sheet.getSheetName) && isHeaderRowMatch(\n              sheet,\n              headerRowRule,\n              headerRowRange\n            )\n          // check table header\n          case ExcelMatchRule(_, (-1, -1), None, (-1, -1), Some(headerRowRule), headerRowRange) =>\n            isHeaderRowMatch(sheet, headerRowRule, headerRowRange)\n          case _ => false\n        }\nWell, with the shitty code logic, what’s matchLogic will be in the function ruleMatchProcess, I think nobody can find out without real time debugger.\nWell, if you want to say you can use debugger to check the running time value, then you are beyond naive, the value in debugger is as below:\nThis is a perfect example of follow OO design and write code which can’t be debugged.\n1. Use the interface, hardy trace the right implemetation\n\n    2. Use Factory mode, also no easy trace by another person who is not the code writer.\n\n    3. The logic jump from implementation and interface multiple times\n\n    4. The parameter configuration is by logic spaghetti.\n        And the logic depends on multi input format.","title":"code"},{"location":"/bugs/java/index.html","text":"","title":"Java related"},{"location":"/bugs/java/index.html#java-related","text":"","title":"Java related"},{"location":"/bugs/java/index.html#date","text":"See reference from oracle site","title":"date"},{"location":"/bugs/loadissue/index.html","text":"","title":"Load issue for valuation"},{"location":"/bugs/loadissue/index.html#load-issue-for-valuation","text":"","title":"Load issue for valuation"},{"location":"/bugs/loadissue/index.html#valuation-load-issue","text":"The fund list is as below, when use select one engagement, all funds will be listed, but with more and more funds in same engagement, the load time increase to unacceptable.\nThe original javascript code as below:\nFetchData fetchData = () => {\n  this.cancelSingleEGAPolling()\n  Promise.all([queryFundsByEngagementIdAndFundAdminType(this.props.engagementId, FrontEndBackEndFundAdminTypeMapping[this.state.fundAccountingType]), queryFundWithStatusByEngagementId(this.props.engagementId), getConfirmationCompletionRatioByEngagementId(this.props.engagementId)])\n    .then(([funds, fundsWithStatus, confirmationCompletionRatio]) => {\n      this.setState({\n        funds: funds,\n        fundItemCollapsed: funds.map(fund => { return { id: fund.id, collapsed: true } }),\n        fundEngagementsWithStatus: fundsWithStatus,\n        fundEngagementWithConfirmationStatus: confirmationCompletionRatio,\n        //bookmark\n        loading: false,\n      }, this.beginSingleEGAPolling)\n      fetchValuationProgress(fundsWithStatus, (valuationProgress: FundEngagementWithValuationStatus) => {\n        this.setState(\n          prevState => {\n            return {\n              ...prevState,\n              fundEngagementWithValuationStatus: [...prevState.fundEngagementWithValuationStatus, valuationProgress]\n            }\n          })\n      })\n\n    }).catch(res => {\n      PopErrors(res.toString() + \" fetching funds data error\")\n      this.setState({\n        loading: false\n      })\n    })\n} GetValuationService export const fetchValuationProgress = async (fundsWithStatus: EngamentFundsWithStatus[], setValuationStatus: (fundEngagementWithValuationStatus: FundEngagementWithValuationStatus) => void) => {\n  fundsWithStatus.map(fundsWithStatus => {\n    var fundEngagementId = fundsWithStatus.fundEngagementId.toString()\n    var fundId = fundsWithStatus.fundId\n\n    getSecurityNameList(fundEngagementId).then((value) => {\n      if (value.length > 0) {\n        var item = {\n          fundEngagementId: fundEngagementId,\n          fundId: fundId,\n          available: true\n        } as FundEngagementWithValuationStatus\n        setValuationStatus(item)\n      } else {\n        var item = {\n          fundEngagementId: fundEngagementId,\n          fundId: fundId,\n          available: false\n        } as FundEngagementWithValuationStatus\n        setValuationStatus(item)\n      }\n    })\n  })\n}\nEvery time one fund’s valuation fetched, the react state will be updated.\nFetchData fetchData = () => {\n  this.cancelSingleEGAPolling()\n  Promise.all([queryFundsByEngagementIdAndFundAdminType(this.props.engagementId, FrontEndBackEndFundAdminTypeMapping[this.state.fundAccountingType]), queryFundWithStatusByEngagementId(this.props.engagementId), getConfirmationCompletionRatioByEngagementId(this.props.engagementId)])\n    .then(([funds, fundsWithStatus, confirmationCompletionRatio]) => {\n      this.setState({\n        funds: funds,\n        fundItemCollapsed: funds.map(fund => { return { id: fund.id, collapsed: true } }),\n        fundEngagementsWithStatus: fundsWithStatus,\n        fundEngagementWithConfirmationStatus: confirmationCompletionRatio,\n        //bookmark\n        loading: false,\n      }, this.beginSingleEGAPolling)\n\n      getValuationUploadOrNot(fundsWithStatus, (valuationProgress: FundEngagementWithValuationStatus[]) => {\n        this.setState(\n          prevState => {\n            return {\n              ...prevState,\n              fundEngagementWithValuationStatus: valuationProgress\n            }\n          })\n      })\n\n    }).catch(res => {\n      PopErrors(res.toString() + \" fetching funds data error\")\n      this.setState({\n        loading: false\n      })\n    })\n} GetValuation","title":"Valuation load issue"},{"location":"/bugs/pdfreader/index.html","text":"","title":"Read PDF"},{"location":"/bugs/pdfreader/index.html#read-pdf","text":"","title":"Read PDF"},{"location":"/bugs/pdfreader/index.html#issue","text":"Read text content from pdf may encounter some wired issue:\nthe text content is expected to be:\nBANK OF NEW YORK (BONY)      \n         USD\n          BLACKROCK INS US TRS USD CORE IUTFD  1.00000000     \n         USD\n          GOLDMAN SACHS USD TREASURY LIQ RES   1.0000000\nBut use different pdf reader setting will have difference result:\nReader1:\ndef extractAllTextFromPdfFile(sourceFilePath: String, reportConfig: ExtractorConfig): String = {\n    try {\n      var content = \"\"\n      if (isPdfFileExtension(sourceFilePath)) {\n        val file                            = FileSystemHelper.getFile(sourceFilePath)\n        val document                        = PDDocument.load(file)\n        val stripper: LayoutPdfTextStripper = new LayoutPdfTextStripper\n        stripper.setReportConfig(reportConfig)\n        stripper.setSortByPosition(true);\n        content = stripper.getText(document);\n        document.close()\n      }\n      content\n    } catch {\n      case e: IOException => throw new IOException(\"read source pdf file IO error\")\n      case e: Exception   => throw new Exception(JsError(\"read source pdf file IO error\"))\n    }\n  }\nresult:\nReader2:\ndef extractAllTextFromConfirmationPdfFile(\n      sourceFilePath: String,\n      reportConfig: ExtractorConfig\n  ): String = {\n    try {\n      var content = \"\"\n      if (isPdfFileExtension(sourceFilePath)) {\n        var file                                        = FileSystemHelper.getFile(sourceFilePath)\n        val document                                    = PDDocument.load(file);\n        var stripper: LayoutConfirmationPdfTextStripper = new LayoutConfirmationPdfTextStripper;\n        stripper.setReportConfig(reportConfig)\n        stripper.setSortByPosition(true);\n        content = stripper.getText(document);\n      }\n      content\n    } catch {\n      case e: IOException => throw new IOException(\"read source pdf file IO error\")\n      case e: Exception   => throw new Exception(JsError(\"read source pdf file IO error\"))\n    }\n  }\nresult:","title":"Issue"},{"location":"/bugs/redundantoperation/index.html","text":"","title":"Redundant DB operation"},{"location":"/bugs/redundantoperation/index.html#redundant-db-operation","text":"","title":"Redundant DB operation"},{"location":"/bugs/redundantoperation/index.html#issue","text":"The store operation will query database multiple times:","title":"Issue"},{"location":"/bugs/redundantoperation/index.html#code","text":"When the storage is empty, there is no need to query database\nOriginal code def exportExcelToDatabase(\n                           storage: GeneralSingleEGAStorage,\n                           fundEngagementId: String,\n                           userEmail: String,\n                           fundEngagementReportTypeSelectionRead: FundEngagementReportTypeSelectionRead,\n                           fundEngagementReportTypeSelectionWrite: FundEngagementReportTypeSelectionWrite,\n                           sheetTypesReportTypesMapRead: SheetTypesReportTypesMapRead\n                         ) = {\n  val selections: Seq[FundEngagementReportTypeSelectionData] = Await.result(\n    fundEngagementReportTypeSelectionRead.lookupByFundEngagementId(fundEngagementId),\n    10 seconds\n  )\n  val selectionDataMap: Map[String, String] = selections.map { selection =>\n    val sheetTypeId = Await\n      .result(\n        sheetTypesReportTypesMapRead.lookupByID(selection.sheettypesReporttypesMapId),\n        10 seconds\n      )\n      .map(_.sheetTypeId)\n      .getOrElse(\"-1\")\n    val value = sheetTypeId match {\n      case \"1\" => Json.toJson(storage.trialBalanceReportTBData).toString()\n      case \"2\" => Json.toJson(storage.detailedGeneralLedgerReportGLData).toString()\n      case \"3\" => Json.toJson(storage.detailedGeneralLedgerReportGLAfterYEData).toString()\n      case \"4\" => Json.toJson(storage.positionAppraisalReportPositionData).toString()\n      case \"5\" => Json.toJson(storage.cashAppraisalReportCashData).toString()\n      case \"6\" => Json.toJson(storage.purchaseAndSaleTransactionReportPSRData).toString()\n      case \"7\" => Json.toJson(storage.purchaseAndSaleTransactionReportPSRAfterYEData).toString()\n      case \"8\" => Json.toJson(storage.dividendsIncomeExpenseReportDividendData).toString()\n      case \"9\" => Json.toJson(storage.dividendsIncomeExpenseReportDividendAfterYEData).toString()\n      case \"10\" =>\n        Json.toJson(storage.realisedGainLossReportRGLData).toString()\n      case \"11\" => Json.toJson(storage.realisedGainLossReportRGLAfterYEData).toString()\n      case _    => \"\"\n    }\n    selection.sheettypesReporttypesMapId -> value\n  }.toMap\n  val addtionMap = storage.additionMap.toSeq.map { kv =>\n    (kv._1 -> Json.toJson(kv._2).toString())\n  }\n  val mergedSelectionMap = selectionDataMap ++ addtionMap\n  val newRows: Seq[Option[FundEngagementReportTypeSelectionData]] = selections.map(row => {\n    val extractedString: String =\n      mergedSelectionMap.get(row.sheettypesReporttypesMapId).getOrElse(\"\")\n    if (extractedString.length > 0 && extractedString != \"[]\") {\n      val newRow = row.copy(\n        uploadFileContent = None,\n        uploadFileStatus = UploadFileStatus.success.toString,\n        extractionFileContent = Some(extractedString),\n        extractionStatus = ExtractStatus.success.toString,\n        modifyby = Some(userEmail),\n        modifydatetime = Some(new Timestamp(System.currentTimeMillis()))\n      )\n      Some(newRow)\n    } else {\n      None\n    }\n  })\n  Await.result(\n    fundEngagementReportTypeSelectionWrite.updateSelectionBatch(\n      newRows.filter(row => !row.isEmpty).map(row => row.get)\n    ),\n    10 seconds\n  )\n  fundEngagementReportTypeSelectionWrite.writeReadyTime(fundEngagementId)\n} Fix code def exportExcelToDatabase(\n                           storage: GeneralSingleEGAStorage,\n                           fundEngagementId: String,\n                           userEmail: String,\n                           fundEngagementReportTypeSelectionRead: FundEngagementReportTypeSelectionRead,\n                           fundEngagementReportTypeSelectionWrite: FundEngagementReportTypeSelectionWrite,\n                           sheetTypesReportTypesMapRead: SheetTypesReportTypesMapRead\n                         ) = {\n  if(!storage.isStorageNotEmpty()){\n    Future(Unit)\n    //Do nothing if no value updated.\n  }else{\n    val selections: Seq[FundEngagementReportTypeSelectionData] = Await.result(\n      fundEngagementReportTypeSelectionRead.lookupByFundEngagementId(fundEngagementId),\n      10 seconds\n    )\n    val selectionDataMap: Map[String, String] = selections.map { selection =>\n      val sheetTypeId = Await\n        .result(\n          sheetTypesReportTypesMapRead.lookupByID(selection.sheettypesReporttypesMapId),\n          10 seconds\n        )\n        .map(_.sheetTypeId)\n        .getOrElse(\"-1\")\n      val value = sheetTypeId match {\n        case \"1\" => Json.toJson(storage.trialBalanceReportTBData).toString()\n        case \"2\" => Json.toJson(storage.detailedGeneralLedgerReportGLData).toString()\n        case \"3\" => Json.toJson(storage.detailedGeneralLedgerReportGLAfterYEData).toString()\n        case \"4\" => Json.toJson(storage.positionAppraisalReportPositionData).toString()\n        case \"5\" => Json.toJson(storage.cashAppraisalReportCashData).toString()\n        case \"6\" => Json.toJson(storage.purchaseAndSaleTransactionReportPSRData).toString()\n        case \"7\" => Json.toJson(storage.purchaseAndSaleTransactionReportPSRAfterYEData).toString()\n        case \"8\" => Json.toJson(storage.dividendsIncomeExpenseReportDividendData).toString()\n        case \"9\" => Json.toJson(storage.dividendsIncomeExpenseReportDividendAfterYEData).toString()\n        case \"10\" =>\n          Json.toJson(storage.realisedGainLossReportRGLData).toString()\n        case \"11\" => Json.toJson(storage.realisedGainLossReportRGLAfterYEData).toString()\n        case _    => \"\"\n      }\n      selection.sheettypesReporttypesMapId -> value\n    }.toMap\n    val addtionMap = storage.additionMap.toSeq.map { kv =>\n      (kv._1 -> Json.toJson(kv._2).toString())\n    }\n    val mergedSelectionMap = selectionDataMap ++ addtionMap\n    val newRows: Seq[Option[FundEngagementReportTypeSelectionData]] = selections.map(row => {\n      val extractedString: String =\n        mergedSelectionMap.get(row.sheettypesReporttypesMapId).getOrElse(\"\")\n      if (extractedString.length > 0 && extractedString != \"[]\") {\n        val newRow = row.copy(\n          uploadFileContent = None,\n          uploadFileStatus = UploadFileStatus.success.toString,\n          extractionFileContent = Some(extractedString),\n          extractionStatus = ExtractStatus.success.toString,\n          modifyby = Some(userEmail),\n          modifydatetime = Some(new Timestamp(System.currentTimeMillis()))\n        )\n        Some(newRow)\n      } else {\n        None\n      }\n    })\n    Await.result(\n      fundEngagementReportTypeSelectionWrite.updateSelectionBatch(\n        newRows.filter(row => !row.isEmpty).map(row => row.get)\n      ),\n      10 seconds\n    )\n    fundEngagementReportTypeSelectionWrite.writeReadyTime(fundEngagementId)\n  }\n\n}","title":"Code"},{"location":"/bugs/statusUpdate/index.html","text":"","title":"project status update issue"},{"location":"/bugs/statusUpdate/index.html#project-status-update-issue","text":"","title":"project status update issue"},{"location":"/bugs/statusUpdate/index.html#update-issue","text":"In CIDR, some project is failed but in front end the project status is processing\nSet the log for the project status\nand shows the log 13:15:30.751 [clustering-cluster-akka.actor.default-dispatcher-27] [info] d.c.f.FsmActor akka://clustering-cluster@localhost:1600/user/driveradbe9c10-d6a9-11ec-a4da-99207fd004c7/fsmActoradbf1140-d6a9-11ec-a4da-99207fd004c7 - Some(JobMeta(0b4b0e71-d6ac-11ec-a4da-99207fd004c7)) is end\n13:15:30.751 [processor-pool-thread--2] [error] c.p.d.c.e.c.JobInstance - processor failed, java.lang.Exception: exit code is non-zero(1)\n13:15:30.751 [processor-pool-thread--2] [error] c.p.d.c.e.c.MultiThreadJobRunnerImpl - java.lang.Exception: exit code is non-zero(1)\n13:15:30.752 [processor-pool-thread--2] [error] c.p.d.c.e.c.JobInstance - processor failed, java.lang.RuntimeException: java.lang.Exception: exit code is non-zero(1)\n13:15:30.752 [processor-pool-thread--2] [error] c.p.d.c.e.c.MultiThreadJobRunnerImpl - java.lang.RuntimeException: java.lang.Exception: exit code is non-zero(1)\n13:15:30.753 [application-akka.actor.default-dispatcher-11] [info] c.p.d.c.s.ProjectServiceWriteImpl - Job failed\n13:15:30.753 [application-akka.actor.default-dispatcher-11] [info] c.p.d.c.s.ProjectServiceWriteImpl - Job failed\n13:15:30.757 [application-akka.actor.default-dispatcher-11] [info] c.p.d.c.d.i.SlickProjectDAO - %update%projectId: 4215 - Some(Process)\n13:15:30.757 [application-akka.actor.default-dispatcher-11] [info] c.p.d.c.d.i.SlickProjectDAO - %update%projectId: 4215 - Some(Process)\n13:15:30.758 [application-akka.actor.default-dispatcher-117] [info] c.p.d.c.s.ProjectServiceWriteImpl - projectId: 4215 - ProjectData(4215,frontend bugfix test,Some(786546cb-7813-47d7-9414-374344b8c724),None,None,None,Some(1861),Some(2022-05-18 13:01:50.0),Some(1861),None,Some(2022-06-01 13:01:50.0),Some(Failed),None,None,Some(afe90779-a049-4542-8066-40f37b7b5a2e),None,None,Some(jiawei.jw.wu@cn.pwc.com))\n13:15:30.758 [application-akka.actor.default-dispatcher-117] [info] c.p.d.c.d.i.SlickProjectDAO - %updateStatus%projectId: 4215 - Some(Failed)\n13:15:30.758 [application-akka.actor.default-dispatcher-11] [info] c.p.d.c.d.i.SlickProjectDAO - %update%projectId: 4215 - Some(Process)\n13:15:30.763 [application-akka.actor.default-dispatcher-117] [info] c.p.d.c.s.ProjectServiceWriteImpl - projectId: 4215 - Apply audit log\n13:15:30.765 [application-akka.actor.default-dispatcher-12] [info] c.p.d.c.d.i.SlickProjectDAO - %update%projectId: 4215 - Some(Failed)\nWhen the project is processing, there are some sub tasks running, if one of the subtask is failed,then the job should be marked as failed, and in front-end user’s operation may also impact the project status updated, then update from frontend will use the dirty value of the previous status and write back the project status.\nfix for the bug:","title":"update issue"},{"location":"/bugs/uicrash/index.html","text":"","title":"UI crash"},{"location":"/bugs/uicrash/index.html#ui-crash","text":"","title":"UI crash"},{"location":"/bugs/uicrash/index.html#issue-1","text":"When user is assigned to specified engagement, then user can’t login to the system\nThe fund name is “Bosheng China Special Value – Fund 2021”\nBut “–” is different from “-”\nThe code for the issue is\ntry{\n        var userResponse = await axios.get(`/user`, {headers:userInfo})\n        if(userResponse.data){\n          let privilege = userResponse.data ? userResponse.data.userInfoFront.privilege : \"\"\n          //window.sessionStorage.setItem(\"userInfo\",btoa(JSON.stringify(userResponse.data)))\n          store.dispatch(setPrivilege(privilege))\n          var loginValue = this.email || \"my account\";\n          this.props.login(loginValue);\n          let state = this.props.location.state || {};\n          window.location.href = state.from || '/';\n        }\n        else {\n          this.setState({\n            ishiddenrerror: false\n          });\n        }\n      }\n      catch (e) {\n        this.setState({\n          ishiddenrerror: false\n        })\n      }\nThe btoa will throw exception,while catch will not print anything about this exception.","title":"Issue 1"},{"location":"/bugs/uicrash/index.html#issue-2","text":"User report some financial data can’t be load in frontend.\nThe “capitalgain” gain field is not correct in the json string\nThe code for the update ordinary earning operation import scala.collection.immutable.ListMap\nimport scala.collection.mutable.ListBuffer\n\ndef extractProfitLossSheetFromExcel(frontEndFinancialData:FinancialdataGetFromFrontend, workbook:Workbook) = {\n  //get profit loss data list from uploaded excel\n  var rowKey_profit_loss: ListMap[String, String] = RowKeys.rowKeys_ProfitLoss.map(key_val => (key_val._2.toLowerCase, key_val._1))\n  val profitLossSheet = workbook.getSheet(\"P&L\")\n  val (profitLossStartRow: Int, profitLossStartColumn: Int) = ExcelReader.findExcelRowAndColumnWithCellValue(profitLossSheet, \"Net Sales\", true)\n  val (profitLossEndRow: Int, _: Int) = ExcelReader.findExcelRowAndColumnWithCellValue(profitLossSheet, \"Net Income\", true)\n  var profitLossDataList = new ListBuffer[ProfitLossCol]()\n\n  var netProfitLoss = \"0\";\n  var capitalGain = \"0\"\n  for (rowNum <- profitLossStartRow to profitLossEndRow) {\n    val row = profitLossSheet.getRow(rowNum)\n    val excelEnglishKey = ExcelReader.getCellValueAsStringOption(row, profitLossStartColumn).getOrElse(\"\").toLowerCase;\n    val keyOpt = rowKey_profit_loss.get(excelEnglishKey)\n    if (keyOpt.isDefined) {\n      profitLossDataList += ProfitLossCol(keyOpt.get, ExcelReader.getCellValueAsStringOption(row, profitLossStartColumn + 1).getOrElse(\"\"))\n\n      //set oridinary earnings\n      if (keyOpt.get.equals(\"net_income\")) {\n        netProfitLoss = ExcelReader.getCellValueAsStringOption(row, profitLossStartColumn + 1).getOrElse(\"0\")\n      }\n      else if (keyOpt.get.equals(\"including_realized_gain_on_disposal_of_assets_held_for_more_than_one_year\")) {\n        capitalGain = ExcelReader.getCellValueAsStringOption(row, profitLossStartColumn + 1).getOrElse(\"0\")\n      }\n    }\n  }\n  var ordianaryOptionFromFrontEnd = Json.parse(frontEndFinancialData.ordinaryearningsandgain.getOrElse(companyfinancialdataServiceRead.ordinaryearningsandgain)).as[OrdinaryEarningsAndGainOption]\n  val ordinaryearningsandgain = \"{\\\"netprofitloss\\\":\" + netProfitLoss + \",\\\"capitalgain\\\":\" + capitalGain + \",\\\"currency\\\":\" + ordianaryOptionFromFrontEnd.currency.getOrElse(\"1\") + \"}\"\n  (profitLossDataList, ordinaryearningsandgain)\n} The code for Excel Reader /**\n * get cell value as string base on cell type\n * @param row\n * @param index\n * @return\n */\ndef getCellValueAsStringOption(row: Row,index: Int):Option[String] = {\n  getCellOption(row, index).flatMap(cell => {\n    var cellStyle = cell.getCellType\n    cellStyle match {\n      case CellType.NUMERIC => {\n        Option(cell.getNumericCellValue.toString.trim)\n      }\n      case CellType.STRING => {\n        Option(cell.getStringCellValue.trim)\n      }\n      case CellType.BOOLEAN => {\n        Option(cell.getBooleanCellValue.toString.trim)\n      }\n      case CellType.FORMULA => {\n        cell.getCachedFormulaResultType match {\n          case CellType.NUMERIC =>\n            Option(cell.getNumericCellValue.toString.trim)\n          case CellType.STRING  =>\n            Option(cell.getStringCellValue.trim)\n          case _=>\n            Option(cell.getCellFormula)\n        }\n      }\n      case _ => {\n        None\n      }\n    }\n  })\n}\nWhen excel has a field of “ ”, then the filed set in json will be missing.\nThe key point is always using class instead of man-made string format.","title":"Issue 2"},{"location":"/bugs/uitest/index.html","text":"","title":"UI test"},{"location":"/bugs/uitest/index.html#ui-test","text":"","title":"UI test"},{"location":"/bugs/uitest/index.html#ui-test-need","text":"Someone just comment one route in React JS, this bug can’t be verified by api test, only can be covered by UI test","title":"UI test need"},{"location":"/bugs/loadIssue2/index.html","text":"","title":"Statistics load issue"},{"location":"/bugs/loadIssue2/index.html#statistics-load-issue","text":"","title":"Statistics load issue"},{"location":"/bugs/loadIssue2/index.html#load-slow-issue","text":"The statistics api engagementCompletion will take long time to load,\nWhile the code as below:\nController def lookupEngagementsCompletion() = deadbolt.SubjectPresent()(parse.anyContent) {\n  implicit authRequest =>\n  {\n    val engagementIdsJsArray = authRequest.body.asJson\n    engagementIdsJsArray match {\n      case Some(array) => {\n        val engagementIds = array.as[Seq[String]]\n        getCompletionRatioByEngagementIds(engagementIds).map(res => {\n          Ok(Json.toJson(res))\n        })\n      }\n      case _ => {\n        val emptyMap: Map[String, Double] = Map()\n        Future(Ok(Json.toJson(emptyMap)))\n      }\n    }\n  }\n}\n\ndef getCompletionRatioByEngagementIds(engagementIds: Seq[String]) = {\n  val engagementIdRatioMap = engagementIds.map(engagementId => {\n    val result = for {\n      fundEngagements <- logTime(\"\") { fundEngagementRead.queryByEngagmentId(engagementId) }\n      reportRatios    <- logTime(\"\") { getReportCompletionRatioByEngagementId(engagementId) }\n    } yield {\n      val fundEngagementIds = fundEngagements.map(_.id)\n      for {\n        egaData <- logTime(\"\") { egaRead.lookupByFundEngagementIds(fundEngagementIds) }\n        feId_UploadAndAccountNamesMap <-\n          logTime(\"\") {\n            fundEngagementReportTypeSelectionRead\n              .getUploadConfirmationDividedByDataFormat_WithAccountNameList(fundEngagementIds)\n          }\n        //confirmationRatios <- getConfirmationCompletionRatioByEngagement(engagementId)\n        fundAccountsWithFEId <- logTime(\"\") {\n          fundAccountRead.lookupByFundEngagementIds(fundEngagementIds)\n        }\n        singleEGARatios <- logTime(\"\") {\n          getSingleEGACompletionRatioByEngagementId(fundEngagementIds)\n        } //ok\n      } yield {\n        logTime(\"TEST: CALCULATE RATIOS\") {\n          val feId_fundId = reportRatios.map(r => (r.fundEngagementId, r.fundId))\n          val confirmationRatios = getConfirmationCompletionRatioByFundEngagementIds(\n            fundEngagementIds,\n            fundAccountsWithFEId,\n            feId_fundId,\n            feId_UploadAndAccountNamesMap\n          )\n          val valuationRatios = getValuationCompletionRatioByEngagementId(egaData) //ok\n          val fundEngagementsRatios = fundEngagementIds\n            .map(fundEngagementId => {\n              val maybeReportRatio =\n                reportRatios.filter(_.fundEngagementId == fundEngagementId).headOption\n              val maybeConfirmationRatio =\n                confirmationRatios.get(fundEngagementId)\n              val maybeValuationRatio = valuationRatios.get(fundEngagementId)\n              val maybeSingleEGARatio = singleEGARatios.get(fundEngagementId)\n              val reportRatio = maybeReportRatio match {\n                case Some(value) => {\n                  if (value.definedReportTypeNumber > 0) {\n                    0.5 * value.reportUploadedNumber / value.definedReportTypeNumber\n                  } else {\n                    0\n                  }\n                }\n                case _ => 0\n              }\n              val confirmationRatio = maybeConfirmationRatio match {\n                case Some(value) => {\n                  if (value.total > 0) {\n                    0.17 * value.finished / value.total\n                  } else {\n                    0\n                  }\n                }\n                case _ => 0\n              }\n              val valuationRatio = maybeValuationRatio match {\n                case Some(value) => {\n                  if (value._1 == true && value._2 == true) {\n                    0.16\n                  } else if (value._1 == false && value._2 == false) {\n                    0\n                  } else {\n                    0.08\n                  }\n                }\n                case _ => 0\n              }\n              val singleEGARatio = maybeSingleEGARatio match {\n                case Some(value) => {\n                  if (value > 0) {\n                    0.17\n                  } else {\n                    0\n                  }\n                }\n                case _ => 0\n              }\n              reportRatio + confirmationRatio + valuationRatio + singleEGARatio\n            })\n          val engagementRatio = if (fundEngagementsRatios.length > 0) {\n            fundEngagementsRatios.reduce(_ + _) / fundEngagementsRatios.length\n          } else {\n            0\n          }\n          (engagementId, (engagementRatio, fundEngagementsRatios.length))\n        }\n      }\n    }\n    result.flatten\n  })\n  Future.sequence(engagementIdRatioMap).map(_.toMap)\n} FundEngagementDAO override def queryByEngagementId(\n                                  engagementId: String\n                                ): Future[Seq[FundEngagementData]] = {\n  val f: Future[Seq[FundEngagementRow]] =\n    db.run(\n      FundEngagement\n        .filter(x => x.engagementid === engagementId)\n        .result\n    )\n  f.map { maybeRows => maybeRows.map(item => rowToData(item)) }\n}","title":"Load slow issue"},{"location":"/bugs/initialCrash/index.html","text":"","title":"Initial crash"},{"location":"/bugs/initialCrash/index.html#initial-crash","text":"","title":"Initial crash"},{"location":"/bugs/initialCrash/index.html#issue","text":"IDR project start with Akka cluster initial crash with error “port 1600 is already in use”.\nThe port 1600 is the akka node port.\nWhy the initialization will create multiple akka cluster?\nBecause the IDR will record unfinished projects and try to restart these project on startup.\nThe left solution will wrap the restart function in Future will create parallel restart project operation which will try to create multiple akka system at same time. Then the crash happens.","title":"Issue"},{"location":"/codedesign/index.html","text":"","title":"Code design"},{"location":"/codedesign/index.html#code-design","text":"Notification desgin IMS processor Service design without interface Cache API design Handle multi input Knowledge base establish with deep-copy","title":"Code design"},{"location":"/codedesign/notification/index.html","text":"","title":"Notification desgin"},{"location":"/codedesign/notification/index.html#notification-desgin","text":"","title":"Notification desgin"},{"location":"/codedesign/notification/index.html#notification-workflow","text":"In PFIC ,external investment notifications will be generated and cleared when data reaches a specific state (as shown in following diagram)\nIt’s very complex workflow and also not want this notification flow design will impact the business logic.","title":"Notification workflow"},{"location":"/codedesign/notification/index.html#design-code","text":"Controller import scala.concurrent.{Await, Future}\n\ndef upload(companyId: String, year: Int, operationType: String) = deadbolt.Pattern(value = \"(v_pwc)|(v_mycompany)\", patternType = PatternType.REGEX)(parse.multipartFormData(maxLength = 1024*1024))  { implicit request =>\n  request.body.file(\"file\").map { file =>\n    try{\n      ...\n        companyfinancialdataServiceWrite.updateFinancialData(request.session.get(\"email\").getOrElse(\"\"), request.subject, financialData).map(res => {Ok(\"success\")})\n    }\n} Service override def updateFinancialData(currentUserEmail: String,\n                                 subject: Option[Subject],\n                                 financialData: FinancialdataGetFromFrontend): Future[Unit] = {\n  validateUserUtil.validateExternalUserPermissionForCompany(subject, financialData.companyId, financialData.year).map(_ => {\n    ...\n    var newFinancedata = waitForUpdateFinancialDataAndGenerateNotification(currentUserEmail, subject, financialData, companyuser)\n    ...\n  })\n}\n\nprivate def waitForUpdateFinancialDataAndGenerateNotification(userEmail: String,\n                                                              subject: Option[Subject],\n                                                              financialData: FinancialdataGetFromFrontend,\n                                                              companyuser: Option[Companyuser]) = {\n  val currentUserPrivileges = subject.map(s => s.permissions.mkString(\",\")).getOrElse(\"\")\n  val newFinancedataAndNotification = checkPermissionThenGetFiDataAndNotification(financialData, userEmail, currentUserPrivileges, companyuser)\n  val newFinancedata = newFinancedataAndNotification.financialData\n  val newNotifications = newFinancedataAndNotification.notification\n  val futureUpdateFinancialdata = update(newFinancedata)\n  var resultUpdateFinancialdata = \"failed\"\n  futureUpdateFinancialdata onComplete {\n    case util.Success(value) => {\n      resultUpdateFinancialdata = \"success\"\n      waitForClearNotifations(newFinancedata.companyId, newFinancedata.year, financialData.operationType)\n      notificationWrite.waitForCreateNotifications(newNotifications)\n    }\n    case scala.util.Failure(exception) => throw new Exception(exception.toString)\n  }\n  Await.result(futureUpdateFinancialdata, Duration.apply(10.toLong, duration.SECONDS))\n  newFinancedata\n} WorkflowUtil import java.sql.Timestamp\n\noverride def checkPermissionThenGetFiDataAndNotification(dataFrontEnd: FinancialdataGetFromFrontend,\n                                                         email: String,\n                                                         privilege: String,\n                                                         companyuser: Option[Companyuser]) = {\n  val currentFinancialData: Financialdata = companyfinancialdataServiceRead.waitForLookupWithDefaultValues(dataFrontEnd.companyId, dataFrontEnd.year) match {\n    case Some(data) => data\n    case None => throw new Exception(\"Financial data doesn't exist\")\n  }\n  FinancialDataWorkflowUtils.checkRolePermissionThenGetFiDataAndNotification(dataFrontEnd, currentFinancialData, email, privilege, companyuser)\n}\n\ndef checkRolePermissionThenGetFiDataAndNotification(dataFrontEnd:FinancialdataGetFromFrontend,\n                                                    currentFinancialData:Financialdata,\n                                                    user:String,\n                                                    privilege:String,\n                                                    companyuser:Option[Companyuser]):NextFinancialDataAndNotification= {\n  val now = TimeService.currentTime\n  val companyuserName = companyuser.map(_.name).getOrElse(\"\")\n  val workflowState = WorkflowState(currentFinancialData.internalState, currentFinancialData.externalState,currentFinancialData.modifiedByExternal, currentFinancialData.uploadFilesByExternal)\n  OperationTypes.withName(dataFrontEnd.operationType.toUpperCase) match {\n    case OperationTypes.external_data_save =>      externalSave(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case OperationTypes.external_file_save =>      externalFileSave(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case OperationTypes.external_data_finalize =>  externalFinalize(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case OperationTypes.external_data_approve =>   externalApprove(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case OperationTypes.file_save =>               internalFileSave(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case OperationTypes.data_save => {\n      if(currentFinancialData.modifiedByExternal.getOrElse(false) && !StatusHelper.isInternalApproved(workflowState) && !( workflowState.externalState.getOrElse(None) == ExternalState.ApprovedOnlyFiles))\n        sentBack(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n      else\n        internalSave(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    }\n    case OperationTypes.external_data_agree =>               agree(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case OperationTypes.external_data_disagree =>         disagree(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case OperationTypes.data_finalize =>          internalFinalize(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case OperationTypes.data_signOff =>            internalSignOff(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case OperationTypes.data_approve =>            internalApprove(dataFrontEnd,currentFinancialData,user, privilege, now,companyuserName)\n    case _ => throw UnAuthorizationException(\"Operation type doesn't exists\")\n  }\n}\n\ndef externalSave(dataFrontEnd:FinancialdataGetFromFrontend,\n                 currentFinancialData:\n                 Financialdata,\n                 user:String,\n                 privilege:String,\n                 now: Timestamp,\n                 companyuserName:String) = {\n  val workflowState = WorkflowState(currentFinancialData.internalState,currentFinancialData.externalState,currentFinancialData.modifiedByExternal, currentFinancialData.uploadFilesByExternal)\n  var modifiedByExternal = getModifiedByExternal(dataFrontEnd, currentFinancialData)\n\n  if(actionsValidator.validateExternalSave(privilege,workflowState))\n  {\n    val newfdata = currentFinancialData.copy(currencyId = dataFrontEnd.currencyId,assetdata = dataFrontEnd.assetdata,\n      liabilitydata = dataFrontEnd.liabilitydata, profitlossdata = dataFrontEnd.profitlossdata,\n      fmvdata = dataFrontEnd.fmvdata, ordinaryearningsandgain = dataFrontEnd.ordinaryearningsandgain,\n\n      modifiedByExternal = modifiedByExternal)\n    val noti = Nil\n    NextFinancialDataAndNotification(newfdata,noti)\n  }\n  else\n    throw UnAuthorizationException()\n}\n\n DataStructure case class FinancialdataGetFromFrontend(id: Long, year: Int, companyId: String,currencyId: String, assetdata: Option[String] = None,\n                                        liabilitydata: Option[String] = None, profitlossdata: Option[String] = None, fmvdata: Option[String] = None, ordinaryearningsandgain: Option[String] = None,\n                                        operationType:String, //The operation type will find the\n                                        msg:Option[String], owAssetdata: Option[String] = None, owLiabilitydata: Option[String] = None,\n                                        owProfitlossdata: Option[String] = None,incorporationdate: Option[String] = None,  uploadFilesByExternal: Option[Boolean] = None)\n\n\ncase class NextFinancialDataAndNotification(financialData:Financialdata,notification:Seq[Notification])\n\ncase class Notification(var id: String, notificationType: NotificationType.NotificationType, notificationDataType: NotificationDataType.NotificationDataType,\n                        description: Option[NotificationDescription], status: Boolean, entityname: Option[String],\n                        link: String, year: Int, triggerAt: java.sql.Timestamp, triggerBy: Option[String])","title":"Design code"},{"location":"/codedesign/imsprocessor/index.html","text":"","title":"IMS processor"},{"location":"/codedesign/imsprocessor/index.html#ims-processor","text":"","title":"IMS processor"},{"location":"/codedesign/imsprocessor/index.html#code","text":"Controller val hsbcIMSExtractorMap = Map[Seq[String], (AbstractProcessor, ExtractorConfig)](\n  Seq(\n    \"PURCHASE TRANSACTION REPORT\"\n  ) -> (ReportProcessor, PurchaseTransactionReportConfig.extractorConfig),\n  Seq(\n    \"QUICK VALUATION REPORT\"\n  ) -> (QuickValuationReportProcessor, QuickValuationReportConfig.extractorConfig_POSITION),\n  Seq(\n    \"SALES TRANSACTION REPORT\"\n  ) -> (ReportProcessor, SalesTransactionReportConfig.extractorConfig),\n  Seq(\n    \"ACCOUNTS MOVEMENT REPORT\"\n  ) -> (ReportProcessor, AccountsMovementReportConfig.extractorConfig),\n  Seq(\n    \"CONSOLIDATED TRIAL BALANCE\"\n  ) -> (new ConsolidationTrialBalanceReportProcessor, ConsolidatedTrialBalancedReportConfig.extractorConfig),\n  Seq(\n    \"OUTSTANDING DIVIDEND REPORT\"\n  ) -> (new OutstandingDividendReportProcessor, OutstandingDividendReportConfig.extractorConfig)\n) ReportProcessor class ReportProcessor {}\n\nobject ReportProcessor extends AbstractProcessor with BaseFileReader {\n  def getMemoryOutput(extractorConfig: ExtractorConfig): AbstractReportMemoryOutput = {\n    extractorConfig.reportType match {\n      case \"PURCHASE TRANSACTION REPORT\" => PurchaseTransactionReportMemoryOutput\n      case \"SALES TRANSACTION REPORT\"    => SalesTransactionReportMemoryOutput\n      case \"ACCOUNTS MOVEMENT REPORT\"    => AccountsMovementReportMemoryOutput\n      case _ => {\n        throw UnsupportedReportTypeException(extractorConfig.reportType)\n      }\n    }\n  }\n\n  def getExcelOutput(\n                      extractorConfig: ExtractorConfig\n                    ): (ExcelOutputConfig, BaseReportExcelOutput) = {\n    extractorConfig.reportType match {\n      case \"PURCHASE TRANSACTION REPORT\" =>\n        (PurchaseTransactionReportConfig.outputterConfig, PurchaseTransactionReportExcelOutput)\n      case \"SALES TRANSACTION REPORT\" =>\n        (SalesTransactionReportConfig.outputterConfig, PurchaseTransactionReportExcelOutput)\n      case \"ACCOUNTS MOVEMENT REPORT\" =>\n        (AccountsMovementReportConfig.outputterConfig, PurchaseTransactionReportExcelOutput)\n      case \"FUND PRICE REPORT\" =>\n        (FundPriceReportConfig.outputterConfig, PurchaseTransactionReportExcelOutput)\n      case _ => {\n        throw UnsupportedReportTypeException(extractorConfig.reportType)\n      }\n    }\n  }\n\n  def getExtractors(content: String, extractorConfig: ExtractorConfig): (\n    BlockSeparator,\n      SanitizerConfig,\n      ExtractorConfig,\n      BaseReportSanitizer,\n      BaseReportExtractor\n    ) = {\n    extractorConfig.reportType match {\n      case \"PURCHASE TRANSACTION REPORT\" =>\n        (\n          new BlockSeparatorImpl {},\n          PurchaseTransactionReportConfig.sanitizeConfig,\n          PurchaseTransactionReportConfig.extractorConfig,\n          SalesTransactionReportSanitizer,\n          new PurchaseReportExtractor(PurchaseTransactionReportConfig.singleCurrencyBodyRowConfig)\n        )\n      case \"SALES TRANSACTION REPORT\" => {\n        val extractorConfig =\n          if (content.contains(\"USING EFFECTIVE YIELD AMORTIZATION\"))\n            SalesTransactionReportAdditionalConfig.extractorConfig\n          else SalesTransactionReportConfig.extractorConfig\n        (\n          new BlockSeparatorImpl {},\n          SalesTransactionReportConfig.sanitizeConfig,\n          extractorConfig,\n          SalesTransactionReportSanitizer,\n          new PurchaseReportExtractor(SalesTransactionReportConfig.singleCurrencyBodyRowConfig)\n        )\n      }\n      case \"ACCOUNTS MOVEMENT REPORT\" =>\n        (\n          new AccountsMovementReportBlockSeparator(),\n          AccountsMovementReportConfig.sanitizeConfig,\n          AccountsMovementReportConfig.extractorConfig,\n          AccountsMovementReportSanitizer,\n          new AccountsMovementReportExtractor()\n        )\n      case \"FUND PRICE REPORT\" =>\n        (\n          new BlockSeparatorImpl {},\n          FundPriceReportConfig.sanitizeConfig,\n          FundPriceReportConfig.extractorConfig,\n          StaticBaseReportSanitizer,\n          new BaseReportExtractor()\n        )\n      case _ => {\n        throw UnsupportedReportTypeException(extractorConfig.reportType)\n      }\n    }\n  }\n\n  def readFileAndExtractToSheets(\n                                  sourceFilePath: String,\n                                  extractorConfig: ExtractorConfig\n                                ): Seq[PurchaseReportExtractedSheet] = {\n    val source = extractTextFromFile(sourceFilePath)\n\n    val (blockSeparator, sanitizerConfig, targetExtractorConfig, sanitizer, extractor) =\n      getExtractors(source, extractorConfig)\n\n    val rawSheets = logTime(\"split content into sheet\") {\n      blockSeparator.splitContentIntoSheets(source)\n    }\n\n    val lineBreaker = DataSanitizer.detectLinebreaker(source)\n\n    var sheets = logTime(\"extract all sheets\") {\n      rawSheets.zipWithIndex.map(v => {\n        logTime(\"extract single sheet\") {\n          val sheet = v._1\n\n          val (headers, tables, summaries) = logTime(\"page block time\") {\n            blockSeparator.getPageBlocks(\n              sheet,\n              targetExtractorConfig.tableConfig,\n              lineBreaker,\n              true,\n              targetExtractorConfig.pageLineNumber\n            )\n          }\n          val (sanitizedHeader, sanitizedTable, sanitizedSummary) = logTime(\"sanitizer time\") {\n            sanitizer.sanitizeBlocks(headers, tables, summaries, sanitizerConfig)\n          }\n          val (extractedSummary, extractedTable) = logTime(\"extract report time\") {\n            extractor.extractSingleReport(\n              sanitizedHeader,\n              sanitizedTable,\n              sanitizedSummary,\n              targetExtractorConfig\n            )\n          }\n          PurchaseReportExtractedSheet(\n            s\"${targetExtractorConfig.reportType} ${v._2}\",\n            extractedTable,\n            extractedSummary,\n            Seq()\n          )\n        }\n      })\n    }\n    sheets\n  }\n\n  override def readFileAndExtractToObjectForPeriod(\n                                                    sourceFilePath: String,\n                                                    extractorConfig: ExtractorConfig,\n                                                    fundName: String,\n                                                    frontEndPeriodStart: Date,\n                                                    frontEndPeriodEnd: Date\n                                                  ): SingleEGAStorage = {\n    val sheets    = readFileAndExtractToSheets(sourceFilePath, extractorConfig)\n    val outputter = getMemoryOutput(extractorConfig)\n    val newStorage = outputter.extractSheetToObjectForPeriod(\n      sheets,\n      fundName,\n      frontEndPeriodStart,\n      frontEndPeriodEnd\n    )\n    newStorage\n  }\n} BlockSeparatorImple trait BlockSeparatorImpl extends BlockSeparator {\n\n  val endOfReport = \"END OF REPORT\";\n\n  var dataSanitizer: BaseDataSanitizerImpl = new BaseDataSanitizerImpl {}\n\n  var isReportHeaderPaternStrictMode: Option[Boolean] = None\n\n  /** * @throws java.lang.NumberFormatException  If the string does not contain a parsable `Double`.\n   * * @throws java.lang.NullPointerException  If the string is null.\n   *\n   * @param str\n   * @return\n   */\n  override def parseDouble(str: String): Double = {\n    try {\n      str.replaceAll(\",\", \"\").toDouble\n    } catch {\n      case x: NumberFormatException => {\n        SafeLogger.logStringError(Logger, str + \" can't be parse into double. \", x)\n        0\n      }\n      case e: Exception => {\n        SafeLogger.logStringError(Logger, str + \" can't be parse into double. \", e)\n        0\n      }\n    }\n  }\n\n  override def splitContentIntoPages(\n                                      content: String,\n                                      lineBreaker: String,\n                                      pageLineNum: Int = 1\n                                    ): Array[String] = {\n    var splitPagePattern = \"\"\n    if (pageLineNum == 1) {\n      splitPagePattern = s\"(?=[ \\\\t]*${lineBreaker}.*PAGE(\\\\s)*(\\\\d)+)\"\n    } else if (pageLineNum == 2) {\n      splitPagePattern = s\"(?=[ \\\\t]*${lineBreaker}.*${lineBreaker}.*PAGE(\\\\s)*(\\\\d)+)\"\n    } else {\n      splitPagePattern = \"(?=(.*\" + lineBreaker + \"){\" + pageLineNum + \"}.**PAGE(\\\\s)*(\\\\d)+)\";\n    }\n    var pages = content.split(splitPagePattern);\n    pages = pages.filter(page => {\n      !dataSanitizer.isGarbageContent(page) && page.contains(\"PAGE\")\n    })\n    pages\n  }\n\n  override def splitContentIntoSegments(\n                                         content: String,\n                                         lineBreaker: String,\n                                         indicator: String\n                                       ): Array[String] = {\n    var splitPagePattern = \"(?=\" + lineBreaker + \".*\" + indicator + \")\";\n    var segments         = content.split(splitPagePattern);\n    segments = segments.filter(!dataSanitizer.isGarbageContent(_)) // to filter empty block\n    segments\n  }\n\n  /** there maybe two kinds of report header patterns, one contains space line in the report header, one does not. this function find out which, and returns.\n   * @param pageContent\n   * @param reportHeaderLineNumber\n   * @param lineBreaker\n   * @return\n   */\n  def getReportHeaderPattern(\n                              pageContent: String,\n                              reportHeaderLineNumber: Int,\n                              lineBreaker: String\n                            ): String = {\n    isReportHeaderPaternStrictMode match {\n      case Some(true) => \"^(.*\\\\w+.*\" + lineBreaker + \"){\" + reportHeaderLineNumber + \"}\"\n      case Some(false) =>\n        \"^(.*\" + lineBreaker + \"){\" + reportHeaderLineNumber + \",}?(\\\\s*\" + lineBreaker + \")\"\n      case _ => {\n        var headerPattern1 = \"^(.*\\\\w+.*\" + lineBreaker + \"){\" + reportHeaderLineNumber + \"}\";\n        var headerPattern2 =\n          \"^(.*\" + lineBreaker + \"){\" + reportHeaderLineNumber + \",}?(\\\\s*\" + lineBreaker + \")\";\n        if (headerPattern1.r.findFirstMatchIn(pageContent).isDefined) {\n          isReportHeaderPaternStrictMode = Some(true)\n          headerPattern1\n        } else {\n          isReportHeaderPaternStrictMode = Some(false)\n          headerPattern2\n        }\n      }\n    }\n  }\n\n  /** get report header end index in the page content, the page content should start with the report header.\n   * @param pageContent\n   * @param reportHeaderLineNumber\n   * @return\n   */\n  override def getReportHeaderEndIndex(\n                                        pageContent: String,\n                                        reportHeaderLineNumber: Int,\n                                        lineBreaker: String\n                                      ): Int = {\n    var left          = dataSanitizer.trimEmptyStartLines(pageContent, lineBreaker)\n    var headerPattern = getReportHeaderPattern(pageContent, reportHeaderLineNumber, lineBreaker)\n    var headerReg     = headerPattern.r.findFirstMatchIn(left);\n    headerReg match {\n      case Some(headerMatch) => {\n        headerMatch.end\n      }\n      case _ => {\n        //TODO the page content is wrong, need error handling\n        throw new Exception(\"there is no report header in this page\")\n      }\n    }\n  }\n\n  /** get the table header end index in the page content. the page content should start with the table header.\n   * @param pageContent\n   * @param tableHeaderLineNumber\n   * @return\n   */\n  override def getTableHeaderEndIndex(\n                                       pageContent: String,\n                                       tableHeaderLineNumber: Int,\n                                       lineBreaker: String\n                                     ): Int = {\n    var headerAfterFirstRow = if (tableHeaderLineNumber > 1) {\n      \"(.*\" + lineBreaker + \"){\" + (tableHeaderLineNumber - 1).toString + \"}\"\n    } else { \"\" }\n    var txtTableHeaderPattern = \"^(.*\\\\w+.*\" + lineBreaker + headerAfterFirstRow + \")\"\n    //var txtTableHeaderPattern = \"^(.*\\\\w+.*\" + lineBreaker + \"){\" + tableHeaderLineNumber + \"}\";\n    var txtTableHeaderReg = txtTableHeaderPattern.r.findFirstMatchIn(pageContent);\n    txtTableHeaderReg match {\n      case Some(titleMatch) => {\n        titleMatch.end\n      }\n      case _ => {\n        -1\n      }\n    }\n  }\n\n  /** @param sheetContent\n   * @param tableConfig\n   * @param lineBreaker\n   * @param hasSummary if this report contains the summary part, the summary part must be surrounded with stars ******\n   * @return\n   */\n  override def getPageBlocks(\n                              sheetContent: String,\n                              tableConfig: TableConfig,\n                              lineBreaker: String,\n                              hasSummary: Boolean = false,\n                              pageLineNumber: Int = 1\n                            ): (Seq[BlockConfig], Seq[BlockConfig], Seq[BlockConfig]) = {\n    var sheets: Array[String] = splitContentIntoSheets(sheetContent);\n    var pages: Array[String] = splitContentIntoPages(\n      sheetContent,\n      lineBreaker,\n      pageLineNumber\n    ) // the pages must contain word \"PAGE\"\n\n    var reportHeaders = Seq[BlockConfig]()\n    var tablebodies   = Seq[BlockConfig]()\n    var summaries     = Seq[BlockConfig]()\n\n    for (pageNum <- 0 until pages.length) {\n      var reportHeaderStr = \"\"\n      var tableContent    = \"\"\n      if (!dataSanitizer.isGarbageContent(pages(pageNum))) { // when page is summary page, it's empty content\n        var page = pages(pageNum)\n        var left = dataSanitizer.trimEmptyStartLines(page, lineBreaker)\n        var reportHeaderLastIndex =\n          getReportHeaderEndIndex(left, tableConfig.reportHeaderLineNumber, lineBreaker);\n        reportHeaderStr = left.substring(0, reportHeaderLastIndex);\n        left = left.substring(reportHeaderLastIndex)\n\n        var (summaryContent: String, tableBodyContent: String) =\n          if (hasSummary) getSummaryContent(left, lineBreaker)\n          else (\"\", left) // here get summary content by star (*) lines\n        summaries = summaries :+ BlockConfig(summaryContent, pageNum)\n        tableContent = dataSanitizer.trimEmptyStartLines(tableBodyContent, lineBreaker)\n      }\n      reportHeaders = reportHeaders :+ BlockConfig(reportHeaderStr, pageNum)\n      tablebodies = tablebodies :+ BlockConfig(tableContent, pageNum)\n    }\n    (reportHeaders, tablebodies, summaries)\n  }\n\n  override def splitContentIntoSheets(\n                                       content: String,\n                                       sheetSeparator: String = null\n                                     ): Array[String] = {\n\n    var splitSheetPattern = \"(?<=\" + endOfReport + \")\";\n    if (sheetSeparator != null) {\n      splitSheetPattern = \"(?<=\" + sheetSeparator + \")\"\n    }\n\n    var sheets = content.split(splitSheetPattern);\n    sheets = sheets.filter(!dataSanitizer.isGarbageContent(_))\n\n    sheets = sheets.filter(sheet => {\n      sheet.contains(\"PAGE\")\n    })\n    sheets\n  }\n\n  override def getTotalPageNumber(content: String): Int = {\n    var pagePattern = \"PAGE\\\\s*([1-9]\\\\d*)\\\\b\".r;\n    var matches     = pagePattern.findAllMatchIn(content);\n\n    var pageNum: Int = 1;\n    matches.foreach(regMatch => {\n      var currentPageNum = Integer.parseInt(regMatch.group(1));\n      if (currentPageNum > pageNum) {\n        pageNum = currentPageNum\n      }\n    })\n    pageNum\n  }\n\n  /** @param blockSeperatorLineNumber\n   * @param tableHeaderLineNum: it's to instruct how many lines one block contains\n   * @param tableBodyContent : this content only contains table body, without summary or others.\n   * @return\n   */\n  override def splitTableContentIntoBlocks(\n                                            blockSeperatorLineNumber: Int,\n                                            tableHeaderLineNum: Int,\n                                            tableContent: String,\n                                            lineBreaker: String\n                                          ): Seq[BlockConfig] = {\n\n    var tableBodyContent = dataSanitizer.trimEmptyStartLines(tableContent, lineBreaker)\n    var pageBlocks       = Seq[BlockConfig]();\n    if (blockSeperatorLineNumber == 1) {\n\n      if (tableHeaderLineNum == 1) {\n        pageBlocks =\n          tableBodyContent.split(lineBreaker).toSeq.map(blockContent => BlockConfig(blockContent))\n      } else {\n        var bodylines = tableBodyContent.split(lineBreaker);\n\n        for (bodylineNum <- 0 until bodylines.length by tableHeaderLineNum) {\n          var blockContent = \"\";\n          for (blockLineNum <- 0 until tableHeaderLineNum) {\n            if (bodylines.length > (bodylineNum + blockLineNum)) { // ensure it's not out of range when accessing bodylines\n              blockContent = blockContent + lineBreaker + bodylines(bodylineNum + blockLineNum)\n            }\n          }\n          pageBlocks = pageBlocks :+ BlockConfig(blockContent);\n        }\n      }\n\n    } else if (blockSeperatorLineNumber >= 2) {\n      pageBlocks = tableBodyContent\n        .split(\"(\\\\s*\" + lineBreaker + \"){\" + blockSeperatorLineNumber + \"}\")\n        .toSeq\n        .map(blockContent => BlockConfig(blockContent));\n    }\n\n    pageBlocks\n  }\n\n  /** summary content is surrounded with star lines both at the beginning and at the ending\n   * @param content\n   * @return\n   */\n  override def getSummaryContent(content: String, lineBreaker: String): (String, String) = {\n    var left           = content;\n    var summaryContent = \"\";\n    var summaryPattern = (\"\\\\*{5,}(.*\" + lineBreaker + \")+\\\\*{5,}\").r;\n    summaryPattern.findFirstMatchIn(content) match {\n      case Some(value) => {\n        summaryContent = value.toString;\n        summaryContent = dataSanitizer.trimEmptyStartLines(summaryContent, lineBreaker);\n        summaryContent = dataSanitizer.trimEmptyEndLines(summaryContent, lineBreaker);\n        left = content.substring(0, value.start)\n        left = dataSanitizer.trimEmptyStartLines(left, lineBreaker);\n        left = dataSanitizer.trimEmptyEndLines(left, lineBreaker)\n      }\n      case _ => {}\n    }\n    (summaryContent, left)\n  }\n\n} PSRConfig object PurchaseTransactionReportConfig {\n  val extractorConfig = ExtractorConfig(\n    \"PURCHASE TRANSACTION REPORT\",\n    Seq(\n      Seq(\n        ColumnConfig(\"\", 0, 143),\n        ColumnConfig(\"\", 143, 158)\n      ),\n      Seq(\n        ColumnConfig(\"\", 0, 160),\n        ColumnConfig(\"\", 160, 168)\n      ),\n      Seq(\n        ColumnConfig(\"\", 0, 160)\n      ),\n      Seq(\n        ColumnConfig(\"\", 0, 53),\n        ColumnConfig(ColumnTitles.START_DATE, 58, 66),\n        ColumnConfig(ColumnTitles.END_DATE, 70, 78)\n      ),\n      Seq(\n        ColumnConfig(ColumnTitles.FUND_NAME, 0, 160)\n      ),\n      Seq(\n        ColumnConfig(ColumnTitles.FUND_NAME, 0, 160)\n      )\n    ),\n    TableConfig(\n      \".*T R A D E D  C U R R E N C Y  /  B A S E  C U R R E N C Y.*\",\n      4,\n      tableBodyConfig = TableBodyConfig(\n        rows = Seq(\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"TD DATE/\", 0, 9),\n              ColumnConfig(\"BROKER\", 9, 25),\n              ColumnConfig(\"TRANS #\", 25, 35),\n              ColumnConfig(\"NUMBER OF SHARES\", 35, 56),\n              ColumnConfig(\"CCY_1\", 56, 59),\n              ColumnConfig(\"UNIT PRICE_1\", 59, 76),\n              ColumnConfig(\"PRINCIPAL COST_1\", 76, 94),\n              ColumnConfig(\"BROKER COMMISSION_1\", 94, 113),\n              ColumnConfig(\"OTHER FEES_1\", 113, 131),\n              ColumnConfig(\"SETTLEMENT AMOUNT_1\", 131, 150),\n              ColumnConfig(\"INT PURCHASE_1\", 150, 165)\n            )\n          ),\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"STL DATE\", 0, 9),\n              ColumnConfig(\"SECURITY NAME_1\", 9, 56),\n              ColumnConfig(\"CCY_2\", 56, 59),\n              ColumnConfig(\"UNIT PRICE_2\", 59, 76),\n              ColumnConfig(\"PRINCIPAL COST_2\", 76, 94),\n              ColumnConfig(\"BROKER COMMISSION_2\", 94, 113),\n              ColumnConfig(\"OTHER FEES_2\", 113, 131),\n              ColumnConfig(\"SETTLEMENT AMOUNT_2\", 131, 150),\n              ColumnConfig(\"INT PURCHASE_2\", 150, 165)\n            )\n          ),\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"SECURITY NAME_2\", 0, 59),\n              ColumnConfig(\"PRINCIPAL COST_3\", 81, 84)\n            ),\n            true\n          ),\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"SECURITY ID & CODE\", 0, 59)\n            )\n          )\n        ),\n        s\"\\\\s*$dateRegex.*\"\n      ),\n      summaries = Seq(\n        // Ignore the TRADED CCY TOTAL row and BASE CCY TOTAL row\n      ),\n      separators = Seq(\n        TableSeparatorConfig(\n          \"---------------\",\n          1,\n          1,\n          rows = Seq(\n            Seq(\n              ColumnConfig(\"\", 0, 165)\n            ),\n            // skip the middle line of the separator\n            Seq(),\n            Seq(\n              ColumnConfig(\"GenericInvestment\", 0, 165)\n            )\n          ),\n          appendToBody = true\n        )\n      ),\n      rowCount = None,\n      subTable = Some(\n        TableConfig(\n          \".*BASE CURRENCY.*\",\n          3,\n          TableBodyConfig(\n            rows = Seq(\n              TableRowConfig(\n                Seq(\n                  ColumnConfig(\"TD DATE/\", 0, 56, 4),\n                  ColumnConfig(\"CCY_1\", 56, 59),\n                  ColumnConfig(\"UNIT PRICE_1\", 59, 76),\n                  ColumnConfig(\"PRINCIPAL COST_1\", 76, 94),\n                  ColumnConfig(\"BROKER COMMISSION_1\", 94, 113),\n                  ColumnConfig(\"OTHER FEES_1\", 113, 131),\n                  ColumnConfig(\"SETTLEMENT AMOUNT_1\", 131, 150),\n                  ColumnConfig(\"INT PURCHASE_1\", 150, 165)\n                )\n              )\n            ),\n            indicator = \".*GRAND TOTAL.*\"\n          ),\n          rowCount = Some(1)\n        )\n      ),\n      reportHeaderLineNumber = 6\n    ),\n    Some(\n      TableConfig(tableBodyConfig =\n        TableBodyConfig(\n          Seq(TableRowConfig(Seq(ColumnConfig(\"\", 0, 75), ColumnConfig(\"\", 76, 92)))),\n          \"\"\n        )\n      )\n    )\n  )\n\n  val singleCurrencyBodyRowConfig = TableBodyConfig(\n    Seq(\n      TableRowConfig(\n        Seq(\n          ColumnConfig(\"TD DATE/\", 0, 9),\n          ColumnConfig(\"BROKER\", 9, 25),\n          ColumnConfig(\"TRANS #\", 25, 35),\n          ColumnConfig(\"NUMBER OF SHARES\", 35, 56),\n          ColumnConfig(\"CCY_1\", 56, 59),\n          ColumnConfig(\"UNIT PRICE_1\", 59, 76),\n          ColumnConfig(\"PRINCIPAL COST_1\", 76, 94),\n          ColumnConfig(\"BROKER COMMISSION_1\", 94, 113),\n          ColumnConfig(\"OTHER FEES_1\", 113, 131),\n          ColumnConfig(\"SETTLEMENT AMOUNT_1\", 131, 150),\n          ColumnConfig(\"INT PURCHASE_1\", 150, 165),\n          //Copy the value as BASE CCY\n          ColumnConfig(\"CCY_2\", 56, 59),\n          ColumnConfig(\"UNIT PRICE_2\", 59, 76),\n          ColumnConfig(\"PRINCIPAL COST_2\", 76, 94),\n          ColumnConfig(\"BROKER COMMISSION_2\", 94, 113),\n          ColumnConfig(\"OTHER FEES_2\", 113, 131),\n          ColumnConfig(\"SETTLEMENT AMOUNT_2\", 131, 150),\n          ColumnConfig(\"INT PURCHASE_2\", 150, 165)\n        )\n      ),\n      TableRowConfig(\n        Seq(\n          ColumnConfig(\"STL DATE\", 0, 9),\n          ColumnConfig(\"SECURITY NAME_1\", 9, 56)\n        )\n      ),\n      TableRowConfig(\n        Seq(\n          ColumnConfig(\"SECURITY NAME_2\", 0, 59),\n          ColumnConfig(\"PRINCIPAL COST_3\", 81, 84)\n        ),\n        true\n      ),\n      TableRowConfig(\n        Seq(\n          ColumnConfig(\"SECURITY ID & CODE\", 0, 59)\n        )\n      )\n    ),\n    s\"\\\\s*$dateRegex.*\"\n  )\n\n  val sanitizeConfig = SanitizerConfig(\n    ignores = Seq(\n      SanitizerLineConfig(\"PRICE IS OUTSIDE TOLERANCE\", true),\n      SanitizerLineConfig(\"SYSTEM DATE\")\n    )\n  )\n\n  val outputterConfig = ExcelOutputConfig(\n    false,\n    Seq(\n      \"TD DATE/\",\n      \"STL DATE\",\n      \"BROKER\",\n      \"SECURITY NAME\",\n      \"SECURITY ID & CODE\",\n      \"TRANS #\",\n      \"NUMBER OF SHARES\",\n      \"CCY_1\",\n      \"UNIT PRICE_1\",\n      \"PRINCIPAL COST_1\",\n      \"BROKER COMMISSION_1\",\n      \"OTHER FEES_1\",\n      \"SETTLEMENT AMOUNT_1\",\n      \"INT PURCHASE_1\",\n      \"CCY_2\",\n      \"UNIT PRICE_2\",\n      \"PRINCIPAL COST_2\",\n      \"BROKER COMMISSION_2\",\n      \"OTHER FEES_2\",\n      \"SETTLEMENT AMOUNT_2\",\n      \"INT PURCHASE_2\",\n      \"PRINCIPAL COST_3\"\n    )\n  )\n} SaleConfig object SalesTransactionReportConfig {\n  val extractorConfig = ExtractorConfig(\n    \"SALES TRANSACTION REPORT\",\n    Seq(\n      Seq(\n        ColumnConfig(\"\", 0, 173),\n        ColumnConfig(\"\", 173, 188)\n      ),\n      Seq(\n        ColumnConfig(\"\", 0, 190),\n        ColumnConfig(\"\", 190, 198)\n      ),\n      Seq(\n        ColumnConfig(\"\", 0, 198)\n      ),\n      Seq(\n        ColumnConfig(\"Group1\", 0, 5),\n        ColumnConfig(\"\", 5, 73),\n        ColumnConfig(ColumnTitles.START_DATE, 78, 86),\n        ColumnConfig(ColumnTitles.END_DATE, 90, 98)\n      ),\n      Seq(\n        ColumnConfig(ColumnTitles.FUND_NAME, 0, 198)\n      ),\n      Seq(\n        ColumnConfig(ColumnTitles.FUND_NAME, 0, 198)\n      )\n    ),\n    TableConfig(\n      \".*T R A D E D  C U R R E N C Y  /  B A S E  C U R R E N C Y.*\",\n      4,\n      TableBodyConfig(\n        Seq(\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"NUMBER OF SHARES\", 18, 198)\n            )\n          ),\n          /*\n        There are totally 4 REALISED PROFIT/LOSS(-) in one table row. The first two values maps to CCY_1, so named REALISED PROFIT/LOSS(-)_1_1 and REALISED PROFIT/LOSS(-)_1_2\n        The second two values maps to CCY_2 so named REALISED PROFIT/LOSS(-)_2_1 and REALISED PROFIT/LOSS(-)_2_2\n           */\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"TD DATE/\", 0, 8),\n              ColumnConfig(\"BROKER\", 8, 25),\n              ColumnConfig(\"TRANS #\", 25, 44),\n              ColumnConfig(\"CCY_1\", 44, 47),\n              ColumnConfig(\"UNIT PRICE_1\", 47, 61),\n              ColumnConfig(\"NET PROCEEDS_1\", 61, 84),\n              ColumnConfig(\"COST WRITTEN-OFF_1\", 84, 106),\n              ColumnConfig(\"REALISED PROFIT/LOSS(-)_1_1\", 106, 125),\n              ColumnConfig(\"BROKER COMMISSION_1\", 125, 143),\n              ColumnConfig(\"OTHER FEES_1\", 143, 164),\n              ColumnConfig(\"INT SOLD_1\", 164, 179),\n              ColumnConfig(\"DEFERRED INCOME_1\", 179, 198)\n            )\n          ),\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"PRINCIPAL COST_1\", 61, 84),\n              ColumnConfig(\"REALISED PROFIT/LOSS(-)_1_2\", 106, 125)\n            )\n          ),\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"STL DATE\", 0, 8),\n              ColumnConfig(\"SECURITY NAME_1\", 8, 44),\n              ColumnConfig(\"CCY_2\", 44, 47),\n              ColumnConfig(\"UNIT PRICE_2\", 47, 61),\n              ColumnConfig(\"NET PROCEEDS_2\", 61, 84),\n              ColumnConfig(\"COST WRITTEN-OFF_2\", 84, 106),\n              ColumnConfig(\"REALISED PROFIT/LOSS(-)_2_1\", 106, 125),\n              ColumnConfig(\"BROKER COMMISSION_2\", 125, 143),\n              ColumnConfig(\"OTHER FEES_2\", 143, 164),\n              ColumnConfig(\"INT SOLD_2\", 164, 179),\n              ColumnConfig(\"DEFERRED INCOME_2\", 179, 198)\n            )\n          ),\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"SECURITY NAME_2\", 8, 44),\n              ColumnConfig(\"PRINCIPAL COST_2\", 61, 84),\n              ColumnConfig(\"REALISED PROFIT/LOSS(-)_2_2\", 106, 125)\n            )\n          ),\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"SECURITY NAME_3\", 8, 44)\n            ),\n            true\n          ),\n          TableRowConfig(\n            Seq(\n              ColumnConfig(\"SECURITY ID & CODE\", 0, 106)\n            )\n          )\n        ),\n        \"NUMBER OF SHARES :.*\"\n      ),\n      Seq(\n        //Ignore *total* rows\n      ),\n      separators = Seq(\n        TableSeparatorConfig(\n          \"---------------\",\n          1,\n          1,\n          rows = Seq(\n            Seq(\n              ColumnConfig(\"\", 0, 165)\n            ),\n            // skip the middle line of the separator\n            Seq(),\n            Seq(\n              ColumnConfig(\"GenericInvestment\", 0, 165)\n            )\n          ),\n          appendToBody = true\n        )\n      ),\n      rowCount = None,\n      subTable = Some(\n        TableConfig(\n          \".*BASE CURRENCY.*\",\n          4,\n          TableBodyConfig(\n            rows = Seq(\n              TableRowConfig(\n                Seq(\n                  ColumnConfig(\"TD DATE/\", 0, 44, 4),\n                  ColumnConfig(\"CCY_1\", 44, 47),\n                  ColumnConfig(\"UNIT PRICE_1\", 47, 61),\n                  ColumnConfig(\"NET PROCEEDS_1\", 61, 84),\n                  ColumnConfig(\"COST WRITTEN-OFF_1\", 84, 106),\n                  ColumnConfig(\"REALISED PROFIT/LOSS(-)_1_1\", 106, 125),\n                  ColumnConfig(\"BROKER COMMISSION_1\", 125, 143),\n                  ColumnConfig(\"OTHER FEES_1\", 143, 164),\n                  ColumnConfig(\"INT SOLD_1\", 164, 179),\n                  ColumnConfig(\"DEFERRED INCOME_1\", 179, 198)\n                )\n              ),\n              TableRowConfig(\n                Seq(\n                  ColumnConfig(\"PRINCIPAL COST_1\", 61, 84),\n                  ColumnConfig(\"REALISED PROFIT/LOSS(-)_1_2\", 106, 125)\n                )\n              )\n            ),\n            //Ignore the COUNTRY TOTAL row, only keep the GRAND TOTAL row\n            indicator = \".*GRAND TOTAL.*\"\n          ),\n          rowCount = Some(1)\n        )\n      ),\n      reportHeaderLineNumber = 6\n    ),\n    Some(\n      TableConfig(tableBodyConfig =\n        TableBodyConfig(\n          Seq(\n            TableRowConfig(\n              Seq(\n                ColumnConfig(\"\", 0, 75),\n                ColumnConfig(\"\", 76, 92)\n              )\n            )\n          ),\n          \"\"\n        )\n      )\n    )\n  )\n\n  val singleCurrencyBodyRowConfig = TableBodyConfig(\n    Seq(\n      TableRowConfig(\n        Seq(\n          ColumnConfig(\"NUMBER OF SHARES\", 18, 198)\n        )\n      ),\n      /*\n      There are totally 4 REALISED PROFIT/LOSS(-) in one table row. The first two values maps to CCY_1, so named REALISED PROFIT/LOSS(-)_1_1 and REALISED PROFIT/LOSS(-)_1_2\n      The second two values maps to CCY_2 so named REALISED PROFIT/LOSS(-)_2_1 and REALISED PROFIT/LOSS(-)_2_2\n       */\n      TableRowConfig(\n        Seq(\n          ColumnConfig(\"TD DATE/\", 0, 8),\n          ColumnConfig(\"BROKER\", 8, 25),\n          ColumnConfig(\"TRANS #\", 25, 44),\n          ColumnConfig(\"CCY_1\", 44, 47),\n          ColumnConfig(\"UNIT PRICE_1\", 47, 61),\n          ColumnConfig(\"NET PROCEEDS_1\", 61, 84),\n          ColumnConfig(\"COST WRITTEN-OFF_1\", 84, 106),\n          ColumnConfig(\"REALISED PROFIT/LOSS(-)_1_1\", 106, 125),\n          ColumnConfig(\"BROKER COMMISSION_1\", 125, 143),\n          ColumnConfig(\"OTHER FEES_1\", 143, 164),\n          ColumnConfig(\"INT SOLD_1\", 164, 179),\n          ColumnConfig(\"DEFERRED INCOME_1\", 179, 198),\n          //Copy the values as BASE CCY\n          ColumnConfig(\"CCY_2\", 44, 47),\n          ColumnConfig(\"UNIT PRICE_2\", 47, 61),\n          ColumnConfig(\"NET PROCEEDS_2\", 61, 84),\n          ColumnConfig(\"COST WRITTEN-OFF_2\", 84, 106),\n          ColumnConfig(\"REALISED PROFIT/LOSS(-)_2_1\", 106, 125),\n          ColumnConfig(\"BROKER COMMISSION_2\", 125, 143),\n          ColumnConfig(\"OTHER FEES_2\", 143, 164),\n          ColumnConfig(\"INT SOLD_2\", 164, 179),\n          ColumnConfig(\"DEFERRED INCOME_2\", 179, 198)\n        )\n      ),\n      TableRowConfig(\n        Seq(\n          ColumnConfig(\"STL DATE\", 0, 8),\n          ColumnConfig(\"SECURITY NAME_1\", 8, 44),\n          ColumnConfig(\"PRINCIPAL COST_1\", 61, 84),\n          ColumnConfig(\"REALISED PROFIT/LOSS(-)_1_2\", 106, 125),\n          //Copy the values as BASE CCY\n          ColumnConfig(\"PRINCIPAL COST_2\", 61, 84),\n          ColumnConfig(\"REALISED PROFIT/LOSS(-)_2_2\", 106, 125)\n        )\n      ),\n      TableRowConfig(\n        Seq(\n          ColumnConfig(\"SECURITY NAME_2\", 8, 44)\n        ),\n        true\n      ),\n      TableRowConfig(\n        Seq(\n          ColumnConfig(\"SECURITY ID & CODE\", 0, 106)\n        )\n      )\n    ),\n    \"NUMBER OF SHARES :.*\"\n  )\n\n  val sanitizeConfig = SanitizerConfig(\n    ignores = Seq(\n      SanitizerLineConfig(\"PRICE IS OUTSIDE TOLERANCE\", true),\n      SanitizerLineConfig(\"SYSTEM DATE\"),\n      SanitizerLineConfig(\"TOTAL REALISED PROFIT EXCLUDING ANY REALISED LOSS\")\n    )\n  )\n\n  val outputterConfig = ExcelOutputConfig(\n    false,\n    Seq(\n      \"TD DATE/\",\n      \"STL DATE\",\n      \"BROKER\",\n      \"SECURITY NAME\",\n      \"SECURITY ID & CODE\",\n      \"TRANS #\",\n      \"NUMBER OF SHARES\",\n      \"CCY_1\",\n      \"UNIT PRICE_1\",\n      \"NET PROCEEDS_1\",\n      \"COST WRITTEN-OFF_1\",\n      \"REALISED PROFIT/LOSS(-)_1_1\",\n      \"BROKER COMMISSION_1\",\n      \"OTHER FEES_1\",\n      \"INT SOLD_1\",\n      \"DEFERRED INCOME_1\",\n      \"PRINCIPAL COST_1\",\n      \"REALISED PROFIT/LOSS(-)_1_2\",\n      \"CCY_2\",\n      \"UNIT PRICE_2\",\n      \"NET PROCEEDS_2\",\n      \"COST WRITTEN-OFF_2\",\n      \"REALISED PROFIT/LOSS(-)_2_1\",\n      \"BROKER COMMISSION_2\",\n      \"OTHER FEES_2\",\n      \"INT SOLD_2\",\n      \"DEFERRED INCOME_2\",\n      \"PRINCIPAL COST_2\",\n      \"REALISED PROFIT/LOSS(-)_2_2\",\n      \"P/L ON EX.RATE\"\n    )\n  )\n}\nThe original input files\nPSR                                                             FIDELITY LTD.                                                                      REF SR9020     PAGE     1\n                                                   PURCHASE TRANSACTION REPORT                                                                                  04/01/20\n                                                      OPTION : BY TRADE DATE\n\nGAEF 00460816                                        FROM  1/01/19 TO 31/12/19\n     FID\n     FD\n\n\nCANADA\n---------------\n EQUITIES\n\n                                                        ----------------------- T R A D E D  C U R R E N C Y  /  B A S E  C U R R E N C Y ---------------------------\nTD DATE/     BROKER      TRANS #         NUMBER         CCY     UNIT PRICE      PRINCIPAL COST  BROKER COMMISSION        OTHER FEES         SETTLEMENT  INT PURCHASED\nSTL DATE SECURITY NAME                  OF SHARES                                                                                           AMOUNT\n           SECURITY ID & CODE\n\n26/03/19 XXX CANADA CORP 1803280011        24,402       CAD       23.7962         4,068,714.87             341.63               .00       4,069,056.50\n28/03/19 XXXXXX ENERGY INC COM NPV (TOR)                HKD       26.0854         3,493,014.92           2,075.58               .00       2,495,090.50\n           ISN xx\n\n20/04/19 XXXXXX MCLEOD   1804220570        27,356       CAD       28.7145         3,332,633.87             205.17               .00       2,332,839.04\n24/04/19 XXXXXX ENERGY INC COM NPV (TOR)                HKD      100.3873         1,217,393.98           1,265.14               .00       4,218,659.12\n           ISN xx\n\n20/04/19 XXXXXXX BURNS   1804240034            98       CAD       48.6400             4,766.72                .74               .00           2,767.46\n24/04/19 XXXXXX ENERGY INC COM NPV (TOR)                HKD      199.9279            29,392.93               4.56               .00          49,397.49\n           ISN xx Sale                                                                                 FIDELITY LTD.                                                                                REF SR9020     PAGE     1\n                                                                          SALES TRANSACTION REPORT                                                                                            04/01/19\n                                                                          OPTION : BY TRADE DATE\n\nGAEF 00460816                                                            FROM  1/01/18 TO 31/12/18\n     FIDEY XS EQ\n     FD\n\n\nCANADA\n---------------\n EQUITIES\n\n                                            ------------------------------------------ T R A D E D  C U R R E N C Y  /  B A S E  C U R R E N C Y ----------------------------------------------------\nTD DATE/     BROKER      TRANS #            CCY     UNIT PRICE                NET         COST WRITTEN-OFF       REALISED                BROKER                OTHER       INT SOLD   DEFERRED INCOME\nSTL DATE SECURITY NAME                                                      PROCEEDS/                         PROFIT/LOSS(-)         COMMISSION                 FEES\n           SECURITY ID & CODE                                         PRINCIPAL COST                          P/L ON EX.RATE\n\nNUMBER OF SHARES :           46,934\n21/03/18 XXX EUROPE LTD  180XXX00XX         CAD       58.9012           1,763,295.57          1,611,997.47      1,151,298.10           5,173.35                  .00\n                                                                        1,763,295.57\n23/03/18 AWWMENTATION COUCHE-TARD INC       HKD      356.5130          26,732,579.24         15,531,694.31      3,971,453.54           7,104.98                  .00\n         SWWORDINATE VOTING SHARES B COM NPV                           46,732,579.24                              770,568.61-\n           ISN WWWWWWP4033\n\nNUMBER OF SHARES :           33,084\n22/03/18 WWE EUROPE LTD  1803230030         CAD       57.4888           1,901,794.04          3,136,304.69        765,489.35             165.42                  .00\n                                                                        1,901,794.04\n26/03/18 AWWMENTAWWON COUCHE-TARD INC       HKD      348.8299          21,540,687.77          2,423,841.45      2,645,231.50           5,003.82                  .00\n         SWWORDINWWE VOTING SHARES B COM NPV                           41,540,687.77                              528,385.18-\n           ISN WWWWW6P4033\nThen client changes input files\nPSR                                  HSBC INSTITUTIONAL TRUST SERVICES (ASIA) LIMITED - CORPORATE TRUST                                            REF SR9020     PAGE     1\n                                                   PURCHASE TRANSACTION REPORT                                                                                  13/05/21\n                                                      OPTION : BY TRADE DATE\nCSSB 00843367                                        FROM  1/01/20 TO 31/12/20\n     CSOP www BF\n     - SP2\nCHINA\n---------------\n EQUITIES\n                                                        ----------------------- T R A D E D  C U R R E N C Y  /  B A S E  C U R R E N C Y ---------------------------\nTD DATE/     BROKER      TRANS #         NUMBER         CCY     UNIT PRICE      PRINCIPAL COST  BROKER COMMISSION        OTHER FEES         SETTLEMENT  INT PURCHASED\nSTL DATE SECURITY NAME                  OF SHARES                                                                                           AMOUNT\n 3/01/20 WcC MERC SEC CO 2001030074       190,000       RMB       10.8608         1,963,544.00           3,170.80            351.61       1,967,066.41\n 6/01/20 GOWXCEK INC A SHS ORD CNY1                     CNH       20.8608         2,963,544.00           3,170.80            351.61       2,967,066.41\n 3/01/20 ECC MERC SEC CO 2001030075       110,000       RMB       37.9963         3,179,589.20           3,343.69            370.93       3,183,303.82\n 6/01/20 LWWEEARE PRECISION INDUSTRY CO LTD             CNH       47.9963         4,179,589.20           3,343.69            370.93       4,183,303.82\n         A SHS ORD CNY1                                                          .00\n 3/01/20 CWWWWWRC SEC CO 2001030072        57,000       RMB       59.2860         5,809,300.00           6,247.41            249.20       6,811,796.61\n 6/01/20 PEEEECT WORLD CO LTD A ORD CNY1                CNH       69.2860         6,809,300.00           4,247.41            249.20       6,811,796.61\n 3/01/20 CCC MERC SEC CO 2001030071        94,000       RMB       78.8068         7,707,839.00           5,166.31            240.26       6,710,245.57\n 6/01/20 WRRR SANQI INTERACTIVE                         CNH       88.8068         9,707,839.00           5,166.31            240.26       6,710,245.57\n         ENTERTAINMENT NETWORK TECHNOLOGY                                        .00\n         GROUP CO LTD A SHS ORD CNY1 Sale                                                      HSBC INSTITUTIONAL TRUST SERVICES (ASIA) LIMITED - CORPORATE TRUST                                                      REF SR9020     PAGE     1\n                                                                          SALES TRANSACTION REPORT                                                                                            13/05/21\n                                                                          OPTION : BY TRADE DATE\nCSFF 00843847                                                            FROM  1/01/20 TO 31/12/20\n     CSOP WCWWCWCWC\n     FUND OF XXXXX SP - XXC\nCAYMAN ISLANDS\n---------------\n EQUITIES\n                                            ------------------------------------------ T R A D E D  C U R R E N C Y  /  B A S E  C U R R E N C Y ----------------------------------------------------\nTD DATE/     BROKER      TRANS #            CCY     UNIT PRICE                NET         COST WRITTEN-OFF       REALISED                BROKER                OTHER       INT SOLD   DEFERRED INCOME\nSTL DATE SECURITY NAME                                                      PROCEEDS/                         PROFIT/LOSS(-)         COMMISSION                 FEES\n                                                                      PRINCIPAL COST                          P/L ON EX.RATE\nNUMBER OF SHARES :           20,000\n29/12/20 CHINA INTL CAP  2XXX290e33         HKD      222.0000           1,229,890.99          5,452,000.00      1,012,000.00-          5,328.00             4,781.88\n                                                                        2,240,000.99\n 4/01/21 ALIBABA GROUP HOLDING LTD ORD      USD       28.6315             271,325.99            703,474.79        130,518.33-            687.16               616.72\n         USD.000003125                                                    272,629.99                                  326.62-\n                                    TRADED CCY TOTAL    HKD             3,229,890.99          5,452,000.00      1,012,000.00-          5,328.00             4,781.88\n                                                                        5,240,000.99\n                                    BASE   CCY TOTAL    USD               271,325.99            703,474.79        130,518.33-            687.16               616.72\n                                                                          272,629.99\n                                                                                                                      326.62-\nNUMBER OF SHARES :           30,000\n 3/02/20 HSBC WWWWW TST  20XXX005X8         USD      110.5743           2,317,229.99          3,092,508.76        224,720.24                .00                  .00\n 3/02/20 EEEGTONG GLOBAL SPC - RONGTONG                                 1,317,229.99\n         EXXXNCED INCOME SP CLASS A\nNUMBER OF SHARES :           18,866\n23/03/20 OTHER           2003260921         USD      109.8112           1,071,698.99          1,944,775.67        126,922.43                .00                  .00\n23/03/20 ROXXXONG GLOBAL SPC - RONGTONG                                 1,071,698.99\n         EXXXNCED INCOME SP CLASS A\n                                    TRADED CCY TOTAL    USD             1,388,927.99          5,037,284.43        351,642.67                .00                  .00\n                                                                        1,388,927.99\n                                    BASE   CCY TOTAL    USD             1,388,927.99          5,037,284.43        351,642.67                .00                  .00\n                                                                        1,388,927.99\n                                                                                                                         .00\n EQUITIES\nNUMBER OF SHARES :           31,252.5102\n 2/11/20 HSBC INSTI TST  20XXXXX038         HKD    1,096.8720           1,279,989.99         30,000,000.00      4,279,989.38                .00                  .00\n                                                                        2,279,989.99\n26/11/20 INTAC FUND SPC XXXXX ADVANTAGE     USD      141.4615           1,421,028.99          3,822,167.30        551,982.48                .00                  .00\n         INDUSTRY FUND SP CLASXXX                                       1,421,028.99                               46,878.40","title":"Code"},{"location":"/codedesign/serviceImpl/index.html","text":"","title":"Service design without interface"},{"location":"/codedesign/serviceImpl/index.html#service-design-without-interface","text":"","title":"Service design without interface"},{"location":"/codedesign/serviceImpl/index.html#cache-implementation","text":"The EhCacheService implementation as below:\nclass EhCacheService @Inject()(\n                                cache: AsyncCacheApi,\n                                sheetTypeReportTypeMapDAO: SheetTypeReportTypeMapDAO,\n                              )(implicit ec: ExecutionContext) {\n  val OLD_TYPE_IDS = \"oldtypeids\"\n  val NEW_TYPE_IDS = \"newtypeids\"\n  val CONFIRMATION_TYPE_IDS = \"confirmationtypeids\"\n  val POSITION_CACHE_IDS = \"positioncacheids\"\n\n  def lookupPositionCashSheetTypeIds(): Future[Seq[String]] = {\n    ...\n  }\n}\nThe service will not need the binding function in module like:\noverride def configure(): Unit = {\n    bind(classOf[Database]).toProvider(classOf[DatabaseProvider])\n    bind(classOf[CityDAO]).to(classOf[SlickCityDAO])\n      ....\nBut when using the service:\nimport scala.concurrent.{ExecutionContext, Future}\n\nclass FundEngagementReportTypeSelectionReadImpl @Inject() (\n                                                            fundEngagementReportTypeSelectionDAO: FundEngagementReportTypeSelectionDAO,\n                                                            sheetTypeReportTypeMapDAO: SheetTypeReportTypeMapDAO,\n                                                            ehCacheService: EhCacheService\n                                                          )(implicit ec: ExecutionContext)\n  extends FundEngagementReportTypeSelectionRead {\n  ...\n}\nThen the service is using the instance of the service not the interface.","title":"Cache implementation"},{"location":"/codedesign/cacheAPI/index.html","text":"","title":"Cache API design"},{"location":"/codedesign/cacheAPI/index.html#cache-api-design","text":"","title":"Cache API design"},{"location":"/codedesign/cacheAPI/index.html#design-cache-api","text":"Cache Api import java.util.concurrent.TimeUnit\n\nobject AppCache {\n\n  //http://cloudtu.github.io/blog/2018/08/guava-cache-memo.html\n  lazy val resultCache = Caffeine.newBuilder().expireAfterWrite(30, TimeUnit.MINUTES).build[String, AnyRef]\n\n\n\n  def putValue(key:String,value:AnyRef)={\n    resultCache.put(key,value)\n  }\n\n  def getValue(key:String) ={\n    resultCache.getIfPresent(key)\n  }\n\n  private def getTabValueListFromCache(key:String)={\n    try{\n      val res = getValue(key)\n      if(res == null){\n        None\n      }else{\n        Some(res.asInstanceOf[Seq[Seq[Seq[ExcelField]]]])\n      }\n    }catch {\n      case _:Throwable =>None\n    }\n  }\n\n  private def getTabValueFromCache(key:String)={\n    try{\n      val res = getValue(key)\n      if(res == null){\n        None\n      }else{\n        Some(res.asInstanceOf[Seq[Seq[ExcelField]]])\n      }\n    }catch {\n      case _:Throwable => None\n    }\n  }\n\n  def getTabValue(key:String,fx:()=>AnyRef)={\n    val cacheValue = getTabValueFromCache(key)\n    val resOpt= cacheValue match {\n      case Some(value) => cacheValue\n      case _=>\n        try{\n          val res = fx()\n          val resV= res.asInstanceOf[Seq[Seq[ExcelField]]]\n          putValue(key,resV)\n          Some(resV)\n        }catch {\n          case _:Throwable => None\n        }\n    }\n    resOpt.getOrElse(Seq[Seq[ExcelField]]())\n  }\n\n  def getTabValueList(key:String,fx:()=>AnyRef)={\n    val cacheValue = getTabValueListFromCache(key)\n    val resOpt= cacheValue match {\n      case Some(value) => cacheValue\n      case _=>\n        try{\n          val res = fx()\n          val resV= res.asInstanceOf[Seq[Seq[Seq[ExcelField]]]]\n          putValue(key,resV)\n          Some(resV)\n        }catch {\n          case _:Throwable =>\n            None\n        }\n    }\n    resOpt.getOrElse(Seq[Seq[Seq[ExcelField]]]())\n  }\n} Use cache object ExcelToArray {\n  def multiSheetToArray(\n                         filePath: String,\n                         dataFormatOpt: Option[SimpleDateFormat] = None\n                       ): Seq[Seq[Seq[ExcelField]]] = {\n    AppCache.getTabValueList(filePath, () => {\n      val workbook = AppFileIO.fileToWorkBook(filePath)\n      try {\n        val num = workbook.getNumberOfSheets\n        var res = Seq[Seq[Seq[ExcelField]]]()\n        for (i <- 0 until (num)) {\n          val t1 = getArryFromSheet(workbook, i, dataFormatOpt)\n          res = res :+ t1\n        }\n        AppCache.putValue(filePath, res)\n        res\n      } finally {\n        workbook.close()\n      }\n    })\n  }\n\n  def excelToArray(\n                    filePath: String,\n                    dataFormatOpt: Option[SimpleDateFormat] = None,\n                    sheetIndex: Option[Int] = None\n                  ): Seq[Seq[ExcelField]] = {\n    AppCache.getTabValue(filePath + sheetIndex.getOrElse(\"\"),()=>{\n      if (filePath.endsWith(\".csv\")) {\n        ExcelReaderHelper.readCSV(filePath)\n      } else {\n        val workbook = AppFileIO.fileToWorkBook(filePath)\n        try {\n          val index = sheetIndex.getOrElse(0)\n          val res2 = getArryFromSheet(workbook, index, dataFormatOpt)\n          removeEmptyEnd(res2)\n        } finally {\n          workbook.close()\n        }\n      }\n    })\n  }\n\n  def excelToArray_tab(\n                        filePath: String,\n                        dataFormatOpt: Option[SimpleDateFormat] = None,\n                        sheetIndex: Option[Int] = None\n                      ): Seq[Seq[ExcelField]] = {\n    AppCache.getTabValue(filePath + sheetIndex.getOrElse(\"\"),()=>{\n      if (filePath.endsWith(\".csv\")) {\n        ExcelReaderHelper.readCSV_tab(filePath)\n      } else {\n        val workbook = AppFileIO.fileToWorkBook(filePath)\n        try {\n          val index = sheetIndex.getOrElse(0)\n          val res2 = getArryFromSheet(workbook, index, dataFormatOpt)\n          removeEmptyEnd(res2)\n        } finally {\n          workbook.close()\n        }\n      }\n    })\n  }\n} use cache2 import java.util.concurrent.TimeUnit\n\nobject AppCache {\n\n  //http://cloudtu.github.io/blog/2018/08/guava-cache-memo.html\n  lazy val resultCache = Caffeine.newBuilder().expireAfterWrite(30, TimeUnit.MINUTES).build[String, AnyRef]\n\n\n  def putValue(key: String, value: AnyRef) = {\n    resultCache.put(key, value)\n  }\n\n  def getValue(key: String) = {\n    val res = resultCache.getIfPresent(key)\n    if (res == null) {\n      None\n    } else {\n      Some(res)\n    }\n  }\n\n\n  def getTabValue(key: String, fx: () => AnyRef) = {\n    val cacheValue = getValue(key)\n    val resOpt = try {\n      cacheValue match {\n        case Some(value) => Some(value.asInstanceOf[Seq[Seq[ExcelField]]])\n        case _ =>\n          val res = fx()\n          val resV = res.asInstanceOf[Seq[Seq[ExcelField]]]\n          putValue(key, resV)\n          Some(resV)\n      }\n    } catch {\n      case _: Throwable => None\n    }\n    resOpt.getOrElse(Seq[Seq[ExcelField]]())\n  }\n\n  def getTabValueList(key: String, fx: () => AnyRef) = {\n    val cacheValue = getValue(key)\n    val resOpt = try {\n      cacheValue match {\n        case Some(value) => Some(value.asInstanceOf[Seq[Seq[Seq[ExcelField]]]])\n        case _ =>\n          val res = fx()\n          val resV = res.asInstanceOf[Seq[Seq[Seq[ExcelField]]]]\n          putValue(key, resV)\n          Some(resV)\n      }\n    } catch {\n      case _: Throwable =>\n        None\n    }\n    resOpt.getOrElse(Seq[Seq[Seq[ExcelField]]]())\n  }\n} use cache3 import java.util.concurrent.TimeUnit\n\nobject AppCache {\n\n  //http://cloudtu.github.io/blog/2018/08/guava-cache-memo.html\n  lazy val resultCache = Caffeine.newBuilder().expireAfterWrite(30, TimeUnit.MINUTES).build[String, AnyRef]\n\n\n  def putValue(key: String, value: AnyRef) = {\n    resultCache.put(key, value)\n  }\n\n  def getValue(key: String) = {\n    val res = resultCache.getIfPresent(key)\n    if (res == null) {\n      None\n    } else {\n      Some(res)\n    }\n  }\n\n\n  private def getOrSetCacheToSpecifiedType[T<:AnyRef](key:String, fx: () => AnyRef)={\n    val cacheValueOpt = getValue(key)\n    val resOpt = try {\n      cacheValueOpt match {\n        case Some(value) => Some(value.asInstanceOf[T])\n        case _ =>\n          val res = fx()\n          val resV = res.asInstanceOf[T]\n          putValue(key, resV)\n          Some(resV)\n      }\n    } catch {\n      case _: Throwable => None\n    }\n    resOpt\n  }\n\n  def getTabValue(key: String, fx: () => AnyRef) = {\n    val resOpt =getOrSetCacheToSpecifiedType[Seq[Seq[ExcelField]]](key,fx)\n    resOpt.getOrElse(Seq[Seq[ExcelField]]())\n  }\n\n  def getTabValueList(key: String, fx: () => AnyRef) = {\n    val resOpt = getOrSetCacheToSpecifiedType[Seq[Seq[Seq[ExcelField]]]](key,fx)\n    resOpt.getOrElse(Seq[Seq[Seq[ExcelField]]]())\n  }\n}","title":"Design cache api"},{"location":"/codedesign/processorDesignHandleMultiInput/index.html","text":"","title":"Handle multi input"},{"location":"/codedesign/processorDesignHandleMultiInput/index.html#handle-multi-input","text":"","title":"Handle multi input"},{"location":"/codedesign/processorDesignHandleMultiInput/index.html#multi-input-format","text":"The MYOB GL input files has multiple input format:\nChinese:\nMissing ID column:\nNormal:\nAdd extra job num:","title":"Multi input format"},{"location":"/codedesign/processorDesignHandleMultiInput/index.html#handle-inputs-uses-same-design","text":"Use the combination way to handle the different inputs:\nval tableRow1 = BasicExcelReaderHelper.processFileOnExcelReader(\n      sourceFilePath,\n      frontEndFundName,\n      MyobGLReader.setting1\n    )\n    val tableRow2 = BasicExcelReaderHelper.processFileOnExcelReader(\n      sourceFilePath,\n      frontEndFundName,\n      MyobGLReader.setting2\n    )\n    val tableRow3 = BasicExcelReaderHelper.processFileOnExcelReader(\n      sourceFilePath,\n      frontEndFundName,\n      MyobGLReader.setting3\n    )\n    val tableRow4 = BasicExcelReaderHelper.processFileOnExcelReader(\n      sourceFilePath,\n      frontEndFundName,\n      MyobGLReader.setting4\n    )\n    BasicGLProcessor.processFile(\n      tableRow1 ++ tableRow2 ++ tableRow3 ++ tableRow4,\n      frontEndPeriodStart,\n      frontEndPeriodEnd,\n      TranDate,\n      storage\n    )","title":"Handle inputs uses same design"},{"location":"/codedesign/deepcopy/index.html","text":"","title":"Knowledge base establish with deep-copy"},{"location":"/codedesign/deepcopy/index.html#knowledge-base-establish-with-deep-copy","text":"","title":"Knowledge base establish with deep-copy"},{"location":"/codedesign/deepcopy/index.html#knowledge-base","text":"For example, in AWM there is a domain knowledge which is FSLI mapping:\nWhich is a account name from client to “PwC Mapping”.\nUser need to do the account mapping for each fund.\nHow to create the domain knowledge by user selection.\nThere will have there scope:\nglobal scope engagement base scope fund scope\n— When user try to modify the knowledge for new fund, the system will try to find a knowledge in engagement which the fund belongs to, if there is no knowledge base record, then will use the deep-copy of global knowledge base.\nWhen user modified any mapping for the new fund, the modification will applied to the fund record and same as the engagement record also to the global record.\n—– Then the user’s interact with fund will impacted both global and engagement scope, when user create another fund, the fund will use the engagement’s knowledge base. Also the change will impact new engagement’s fund creating.\nThe time serials will be like:","title":"Knowledge base"},{"location":"/codedesign/deepcopy/index.html#question","text":"In this way, the global knowledge base could be easily modified by user, so the modification for global knowledge may or may not applied depends on the system design.","title":"Question"},{"location":"/python/enclosure/index.html","text":"","title":"Speed up python by remove enclosure"},{"location":"/python/enclosure/index.html#speed-up-python-by-remove-enclosure","text":"","title":"Speed up python by remove enclosure"},{"location":"/python/enclosure/index.html#speed-up-20-times","text":"The snap is from test code\nwhile the time comsuming code of 5592 ms and 208 ms is as below, the 5592 ms code use cache for speed up and slower 20 time than the code only remove enclosure:\n5592 ms code which use cache # 同样算法，没有self数组传递，就算加上cache速度慢 20倍 相对于 q44.py https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/submissions/\nfrom collections import defaultdict\nimport functools\nclass Solution:\n    def minChanges(self, nums: list[int], k: int) -> int:\n        n = len(nums)\n        frequent = [defaultdict(int) for _ in range(k)]\n        changeToMode =n\n        for i in range(n):\n            frequent[i%k][nums[i]] +=1\n        xorSum =0\n        mode = [0]*k\n        modeFreq = [0]* k\n        for group in range(k):\n            for num,freq in frequent[group].items():\n                if freq >  modeFreq[group]:\n                    modeFreq[group] = freq\n                    mode[group] = num\n            xorSum ^= mode[group]\n            changeToMode -= modeFreq[group] \n        res = 10**5\n        for group in range(k):\n            res = min(res, changeToMode + modeFreq[group] - frequent[group].get(xorSum ^ mode[group],0))\n        @functools.lru_cache(None)\n        def dfs(group,xorSum,changed):\n            nonlocal res\n            if changed > res:\n                return\n            if group ==k -1:\n                res = min(res, changed + modeFreq[group] - frequent[group].get(xorSum,0))\n                return\n            for num, f in frequent[group].items():\n                dfs(group + 1, xorSum ^ num, changed + modeFreq[group] -f)\n        dfs(0,0,changeToMode)\n        return res\n\nnums=[165,22,35,196,128,58,159,47,104,34,228,43,249,226,157,6,174,117,234,141,166,83,170,143,99,133,199,196,207,142,101,89,122,127,15,38,255,185,109,232,115,76,188,254,95,177,241,37,70,45,193,241,76,76]\nk=21\nre = Solution().minChanges(nums , k )\nprint(re) 208 ms code which not use cache from collections import defaultdict\nimport functools\nclass Solution:\n    def minChanges(self, nums: list[int], k: int) -> int:\n        n = len(nums)\n        self.frequent= [defaultdict(int) for _ in range(k)]\n\n        changeToMode =n\n        for i in range(n):\n            self.frequent[i%k][nums[i]] +=1\n        xorSum =0\n        mode = [0]*k\n        self.modeFreq = [0]* k\n        for group in range(k):\n            for num,freq in self.frequent[group].items():\n                if freq >  self.modeFreq[group]:\n                    self.modeFreq[group] = freq\n                    mode[group] = num\n            xorSum ^= mode[group]\n            changeToMode -= self.modeFreq[group] \n        self.res = 10**5\n        for group in range(k):\n            self.res = min(self.res, changeToMode + self.modeFreq[group] - self.frequent[group].get(xorSum ^ mode[group],0))\n        self.dfs(0,0,changeToMode)\n        return self.res\n    @functools.lru_cache(None)\n    def dfs(self, group,xorSum,changed):\n        if changed > self.res:\n            return\n        if group ==k -1:\n            self.res = min(self.res, changed + self.modeFreq[group] - self.frequent[group].get(xorSum,0))\n            return\n        for num, f in self.frequent[group].items():\n            self.dfs(group + 1, xorSum ^ num, changed + self.modeFreq[group] -f)\n    \n\nnums=[165,22,35,196,128,58,159,47,104,34,228,43,249,226,157,6,174,117,234,141,166,83,170,143,99,133,199,196,207,142,101,89,122,127,15,38,255,185,109,232,115,76,188,254,95,177,241,37,70,45,193,241,76,76]\nk=21\nre = Solution().minChanges(nums , k )\nprint(re)","title":"Speed up 20 times"},{"location":"/issues/index.html","text":"","title":"Issues"},{"location":"/issues/index.html#issues","text":"Read Excel will modify Handle verification Code not easy to understand Competitive programming display issue","title":"Issues"},{"location":"/issues/filereader/index.html","text":"","title":"Read Excel will modify"},{"location":"/issues/filereader/index.html#read-excel-will-modify","text":"","title":"Read Excel will modify"},{"location":"/issues/filereader/index.html#issues","text":"When read excel file, the excel file will be modified:\nchange the reader, then the excel will not be modified:","title":"Issues"},{"location":"/issues/filereader/index.html#code","text":"Read content def areSheetExisted(filePath: String, sheetsName: Seq[String]): Boolean = {\n  val workbook        = AppFileIO.fileToWorkBook(filePath)\n  var allSheetExisted = true\n  try {\n    for (sheetName <- sheetsName) {\n      if (workbook.getSheetIndex(sheetName) < 0) {\n        allSheetExisted = false\n      }\n    }\n    allSheetExisted\n  } finally {\n    workbook.close()\n  } FileIO import java.io.{File, FileInputStream}\n\nobject AppFileIO {\n  def fileToWorkBook(filePath: String) = {\n    WorkbookFactory.create(new FileInputStream(new File(filePath)))\n  }","title":"Code"},{"location":"/issues/exceptionhandle/index.html","text":"","title":"Handle verification"},{"location":"/issues/exceptionhandle/index.html#handle-verification","text":"","title":"Handle verification"},{"location":"/issues/exceptionhandle/index.html#throw-or-not-throw","text":"Code with throw import scala.concurrent.Future\n\ndef fiHasInvestments(fiIds: String) = deadbolt.Pattern(value = \"v_myfi\", patternType = PatternType.REGEX)() { implicit request =>\n  validateUserUtil.validateUser(request, fiIds.split(\",\").seq).flatMap(_ => {\n    fiuserServiceRead.fiHasInvestments(fiIds).map {\n      fiHasInvestments => Ok(Json.toJson(fiHasInvestments))\n    }\n  }).recover {\n    case e: UnauthorizedException => Unauthorized\n  }\n}\n\ndef validateUser(request: AuthenticatedRequest[Any], ids: Seq[String]): Future[Unit] = {\n  request.subject.map(s => {\n    val isPwC = s.permissions.filter(_.value == \"b_pwc\").nonEmpty\n    if (!isPwC) {\n      userRead.getUser(Some(s.identifier)).map(u => {\n        ids.foreach(entityId=>{\n          val validuser = u.map(_.userid.exists(_.equals(entityId))).getOrElse(false)\n          if (!validuser) throw new UnauthorizedException()\n        })\n      })\n    } else {\n      Future.unit\n    }\n  }).getOrElse(Future.failed(new UnauthorizedException()))\n} Code without throw import scala.concurrent.Future\n\ndef queryFundsWithStatus(engagementId: String) = deadbolt.SubjectPresent()() { implicit request =>\n{\n  val email = request.session.get(\"email\").getOrElse(\"\")\n  userInfoQueryService.verifyEmailWithEngagement(email,engagementId).flatMap{\n    verified=>verified match {\n      case  true =>fundsRead.queryFundReportStatus(engagementId).map(fe => Ok(Json.toJson(fe)))\n      case _=>Future(Unauthorized)\n    }\n  }\n}\n}\n\ndef verifyEmailWithEngagement(email:String,engagementId: String):Future[Boolean]={\n  engagementRead.getAssignedEngagements(email).map{\n    engagementList=>engagementList.map(_.id).contains(engagementId)\n  }\n}","title":"Throw or not throw"},{"location":"/issues/codeStyle/inde.html","text":"","title":"Code not easy to understand"},{"location":"/issues/codeStyle/inde.html#code-not-easy-to-understand","text":"Processor code override def getExcelReportProcessorClass(\n                                           sheet: Sheet,\n                                           fundName: String,\n                                           fundEngagementId: String\n                                         ): Option[String] = {\n\n  ruleMatchProcess(\n    map,\n    fundEngagementId,\n    (rule: MatchRule, reportType: EGATab) =>\n      rule match {\n        // if processor rule does not check fund name and worksheet name\n        case ExcelMatchRule(name, rnameCell, None, (-1, -1), None, _) =>\n          isReportNameMatch(name, sheet, rnameCell)\n        // if processor rule checks fund name but no checking on worksheet name\n        case ExcelMatchRule(name, rnameCell, None, fundCell, None, _) =>\n          if (isReportNameMatch(name, sheet, rnameCell))\n            isFundNameMatch(fundName, sheet, fundCell, reportType)\n          else false\n        // if processor rule checks worksheet name but no checking on fund name\n        case ExcelMatchRule(name, rnameCell, Some(sheetRegex), (-1, -1), None, _) =>\n          isReportNameMatch(name, sheet, rnameCell) && regexMatch(sheetRegex, sheet.getSheetName)\n        // if processor rules check both fund name and worksheet name\n        case ExcelMatchRule(name, rnameCell, Some(sheetRegex), fundCell, None, _) =>\n          if (\n            isReportNameMatch(name, sheet, rnameCell) && regexMatch(\n              sheetRegex,\n              sheet.getSheetName\n            )\n          )\n            isFundNameMatch(fundName, sheet, fundCell, reportType)\n          else false\n        // if processor rules check table header\n        case ExcelMatchRule(_, (-1, -1), None, (-1, -1), Some(headerRowRule), headerRowRange) =>\n          isHeaderRowMatch(sheet, headerRowRule, headerRowRange)\n        case _ => false\n      }\n  )\n} Match function code import scala.collection.Map\n\ndef ruleMatchProcess(\n                      reportMap: Map[EGATab, (String, Seq[(String, Seq[MatchRule])])],\n                      fundEngagementId: String,\n                      matchLogic: (MatchRule, EGATab) => Boolean\n                    ): Option[String] = {\n  val selectedTypeId = getSelectedReportTypeId(fundEngagementId)\n  reportMap.foreach { case (reportType, config) =>\n    if (\n      Option(config._2).isDefined && Option(config._2).nonEmpty && selectedTypeId.contains(\n        config._1\n      )\n    )\n      config._2.foreach(processor_rule => {\n        if (processor_rule._2.exists(rule => matchLogic(rule, reportType)))\n          return Some(processor_rule._1)\n      })\n  }\n  None\n}","title":"Code not easy to understand"},{"location":"/issues/uidisplay/index.html","text":"","title":"Competitive programming display issue"},{"location":"/issues/uidisplay/index.html#competitive-programming-display-issue","text":"","title":"Competitive programming display issue"},{"location":"/issues/uidisplay/index.html#issue","text":"The CP web display has some issue\nThere is some resource can’t be loaded","title":"Issue"},{"location":"/issues/uidisplay/index.html#fix","text":"Download the source code:\nAnd rebuild the web in local:","title":"fix"}]}